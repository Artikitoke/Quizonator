{"version":3,"file":"contentScript.bundle.js","mappings":"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","sources":["webpack://quizonator/./src/content/core/api.js","webpack://quizonator/./src/content/platforms/Moodle.js","webpack://quizonator/./src/content/platforms/TestPortal.js","webpack://quizonator/./src/content/platforms/MicrosoftForms.js","webpack://quizonator/./src/content/platforms/Quizziz.js","webpack://quizonator/./src/content/platforms/GoogleForms.js","webpack://quizonator/./src/content/platforms/Naurok.js","webpack://quizonator/./src/content/platforms/Vseosvita.js","webpack://quizonator/./src/content/Analitics/SummaryProcessor.js","webpack://quizonator/./src/content/core/DOMChangesToggler.js","webpack://quizonator/./src/content/core/contentScript.js"],"sourcesContent":["// api.js\r\n\r\nexport function sendQuestionToChatGPT(questionText, possibleAnswers, questionType, inputCount, currentOrder, isMultipleCorrect = false, imageBase64Strings = []) {\r\n    return new Promise((resolve, reject) => {\r\n        const formattedPrompt = formatQuestionForChatGPT(questionText, possibleAnswers, questionType, inputCount, currentOrder, isMultipleCorrect, imageBase64Strings);\r\n        const imageUrl = imageBase64Strings.length > 0 ? imageBase64Strings[0] : null;\r\n        chrome.runtime.sendMessage({\r\n            type: \"QUERY_CHATGPT\",\r\n            questionText: formattedPrompt,\r\n            imageUrl: imageUrl,\r\n            originalQuestionText: questionText\r\n\r\n        }, (response) => {\r\n            if (response && response.answer) {\r\n                resolve(response.answer);\r\n            } else {\r\n                reject(\"No answer received from ChatGPT.\");\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function sendQuestionToChatGPTNew(questionData, isMultipleCorrect) {\r\n    return new Promise((resolve, reject) => {\r\n        chrome.runtime.sendMessage({\r\n            type: \"QUERY_CHATGPT_NEW\",\r\n            questionData: questionData,\r\n            isMultipleCorrect: isMultipleCorrect,\r\n        }, (response) => {\r\n            if (response && response.answer) {\r\n                resolve(response.answer);\r\n            } else {\r\n                reject(\"No answer received from ChatGPT.\");\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nexport function sendQuestionToChatGPTMicrosoftForms(questionData, isMultipleCorrect) {\r\n    return new Promise((resolve, reject) => {\r\n        chrome.runtime.sendMessage({\r\n            type: \"QUERY_CHATGPT_MF\",\r\n            questionData: questionData,\r\n            isMultipleCorrect: isMultipleCorrect,\r\n        }, (response) => {\r\n            if (response && response.answer) {\r\n                resolve(response.answer);\r\n            } else {\r\n                reject(\"No answer received from ChatGPT.\");\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function sendQuestionToChatGPTGoogleForms(questionData, isMultipleCorrect) {\r\n    return new Promise((resolve, reject) => {\r\n        chrome.runtime.sendMessage({\r\n            type: \"QUERY_CHATGPT_MF\",\r\n            questionData: questionData,\r\n            isMultipleCorrect: isMultipleCorrect,\r\n            platform: \"googleForms\" // Specify this is from Google Forms\r\n        }, (response) => {\r\n            if (response && response.answer) {\r\n                resolve(response.answer);\r\n            } else {\r\n                reject(\"No answer received from ChatGPT.\");\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function sendQuestionToBackendNaurok(questionData, isMultipleCorrect) {\r\n    return new Promise((resolve, reject) => {\r\n        chrome.runtime.sendMessage({\r\n            type: \"QUERY_CHATGPT_MF\",\r\n            questionData: questionData,\r\n            isMultipleCorrect: isMultipleCorrect,\r\n            platform: \"naurok\" // Specify this is from Naurok\r\n        }, (response) => {\r\n            if (response && response.answer) {\r\n                resolve(response.answer);\r\n            } else {\r\n                reject(\"No answer received from ChatGPT.\");\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function sendQuestionToBackendVseosvita(questionData, isMultipleCorrect) {\r\n    return new Promise((resolve, reject) => {\r\n        chrome.runtime.sendMessage({\r\n            type: \"QUERY_CHATGPT_MF\",\r\n            questionData: questionData,\r\n            isMultipleCorrect: isMultipleCorrect,\r\n            platform: \"vseosvita\" // Specify this is from Vseosvita\r\n        }, (response) => {\r\n            if (response && response.answer) {\r\n                resolve(response.answer);\r\n            } else {\r\n                reject(\"No answer received from ChatGPT.\");\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function sendQuizizzRequest(quizId, mode) {\r\n    return new Promise((resolve, reject) => {\r\n        chrome.runtime.sendMessage({\r\n            type: \"QUERY_CHATGPT_MF\",\r\n            platform: \"quizizz\",\r\n            quizId: quizId,\r\n            mode: mode\r\n        }, (response) => {\r\n            if (response && response.answer) {\r\n                resolve(response.answer);\r\n            } else {\r\n                reject(\"No answer received from backend.\");\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n\r\n\r\n\r\n\r\nfunction formatQuestionForChatGPT(questionText, possibleAnswers, questionType, inputCount = 1, currentOrder = [], isMultipleCorrect = false, imageBase64Strings) {\r\n    let prompt = `${questionText}\\n\\n`;\r\n\r\n    // Kontynuujemy tworzenie promptu jak wcześniej\r\n    if (questionType === 'multipleChoice') {\r\n        if (!Array.isArray(possibleAnswers)) {\r\n            console.error(\"possibleAnswers is not an array:\", possibleAnswers);\r\n            throw new Error(\"possibleAnswers should be an array for multipleChoice\");\r\n        }\r\n\r\n        if (imageBase64Strings && imageBase64Strings.length > 0) {\r\n            prompt += \"Rozwiąż na bazie załączonego zdjęcia, zanim zaznaczyć odpowiedź przeanalizuj zdjęcie.\\n\";\r\n        }\r\n\r\n        if (isMultipleCorrect) {\r\n            prompt += \"Podaj wszystkie poprawne odpowiedzi. Musisz podać co najmniej jedną odpowiedź. Napisz bardzo krótkie uzasadnienie, następnie daj znak '|$|' a po nim napisz jedynie numery poprawnych odpowiedzi.\\n\\n\";\r\n        } else {\r\n            prompt += \"Jest jedynie jedna poprawna odpowiedź, zaznacz tą która wydaje się być najbardziej prawidłowa. Napisz bardzo krótkie uzasadnienie następnie daj znak '|$|' a po nim napisz jedynie numer poprawnej.\\n\\n\";\r\n        }\r\n\r\n        possibleAnswers.forEach((answer, index) => {\r\n            prompt += `${index + 1}. ${answer}\\n`;\r\n        });\r\n\r\n\r\n    } else if (questionType === 'trueFalse') {\r\n        if (!Array.isArray(possibleAnswers)) {\r\n            console.error(\"possibleAnswers is not an array:\", possibleAnswers);\r\n            throw new Error(\"possibleAnswers should be an array for trueFalse\");\r\n        }\r\n        prompt += \"Podaj poprawną odpowiedź (True/False). Podaj jedynie samą odpowiedź nic więcej.\\n\\n\";\r\n        possibleAnswers.forEach((answer, index) => {\r\n            prompt += `${index + 1}. ${answer}\\n`;\r\n        });\r\n    } else if (questionType === 'matching') {\r\n        if (!Array.isArray(possibleAnswers)) {\r\n            console.error(\"possibleAnswers is not an array:\", possibleAnswers);\r\n            throw new Error(\"possibleAnswers should be an array for matching\");\r\n        }\r\n        prompt += \"Dopasuj każdy termin do jednej z podanych opcji. Odpowiedz wyłącznie numerami opcji w kolejności ich występowania, oddzielając je przecinkami, np. '3, 1, 2'. Bez dodatkowych komentarzy.\\n\\n\";\r\n        possibleAnswers.forEach(pair => {\r\n            if (!pair || !Array.isArray(pair.options)) {\r\n                console.error(\"pair.options is not an array:\", pair);\r\n                throw new Error(\"pair.options should be an array in matching\");\r\n            }\r\n            prompt += `Termin: ${pair.term}\\nOpcje:\\n`;\r\n            pair.options.forEach((option, index) => {\r\n                prompt += `  ${index + 1}. ${option}\\n`;\r\n            });\r\n        });\r\n    } else if (questionType === 'cloze') {\r\n        if (!Array.isArray(possibleAnswers)) {\r\n            console.error(\"possibleAnswers is not an array:\", possibleAnswers);\r\n            throw new Error(\"possibleAnswers should be an array for cloze\");\r\n        }\r\n        prompt += \"Dopasuj odpowiednie odpowiedzi do każdej luki w tekście. Podaj numer każdej poprawnej opcji w kolejności ich występowania, bez dodatkowych komentarzy. Na przykład, jeśli poprawne odpowiedzi to 'długoterminowe planowanie', 'strategiczne planowanie', odpowiedź powinna wyglądać tak: '1, 4'.\\n\\n\";\r\n        possibleAnswers.forEach((options, index) => {\r\n            if (!Array.isArray(options)) {\r\n                console.error(\"options is not an array:\", options);\r\n                throw new Error(\"options should be an array in cloze\");\r\n            }\r\n            prompt += `Luka ${index + 1}:\\n`;\r\n            options.forEach((option, i) => {\r\n                prompt += `  ${i + 1}. ${option}\\n`;\r\n            });\r\n        });\r\n    } else if (questionType === 'cloze-multianswer') {\r\n        prompt += \"Jeśli pytanie ma listę opcji, podaj cyfry numerków poprawnych odpowiedzi. Jeśli pytanie wymaga odpowiedzi tekstowej i nie ma możliwych odpowiedzi, odpowiedz jednym słowem do wpisania. Nie pisz nic poza odpowiedzią. Albo piszesz np. '1,2' albo np. 'well-paid' nie dodawaj nic poza odpowiedzią.\\n\\n\";\r\n    } else if (questionType === 'shortAnswer') {\r\n        if (inputCount > 1) {\r\n            prompt += \"Podaj odpowiedzi dla każdego pola tekstowego w osobnym wierszu, w takiej kolejności, jak są one widoczne. Nie dodawaj żadnych dodatkowych informacji ani wyjaśnień.\\n\\n\";\r\n        } else {\r\n            prompt += \"Podaj jedno słowo lub krótką frazę jako odpowiedź na poniższe pytanie. Nie dodawaj żadnych dodatkowych informacji ani wyjaśnień. Po prostu wpisz odpowiedź.\\n\\n\";\r\n        }\r\n    } else if (questionType === 'longAnswer') {\r\n        prompt += \"Podaj pełną odpowiedź na poniższe pytanie. Proszę, aby odpowiedź była szczegółowa i wyczerpująca ale ma być w kilku zdaniach, nie przekraczaj 600 znaków.\\n\\n\";\r\n    } else if (questionType === 'dragAndDrop') {\r\n        prompt += \"Dopasuj każdą frazę do odpowiedniego miejsca w tekście. Podaj numer każdej poprawnej frazy w kolejności ich występowania, bez dodatkowych komentarzy. Na przykład, jeśli poprawne odpowiedzi to '1, 3, 2', odpowiedź powinna wyglądać tak: '1, 3, 2'.\\n\\n\";\r\n        possibleAnswers.forEach((answer, index) => {\r\n            prompt += `${index + 1}. ${answer}\\n`;\r\n        });\r\n    } else if (questionType === 'ordering') {\r\n        prompt = `${questionText.trim()}\\n\\n`;\r\n        prompt += \"Podaj poprawną kolejność elementów, podając ich nazwy w odpowiedniej kolejności, oddzielając je przecinkami. Na przykład: 'Element1, Element2, Element3'.\\n\\n\";\r\n        currentOrder.forEach(item => {\r\n            prompt += `${item.trim()}\\n`;\r\n        });\r\n        return prompt;\r\n    } else if (questionType === 'opowiedzZAI') {\r\n        prompt = \"Proszę opowiedzieć o poniższym tekście w kilku zdaniach:\\n\\n\";\r\n        prompt += questionText;\r\n    } else if (questionType === 'openEnded') {\r\n        prompt += \"Podaj jedno słowo lub krótką frazę jako odpowiedź na poniższe pytanie. Nie dodawaj żadnych dodatkowych informacji ani wyjaśnień (chyba że ewidetnie z treści pytania wynika, że trzeba się rozpisać). Po prostu wpisz odpowiedź. Przykłądowo dla treści pytania 'She has been working here ___ five years.' twoja odpowiedz powinna brzmieć dokładnie tak: 'for'\\n\\n\";\r\n        prompt += questionText;\r\n    }\r\n\r\n    else {\r\n        prompt += \"Podaj poprawną odpowiedź.\\n\\n\";\r\n        if (Array.isArray(possibleAnswers)) {\r\n            possibleAnswers.forEach((answer, index) => {\r\n                prompt += `${index + 1}. ${answer}\\n`;\r\n            });\r\n        } else {\r\n            console.error(\"possibleAnswers is not an array:\", possibleAnswers);\r\n            throw new Error(\"possibleAnswers should be an array\");\r\n        }\r\n    }\r\n\r\n    return prompt;\r\n}\r\n\r\n","import { sendQuestionToChatGPT } from '../core/api.js';  // Import funkcji z api.js\r\nfunction handleInformationQuestion(questionElement) {\r\n    const currentPage = getCurrentPageNumber();\r\n\r\n    // Odczytaj tekst\r\n    const qtextElem = questionElement.querySelector(\".qtext\");\r\n    const infoText = qtextElem ? qtextElem.innerText.trim() : \"\";\r\n\r\n    // Wczytaj aktualny instructionsRanges z localStorage\r\n    let instructionsRanges = JSON.parse(localStorage.getItem('instructionsRanges')) || [];\r\n\r\n    // Znajdź obiekt, który ma infoPage = currentPage\r\n    const idx = instructionsRanges.findIndex(r => r.infoPage === currentPage);\r\n    if (idx !== -1) {\r\n        // Nadpisz/uzupełnij pole instructionText\r\n        instructionsRanges[idx].instructionText = infoText;\r\n    }\r\n\r\n    // Zapisz z powrotem do localStorage\r\n    localStorage.setItem('instructionsRanges', JSON.stringify(instructionsRanges));\r\n}\r\n\r\nfunction getCurrentPageNumber() {\r\n    // Pobieramy fragment \"?attempt=...&cmid=...&page=1\"\r\n    const urlParams = new URLSearchParams(window.location.search);\r\n    // Sprawdzamy, czy jest parametr 'page'\r\n    const pageParam = urlParams.get('page');\r\n    // Jeżeli nie ma go w URL, przyjmujemy 0\r\n    const pageNumber = pageParam !== null ? parseInt(pageParam, 10) : 0;\r\n    // Dodatkowo, dla bezpieczeństwa:\r\n    return isNaN(pageNumber) ? 0 : pageNumber;\r\n}\r\n\r\nfunction getLocalizedText(textKey) {\r\n    // Get browser language\r\n    const browserLang = navigator.language || navigator.userLanguage;\r\n    const lang = browserLang.split('-')[0]; // Get main language code (e.g., \"pl\" from \"pl-PL\")\r\n\r\n    // Dictionary of translations for various text elements\r\n    const translations = {\r\n        'correctAnswer': {\r\n            'pl': 'Poprawna odpowiedź:',\r\n            'en': 'Correct answer:',\r\n            'ru': 'Правильный ответ:',\r\n            'uk': 'Правильна відповідь:',\r\n            // Default to English if language not found\r\n            'default': 'Correct answer:'\r\n        }\r\n    };\r\n\r\n    // Return translation for detected language or default to English\r\n    const textDict = translations[textKey] || {};\r\n    return textDict[lang] || textDict['default'] || textKey;\r\n}\r\n\r\n// Funkcja do rozpoznawania typu pytania\r\nexport function detectQuestionType(questionElement) {\r\n    handleInformationQuestion(questionElement)\r\n\r\n    if (questionElement.closest('.que.multichoice') || questionElement.closest('.que.calculatedmulti')) {\r\n        return \"multipleChoice\";\r\n    }\r\n    if (questionElement.closest(\".que.truefalse\")) {\r\n        return \"trueFalse\";\r\n    }\r\n    if (questionElement.closest(\".que.match\")) {\r\n        return \"matching\";\r\n    }\r\n    if (questionElement.closest(\".que.gapselect\")) {\r\n        return \"cloze\";\r\n    }\r\n    if (questionElement.closest(\".que.multianswer\")) {\r\n        return \"cloze-multianswer\";\r\n    }\r\n    if (questionElement.closest('.que.shortanswer') || questionElement.closest('.que.numerical') || questionElement.closest('.que.calculated')) {\r\n        return \"shortAnswer\";\r\n    }\r\n    if (questionElement.querySelector(\".qtype_essay_editor\") ||\r\n        questionElement.querySelector(\"textarea.qtype_essay_plain\") ||\r\n        questionElement.querySelector(\"que.essay\")) {\r\n        return \"longAnswer\";\r\n    }\r\n    if (questionElement.querySelector(\".sortablelist\")) {\r\n        return \"ordering\";\r\n    }\r\n    if (questionElement.querySelector(\".answercontainer .draghome\")) {\r\n        return \"dragAndDrop\";\r\n    }\r\n    return \"unknown\";\r\n}\r\n// Funkcja rozpoznająca typ pytania dla Socrative\r\nexport function detectQuestionTypeSocrative(questionElement) {\r\n    if (questionElement.querySelector('#question-container .mc-question')) {\r\n        return \"multipleChoiceSocrative\";\r\n    }\r\n    if (questionElement.querySelector('#question-container .tf-question')) {\r\n        return \"trueFalseSocrative\";\r\n    }\r\n    if (questionElement.querySelector('#question-container .fr-question')) {\r\n        return \"openEndedSocrative\";\r\n    }\r\n    return \"unknown\";\r\n}\r\n\r\n\r\n\r\n\r\n// SOCRATIVE\r\n\r\n\r\n// Funkcja do przetwarzania pytania wielokrotnego wyboru na platformie Socrative\r\nexport async function handleMultipleChoiceQuestionSocrative(questionElement) {\r\n    const questionText = await extractMultipleChoiceQuestionTextSocrative(questionElement);\r\n    const possibleAnswers = await extractMultipleChoiceAnswersSocrative(questionElement);\r\n\r\n    sendQuestionToChatGPT(questionText, possibleAnswers, \"multipleChoice\", 1, [], false, [])\r\n        .then(response => {\r\n            markCorrectAnswerForMultipleChoiceSocrative(questionElement, response);\r\n\r\n        })\r\n        .catch(error => {\r\n            console.error(\"Error processing question with ChatGPT:\", error);\r\n        });\r\n}\r\n\r\n// Funkcja do wyciągania tekstu pytania dla platformy Socrative\r\nasync function extractMultipleChoiceQuestionTextSocrative(questionElement) {\r\n    const questionTextElement = questionElement.querySelector(\".question-text pre\");\r\n    return questionTextElement ? questionTextElement.innerText.trim() : \"\";\r\n}\r\n\r\n// Funkcja do wyciągania odpowiedzi dla platformy Socrative\r\nasync function extractMultipleChoiceAnswersSocrative(questionElement) {\r\n    const answerElements = questionElement.querySelectorAll(\".mc-answer-option\");\r\n    const answers = [];\r\n\r\n    for (let el of answerElements) {\r\n        const answerTextElement = el.querySelector(\".mc-answer-option-text pre\");\r\n        if (answerTextElement) {\r\n            const answerText = answerTextElement.innerText.trim();\r\n            if (answerText && !answers.includes(answerText)) {\r\n                answers.push(answerText);\r\n            }\r\n        }\r\n    }\r\n    return answers;\r\n}\r\n\r\n\r\n// Funkcja do zaznaczania poprawnej odpowiedzi na platformie Socrative\r\nfunction markCorrectAnswerForMultipleChoiceSocrative(questionElement, correctAnswer) {\r\n    const answerElements = questionElement.querySelectorAll(\".mc-answer-option\");\r\n    const correctIndex = parseInt(correctAnswer.trim()) - 1;\r\n\r\n    chrome.storage.local.get(['markingMode'], (result) => {\r\n        const markingMode = result.markingMode || 'default';\r\n\r\n        if (correctIndex >= 0 && correctIndex < answerElements.length) {\r\n            const correctAnswerElement = answerElements[correctIndex];\r\n            const answerContainer = correctAnswerElement.querySelector(\".mc-answer-option-container\");\r\n            const answerTextElement = correctAnswerElement.querySelector(\".mc-answer-option-text pre\");\r\n\r\n            if (markingMode === 'immediate') {\r\n                answerTextElement.click();\r\n            } else if (markingMode === 'saveMode') {\r\n                if (answerTextElement) {\r\n                    answerTextElement.style.fontWeight = 'normal';\r\n                    answerTextElement.innerHTML = `<span style=\"font-weight: 600;\">${answerTextElement.innerText[0]}</span>${answerTextElement.innerText.slice(1)}`;\r\n                }\r\n            } else {\r\n                if (answerTextElement) {\r\n                    answerTextElement.style.fontWeight = 'bold';\r\n                    answerTextElement.style.color = '#4CAF50';\r\n                }\r\n            }\r\n        } else {\r\n            console.warn(\"Niepoprawny numer odpowiedzi:\", correctAnswer);\r\n        }\r\n    });\r\n}\r\n\r\n\r\n// Funkcja do przetwarzania pytania typu True/False na platformie Socrative\r\nexport async function handleTrueFalseQuestionSocrative(questionElement) {\r\n    const questionText = await extractTrueFalseQuestionTextSocrative(questionElement);\r\n    const possibleAnswers = await extractTrueFalseAnswersSocrative(questionElement);\r\n\r\n    sendQuestionToChatGPT(questionText, possibleAnswers, \"trueFalse\", 1, [], false, [])\r\n        .then(response => {\r\n            markCorrectAnswerForTrueFalseSocrative(questionElement, response);\r\n        })\r\n        .catch(error => {\r\n            console.error(\"Error processing True/False question with ChatGPT:\", error);\r\n        });\r\n}\r\n\r\n// Funkcja do wyciągania tekstu pytania typu True/False na platformie Socrative\r\nasync function extractTrueFalseQuestionTextSocrative(questionElement) {\r\n    const questionTextElement = questionElement.querySelector(\".question-text pre\");\r\n    return questionTextElement ? questionTextElement.innerText.trim() : \"\";\r\n}\r\n\r\n// Funkcja do wyciągania odpowiedzi True/False dla platformy Socrative\r\nasync function extractTrueFalseAnswersSocrative(questionElement) {\r\n    const answerElements = questionElement.querySelectorAll(\".tf-answer-option\");\r\n    const answers = [];\r\n\r\n    for (let el of answerElements) {\r\n        const answerTextElement = el.querySelector(\".tf-answer-option-text pre p\");\r\n        if (answerTextElement) {\r\n            const answerText = answerTextElement.innerText.trim();\r\n            if (answerText && !answers.includes(answerText)) {\r\n                answers.push(answerText);\r\n            }\r\n        }\r\n    }\r\n    return answers;\r\n}\r\n\r\n// Funkcja do zaznaczania poprawnej odpowiedzi True/False na platformie Socrative\r\nexport function markCorrectAnswerForTrueFalseSocrative(questionElement, correctAnswer) {\r\n    const answerElements = questionElement.querySelectorAll(\".mc-answer-option\");\r\n\r\n    const answerText = correctAnswer.trim().replace(/[.,!]/g, \"\").toLowerCase();\r\n\r\n    chrome.storage.local.get(['markingMode'], (result) => {\r\n        const markingMode = result.markingMode || 'default';\r\n\r\n        answerElements.forEach((answerElement) => {\r\n            const optionTextElement = answerElement.querySelector(\".mc-answer-option-text pre\");\r\n            const optionText = optionTextElement ? optionTextElement.innerText.trim().replace(/[.,!]/g, \"\").toLowerCase() : \"\";\r\n\r\n            if (optionText === answerText) {\r\n                if (markingMode === 'immediate') {\r\n                    optionTextElement.click();\r\n\r\n                } else if (markingMode === 'saveMode') {\r\n                    if (optionTextElement) {\r\n                        const originalText = optionTextElement.innerText.trim();\r\n                        optionTextElement.innerHTML = `<span style=\"font-weight: 600; color: inherit;\">${originalText[0]}</span>${originalText.slice(1)}`;\r\n                    }\r\n\r\n                } else {\r\n                    answerElement.style.fontWeight = 'bold';\r\n                    answerElement.style.color = '#4CAF50';\r\n                }\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n\r\n\r\n// Funkcja do przetwarzania pytania otwartego na platformie Socrative\r\nexport async function handleOpenEndedQuestionSocrative(questionElement) {\r\n    const questionText = await extractOpenEndedQuestionTextSocrative(questionElement);\r\n\r\n    sendQuestionToChatGPT(questionText, [], \"openEnded\", 1, [], false, [])\r\n        .then(response => {\r\n            markCorrectAnswerForOpenEndedSocrative(questionElement, response);\r\n        })\r\n        .catch(error => {\r\n            console.error(\"Error processing open-ended question with ChatGPT:\", error);\r\n        });\r\n}\r\n\r\n// Funkcja do wyciągania tekstu pytania otwartego dla platformy Socrative\r\nasync function extractOpenEndedQuestionTextSocrative(questionElement) {\r\n    const questionTextElement = questionElement.querySelector(\".question-text pre\");\r\n    return questionTextElement ? questionTextElement.innerText.trim() : \"\";\r\n}\r\n\r\n// Funkcja do wypełniania odpowiedzi dla pytań otwartych na platformie Socrative\r\nexport function markCorrectAnswerForOpenEndedSocrative(questionElement, answerText) {\r\n    const answerTextarea = questionElement.querySelector(\".fr-question-textarea\");\r\n\r\n    if (answerTextarea) {\r\n        chrome.storage.local.get(['markingMode'], (result) => {\r\n            const markingMode = result.markingMode || 'default';\r\n            answerTextarea.value = answerText;\r\n            if (markingMode === 'immediate') {\r\n                answerTextarea.dispatchEvent(new Event('input', { bubbles: true }));\r\n            } else if (markingMode === 'saveMode') {\r\n\r\n                answerTextarea.dispatchEvent(new Event('input', { bubbles: true }));\r\n            } else {\r\n                answerTextarea.dispatchEvent(new Event('input', { bubbles: true }));\r\n            }\r\n\r\n            answerTextarea.addEventListener('focus', () => {\r\n                answerTextarea.style.color = '';\r\n                answerTextarea.style.fontWeight = '';\r\n            });\r\n        });\r\n    } else {\r\n        console.warn(\"Answer textarea not found for open-ended question.\");\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nfunction getInstructionForPage(page) {\r\n    const instructionsRanges = JSON.parse(localStorage.getItem('instructionsRanges')) || [];\r\n    const found = instructionsRanges.find(r =>\r\n        r.startPage !== null &&\r\n        r.endPage !== null &&\r\n        page >= r.startPage &&\r\n        page <= r.endPage\r\n    );\r\n    return found ? found.instructionText : \"\";\r\n}\r\n\r\nfunction formatPromptWithInstruction(questionText, instructionText, possibleAnswers) {\r\n    return `\r\n    Instructions: ${instructionText || '(brak)'}\r\n    Question: ${questionText}\r\n    Choices: ${possibleAnswers ? possibleAnswers.join(' | ') : '(brak)'}\r\n    `;\r\n}\r\n\r\n\r\n\r\nfunction waitForMathJax() {\r\n    return new Promise((resolve) => {\r\n        if (typeof MathJax === 'undefined') {\r\n            console.warn('MathJax is not defined, proceeding without waiting.');\r\n            resolve();\r\n            return;\r\n        }\r\n\r\n        MathJax.Hub.Queue(() => {\r\n            resolve();\r\n        });\r\n    });\r\n}\r\n\r\nasync function convertMathJaxToText(element) {\r\n    // Pracujemy na kopii, aby nie modyfikować oryginalnej strony\r\n    const clone = element.cloneNode(true);\r\n\r\n    // Krok 1: Znajdź wszystkie skrypty z kodem LaTeX i zastąp je czytelną dla człowieka formą.\r\n    // MathJax przechowuje wzory w takich skryptach.\r\n    const scripts = clone.querySelectorAll('script[type=\"math/tex\"], script[type=\"math/tex; mode=display\"]');\r\n    scripts.forEach(script => {\r\n        const latex = script.textContent.trim();\r\n        // Zastępujemy cały element-rodzic skryptu (np. <span class=\"MathJax_Preview\">...</span>)\r\n        // samym kodem LaTeX otoczonym w nawiasy, aby był łatwy do odczytania przez AI.\r\n        if (script.parentElement) {\r\n            script.parentElement.replaceWith(document.createTextNode(` \\\\(${latex}\\\\) `));\r\n        } else {\r\n            script.remove();\r\n        }\r\n    });\r\n\r\n    // Krok 2: Usuń ewentualne pozostałości po MathJax, które nie zawierają treści\r\n    const previews = clone.querySelectorAll('.MathJax_Preview, .MJX_Assistive_MathML');\r\n    previews.forEach(el => el.remove());\r\n\r\n    // Krok 3: Zwróć czysty tekst z przetworzonego elementu.\r\n    // .innerText jest inteligentniejszy niż .textContent i lepiej oddaje formatowanie.\r\n    return clone.innerText.trim().replace(/\\s+/g, ' ');\r\n}\r\n\r\nasync function extractImageUrlsFromQuestion(questionElement) {\r\n    const formulationElement = questionElement.querySelector('.formulation');\r\n    const imageElements = formulationElement.querySelectorAll(\"img\");\r\n    const imageBase64 = [];\r\n\r\n    for (const img of imageElements) {\r\n        const base64 = await convertImageToBase64(img);\r\n        imageBase64.push(base64);\r\n    }\r\n\r\n    return imageBase64;\r\n}\r\n\r\nfunction convertImageToBase64(img) {\r\n    return new Promise((resolve, reject) => {\r\n        const canvas = document.createElement('canvas');\r\n        const ctx = canvas.getContext('2d');\r\n        canvas.width = img.width;\r\n        canvas.height = img.height;\r\n        ctx.drawImage(img, 0, 0);\r\n\r\n        canvas.toBlob((blob) => {\r\n            const reader = new FileReader();\r\n            reader.onloadend = () => {\r\n                resolve(reader.result);\r\n            };\r\n            reader.onerror = () => {\r\n                reject(\"Error converting image to base64.\");\r\n            };\r\n            reader.readAsDataURL(blob);\r\n        }, 'image/png');\r\n    });\r\n}\r\n\r\nexport async function handleMultipleChoiceQuestion(questionElement) {\r\n\r\n    const questionText = await extractMultipleChoiceQuestionText(questionElement);\r\n    const possibleAnswers = await extractMultipleChoiceAnswers(questionElement);\r\n    const imageBase64Strings = await extractImageUrlsFromQuestion(questionElement);\r\n    const isMultipleCorrect = questionElement.querySelectorAll(\"input[type='checkbox']\").length > 1;\r\n\r\n    // 1) pobierz numer aktualnej strony z URL lub w inny sposób\r\n    const currentPage = getCurrentPageNumber();\r\n\r\n    // 2) znajdź instrukcję w localStorage\r\n    const instructionText = getInstructionForPage(currentPage);\r\n\r\n    // 3) zbuduj prompt (np. scalamy instructionText i questionText)\r\n    // Może być w formie: \"Instrukcja:\\n${instructionText}\\nPytanie:\\n${questionText}\"\r\n    const combinedPrompt = formatPromptWithInstruction(questionText, instructionText, possibleAnswers);\r\n\r\n    sendQuestionToChatGPT(combinedPrompt, possibleAnswers, \"multipleChoice\", 1, [], isMultipleCorrect, imageBase64Strings)\r\n        .then(response => {\r\n            markCorrectAnswerForMultipleChoice(questionElement, response);\r\n        })\r\n        .catch(error => {\r\n            console.error(\"Error processing question with ChatGPT:\", error);\r\n        });\r\n}\r\n\r\nasync function extractMultipleChoiceQuestionText(questionElement) {\r\n    const questionTextElement = questionElement.querySelector(\".qtext\");\r\n    return questionTextElement ? await convertMathJaxToText(questionTextElement) : \"\";\r\n}\r\n\r\nasync function extractMultipleChoiceAnswers(questionElement) {\r\n    const answerElements = questionElement.querySelectorAll(\".answer > div, .answer .r0, .answer .r1\");\r\n    const answers = [];\r\n\r\n    for (let el of answerElements) {\r\n        let processedText = \"\";\r\n\r\n        const answerLabelElement = el.querySelector(\"div[data-region='answer-label'], label\");\r\n\r\n        if (answerLabelElement) {\r\n            const pElements = answerLabelElement.querySelectorAll(\"p\");\r\n            const preElements = answerLabelElement.querySelectorAll(\"pre\");\r\n            const divElements = answerLabelElement.querySelectorAll(\"div\");\r\n\r\n            if (pElements.length > 0) {\r\n                processedText = Array.from(pElements)\r\n                    .map(node => node.textContent.trim())\r\n                    .join(\" \");\r\n            } else if (preElements.length > 0) {\r\n                processedText = Array.from(preElements)\r\n                    .map(node => node.textContent.trim())\r\n                    .join(\" \");\r\n            } else if (divElements.length > 0) {\r\n                processedText = Array.from(divElements)\r\n                    .map(node => node.textContent.trim())\r\n                    .join(\" \");\r\n            }\r\n\r\n            processedText = processedText.trim();\r\n\r\n            if (processedText && !answers.includes(processedText)) {\r\n                answers.push(processedText);\r\n            }\r\n        }\r\n    }\r\n    return answers;\r\n}\r\n\r\nfunction markCorrectAnswerForMultipleChoice(questionElement, correctAnswer) {\r\n    const answerElements = questionElement.querySelectorAll(\".answer > div, .answer .r0, .answer .r1, .radio-custom\");\r\n    const correctAnswersArray = correctAnswer.split(',').map(a => a.trim());\r\n    chrome.storage.local.get(['markingMode'], (result) => {\r\n        const markingMode = result.markingMode || 'default';\r\n\r\n        answerElements.forEach((el, index) => {\r\n            const inputElement = el.querySelector(\"input[type='checkbox'], input[type='radio']\");\r\n            let answerLabelElement = el.querySelector(\"div[data-region='answer-label']\");\r\n\r\n            if (!answerLabelElement) {\r\n                answerLabelElement = el.querySelector(\"label\");\r\n            }\r\n\r\n            let answerText = \"\";\r\n            if (answerLabelElement) {\r\n                answerText = Array.from(answerLabelElement.querySelectorAll(\"p, pre, div\"))\r\n                    .map(node => node.innerText.trim())\r\n                    .filter(text => text.length > 0)\r\n                    .join(\" \")\r\n                    .trim();\r\n            }\r\n\r\n            const answerNumber = (index + 1).toString();\r\n\r\n            const isNumberMatch = correctAnswersArray.includes(answerNumber);\r\n\r\n            const isTextMatch = correctAnswersArray.some(correctText => {\r\n                return correctText === answerText;\r\n            });\r\n\r\n            if (isNumberMatch || isTextMatch) {\r\n                if (markingMode === 'immediate') {\r\n                    if (inputElement) {\r\n                        inputElement.checked = true;\r\n                        // console.debug(`Zaznaczono odpowiedź: ${answerText}`);\r\n                    } else {\r\n                        console.warn(`Input element for answer \"${answerText}\" not found.`);\r\n                    }\r\n                } else if (markingMode === 'saveMode') {\r\n                    Array.from(answerLabelElement.querySelectorAll(\"p, pre, div\")).forEach(label => {\r\n                        const text = label.innerText.trim();\r\n                        if (text) {\r\n                            label.innerHTML = `<span style=\"font-weight: 600;\">${text[0]}</span>${text.slice(1)}`;\r\n                            // console.debug(`Zmieniono formatowanie dla odpowiedzi: ${answerText}`);\r\n                        }\r\n                    });\r\n                } else {\r\n                    Array.from(answerLabelElement.querySelectorAll(\"p, pre, div\")).forEach(label => {\r\n                        label.style.fontWeight = 'bold';\r\n                        label.style.color = '#4CAF50';\r\n                        // console.debug(`Zmieniono formatowanie dla odpowiedzi: ${answerText}`);\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n\r\n\r\nexport async function handleTrueFalseQuestion(questionElement) {\r\n\r\n    const questionText = await extractTrueFalseQuestionText(questionElement);\r\n\r\n    const possibleAnswers = await extractTrueFalseAnswers(questionElement);\r\n\r\n    if (!Array.isArray(possibleAnswers)) {\r\n        return;\r\n    }\r\n\r\n    sendQuestionToChatGPT(questionText, possibleAnswers, \"trueFalse\")\r\n        .then(response => {\r\n            markCorrectAnswerForTrueFalse(questionElement, response);\r\n        })\r\n        .catch(error => {\r\n            console.error(\"Error processing true/false question with ChatGPT:\", error);\r\n        });\r\n}\r\n\r\nasync function extractTrueFalseQuestionText(questionElement) {\r\n    const questionTextElement = questionElement.querySelector(\".qtext\");\r\n    return questionTextElement ? await convertMathJaxToText(questionTextElement) : \"\";\r\n}\r\n\r\n\r\nasync function extractTrueFalseAnswers(questionElement) {\r\n    const answerElements = questionElement.querySelectorAll(\".answer label\");\r\n    const answers = [];\r\n    for (const el of answerElements) {\r\n        const processedText = await convertMathJaxToText(el);\r\n        answers.push(processedText.trim());\r\n    }\r\n    return answers;\r\n}\r\n\r\nfunction markCorrectAnswerForTrueFalse(questionElement, correctAnswer) {\r\n    const answerElements = questionElement.querySelectorAll(\".answer div\");\r\n    const correctAnswerText = correctAnswer.trim().toLowerCase();\r\n\r\n    chrome.storage.local.get(['markingMode'], (result) => {\r\n        const markingMode = result.markingMode || 'default';\r\n\r\n        answerElements.forEach((el, index) => {\r\n            const labelElement = el.querySelector(\"label\");\r\n            const inputElement = el.querySelector(\"input[type='radio']\");\r\n\r\n            if (labelElement && inputElement) {\r\n                const answerText = labelElement.innerText.trim().toLowerCase();\r\n                const answerNumber = (index + 1).toString();\r\n\r\n                if (correctAnswerText.includes(answerText) || correctAnswerText.includes(answerNumber)) {\r\n                    if (markingMode === 'immediate') {\r\n                        inputElement.checked = true;\r\n                    } else if (markingMode === 'saveMode') {\r\n                        labelElement.innerHTML = `<span style=\"font-weight: 600;\">${answerText[0]}</span>${answerText.slice(1)}`;\r\n                    } else {\r\n                        labelElement.style.fontWeight = 'bold';\r\n                        labelElement.style.color = '#4CAF50';\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n\r\n\r\n\r\n\r\nexport async function handleMatchingQuestion(questionElement) {\r\n\r\n    const questionText = await extractMatchingQuestionText(questionElement);\r\n\r\n    const matchingPairs = await extractMatchingPairs(questionElement);\r\n    if (!Array.isArray(matchingPairs)) {\r\n        return;\r\n    }\r\n\r\n    sendQuestionToChatGPT(questionText, matchingPairs, \"matching\")\r\n        .then(response => {\r\n            markCorrectAnswersForMatching(questionElement, response);\r\n        })\r\n        .catch(error => {\r\n            console.error(\"Error processing matching question with ChatGPT:\", error);\r\n        });\r\n}\r\n\r\n\r\nasync function extractMatchingQuestionText(questionElement) {\r\n    const questionTextElement = questionElement.querySelector(\".qtext\");\r\n    if (!questionTextElement) {\r\n        console.error(\"Nie znaleziono elementu .qtext.\");\r\n        return \"\";\r\n    }\r\n\r\n    let questionText = questionTextElement.textContent.trim();\r\n    return questionText;\r\n}\r\n\r\nasync function extractMatchingPairs(questionElement) {\r\n    const answerTable = questionElement.querySelector(\".ablock .answer tbody\");\r\n    if (!answerTable) {\r\n        console.error(\"Nie znaleziono tabeli odpowiedzi.\");\r\n        return [];\r\n    }\r\n\r\n    const pairs = [];\r\n    const rows = answerTable.querySelectorAll(\"tr\");\r\n\r\n    rows.forEach(row => {\r\n        let termElement = row.querySelector(\"td.text pre\");\r\n        const selectElement = row.querySelector(\"td.control select\");\r\n        termElement = row.querySelector(\"td.text p\");\r\n        if (!termElement) {\r\n            termElement = row.querySelectorAll(\"td.text pre\");\r\n        }\r\n        if (termElement && selectElement) {\r\n            const term = termElement.textContent.trim();\r\n            const options = [];\r\n\r\n            selectElement.querySelectorAll(\"option\").forEach(option => {\r\n                if (option.value !== \"0\") {\r\n                    options.push(option.textContent.trim());\r\n                }\r\n            });\r\n\r\n            pairs.push({ term, options });\r\n        } else {\r\n            console.error(\"Nie znaleziono elementów termElement lub selectElement w wierszu:\", row);\r\n        }\r\n    });\r\n\r\n    return pairs;\r\n}\r\n\r\n\r\nfunction markCorrectAnswersForMatching(questionElement, rawResponse) {\r\n    const response = rawResponse.replace(/[^0-9,]/g, '').trim();\r\n    const rows = questionElement.querySelectorAll(\".ablock .answer tbody tr\");\r\n\r\n    if (!rows.length) {\r\n        console.error(\"Nie znaleziono żadnych wierszy w tabeli odpowiedzi.\");\r\n        return;\r\n    }\r\n\r\n    chrome.storage.local.get(['markingMode'], (result) => {\r\n        const markingMode = result.markingMode || 'default';\r\n        const correctAnswerNumbers = response.split(',').map(answer => answer.trim());\r\n\r\n        if (correctAnswerNumbers.length !== rows.length) {\r\n            console.error(\"Mismatch between number of terms and answers. Check the response format.\");\r\n            return;\r\n        }\r\n\r\n        rows.forEach((row, index) => {\r\n            const selectElement = row.querySelector(\"select\");\r\n            const correctAnswerNumber = correctAnswerNumbers[index];\r\n            const termElement = row.querySelector(\"td.text p\");\r\n\r\n            if (!termElement) {\r\n                console.error(\"Nie znaleziono elementu termElement w wierszu:\", row);\r\n                return;\r\n            }\r\n\r\n            const optionToHighlight = selectElement ? selectElement.querySelector(`option[value=\"${correctAnswerNumber}\"]`) : null;\r\n\r\n            if (markingMode === 'immediate') {\r\n                if (optionToHighlight) {\r\n                    selectElement.value = optionToHighlight.value;\r\n                }\r\n            } else if (markingMode === 'saveMode') {\r\n                if (optionToHighlight) {\r\n                    optionToHighlight.style.color = '#999797';\r\n                }\r\n            } else {\r\n                if (optionToHighlight) {\r\n                    optionToHighlight.style.fontWeight = 'bold';\r\n                    optionToHighlight.style.color = '#4CAF50';\r\n                }\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport async function handleClozeQuestion(questionElement) {\r\n\r\n    const questionText = await extractClozeQuestionText(questionElement);\r\n\r\n    const clozeOptions = await extractClozeOptions(questionElement);\r\n\r\n    if (!Array.isArray(clozeOptions)) {\r\n        console.error(\"clozeOptions is not an array:\", clozeOptions);\r\n        return;\r\n    }\r\n\r\n    sendQuestionToChatGPT(questionText, clozeOptions, \"cloze\")\r\n        .then(response => {\r\n            markCorrectAnswersForCloze(questionElement, response);\r\n        })\r\n        .catch(error => {\r\n            console.error(\"Error processing cloze question with ChatGPT:\", error);\r\n        });\r\n}\r\n\r\n\r\nasync function extractClozeQuestionText(questionElement) {\r\n    const questionTextElement = questionElement.querySelector(\".qtext\");\r\n    return questionTextElement ? await convertMathJaxToText(questionTextElement) : \"\";\r\n}\r\n\r\n\r\nasync function extractClozeOptions(questionElement) {\r\n    const selects = questionElement.querySelectorAll(\".qtext select\");\r\n    let options = [];\r\n\r\n    for (const select of selects) {\r\n        const selectOptions = [];\r\n        for (const option of select.options) {\r\n            if (option.value !== \"\") {\r\n                const processedText = await convertMathJaxToText(option);\r\n                selectOptions.push(processedText.trim());\r\n            }\r\n        }\r\n        options.push(selectOptions);\r\n    }\r\n\r\n    return options;\r\n}\r\n\r\n\r\nfunction markCorrectAnswersForCloze(questionElement, correctAnswers) {\r\n    const selects = questionElement.querySelectorAll(\".qtext select\");\r\n\r\n    chrome.storage.local.get(['markingMode'], (result) => {\r\n        const markingMode = result.markingMode || 'default';\r\n\r\n        correctAnswers.split(',').forEach((answer, index) => {\r\n            const selectElement = selects[index];\r\n            if (!selectElement) {\r\n                console.warn(`No select element found for cloze part ${index + 1}`);\r\n                return;\r\n            }\r\n\r\n            const correctAnswerNumber = answer.trim();\r\n            const optionToHighlight = selectElement.querySelector(`option[value=\"${correctAnswerNumber}\"]`);\r\n\r\n            if (!optionToHighlight) {\r\n                console.warn(`No option found for value '${correctAnswerNumber}' in select element for cloze part ${index + 1}`);\r\n                return;\r\n            }\r\n\r\n            if (markingMode === 'immediate') {\r\n                selectElement.value = optionToHighlight.value;\r\n            } else if (markingMode === 'saveMode') {\r\n                optionToHighlight.style.color = '#D3D3D3';\r\n            } else {\r\n                optionToHighlight.style.fontWeight = 'bold';\r\n                optionToHighlight.style.color = '#4CAF50';\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nexport async function handleClozeMultianswerQuestion(questionElement) {\r\n\r\n    // Pobieramy wszystkie kontenery pytań\r\n    const questionContainers = document.querySelectorAll(\".formulation\");\r\n    let extractedText = [];\r\n\r\n    /**\r\n     * Funkcja rekurencyjnie wyciągająca treść z danego węzła, \r\n     * wstawiająca [opcja] w miejscu subquestion w zależności od tego,\r\n     * czy w subquestion jest <select>, czy <input type=\"text\">\r\n     */\r\n    function extractTextWithSubquestions(node) {\r\n        let textResult = \"\";\r\n\r\n        node.childNodes.forEach(child => {\r\n            // Jeśli to zwykły tekst\r\n            if (child.nodeType === Node.TEXT_NODE) {\r\n                textResult += child.textContent;\r\n\r\n                // Jeśli to element HTML\r\n            } else if (child.nodeType === Node.ELEMENT_NODE) {\r\n                const element = child;\r\n\r\n                // Sprawdzamy, czy to .subquestion\r\n                if (element.classList.contains(\"subquestion\")) {\r\n                    const selectElement = element.querySelector(\"select\");\r\n                    const inputElement = element.querySelector(\"input[type='text']\");\r\n\r\n                    if (selectElement) {\r\n                        // Mamy listę rozwijaną\r\n                        let options = [];\r\n                        // Zbieramy wszystkie niepuste opcje\r\n                        const allOptions = selectElement.querySelectorAll(\"option\");\r\n                        allOptions.forEach((option, index) => {\r\n                            if (option.value !== \"\") {\r\n                                // Używamy indeksu jako wskaźnika odpowiedzi\r\n                                options.push(`${index}: ${option.textContent.trim()}`);\r\n                            }\r\n                        });\r\n                        // Wstawiamy listę w nawiasach kwadratowych\r\n                        textResult += ` [${options.join(\", \")}] `;\r\n                    } else if (inputElement) {\r\n                        // Mamy pole tekstowe\r\n                        // Dla czytelności wstawiamy np. [___] jako placeholder\r\n                        textResult += ` [___] `;\r\n                    }\r\n                } else {\r\n                    // Jeśli to inny element, to wywołujemy rekurencję\r\n                    textResult += extractTextWithSubquestions(element);\r\n                }\r\n            }\r\n        });\r\n\r\n        return textResult;\r\n    }\r\n\r\n    // Przetwarzamy każdy kontener pytania z osobna\r\n    questionContainers.forEach((questionContainer, qIndex) => {\r\n        let questionText = extractTextWithSubquestions(questionContainer);\r\n\r\n        questionText = questionText\r\n            .replace(/\\s+/g, \" \")\r\n            .trim();\r\n\r\n        extractedText.push(`Pytanie ${qIndex + 1}: ${questionText}`);\r\n    });\r\n\r\n    const currentPage = getCurrentPageNumber();\r\n\r\n\r\n    const instructionText = getInstructionForPage(currentPage);\r\n\r\n\r\n    const combinedPrompt = formatPromptWithInstruction(extractedText, instructionText);\r\n\r\n    sendQuestionToChatGPT(combinedPrompt, [], \"cloze-multianswer\")\r\n        .then(response => {\r\n\r\n            // Każda linia z odpowiedzi to kolejna wartość do wstawienia\r\n            // (np. \"1\", \"0\", \"wealthy\", itp.)\r\n            const answersArray = response\r\n                .split(\"\\n\")\r\n                .map(answer => answer.trim())\r\n                .filter(a => a !== \"\"); // usuwamy ewentualne puste linie\r\n\r\n\r\n            markCorrectAnswersForMultianswer(questionElement, answersArray);\r\n        })\r\n        .catch(error => {\r\n            console.error(\"Error processing multi-answer question with ChatGPT:\", error);\r\n        });\r\n}\r\n\r\n/****************************************************\r\n * Funkcja do oznaczania odpowiedzi \r\n ****************************************************/\r\nfunction markCorrectAnswersForMultianswer(questionElement, correctAnswers) {\r\n\r\n    // Znajdujemy wszystkie .subquestion w obrębie pytania\r\n    const subQuestions = questionElement.querySelectorAll(\".subquestion\");\r\n\r\n    // Pobieramy tryb oznaczania z pamięci\r\n    chrome.storage.local.get([\"markingMode\"], (result) => {\r\n        const markingMode = result.markingMode || \"default\";\r\n\r\n\r\n        const joinedAnswers = correctAnswers.join(\",\");\r\n\r\n\r\n        const allAnswers = joinedAnswers\r\n            .split(\",\")\r\n            .map(item => item.trim())   // usuwamy spacje\r\n            .filter(item => item !== \"\"); // usuwamy puste wejścia\r\n\r\n\r\n        subQuestions.forEach((subq, index) => {\r\n            const selectElement = subq.querySelector(\"select\");\r\n            const inputElement = subq.querySelector(\"input[type='text']\");\r\n\r\n            if (index >= allAnswers.length) {\r\n                return;\r\n            }\r\n\r\n            // userAnswer to np. \"1\" dla <select>, \"wealthy\" dla <input>\r\n            const userAnswer = allAnswers[index];\r\n\r\n            if (selectElement) {\r\n                // ------ Przypadek: <select> ------\r\n                const correctIndex = parseInt(userAnswer, 10);\r\n                if (isNaN(correctIndex)) {\r\n                    return;\r\n                }\r\n\r\n                const correctOption = selectElement.options[correctIndex];\r\n                if (!correctOption) {\r\n                    return;\r\n                }\r\n\r\n                // Oznaczanie wg trybu\r\n                if (markingMode === \"default\") {\r\n                    correctOption.style.color = \"#4CAF50\";\r\n                } else if (markingMode === \"immediate\") {\r\n                    selectElement.value = correctOption.value;\r\n                } else if (markingMode === \"saveMode\") {\r\n                    const answerText = correctOption.textContent.trim();\r\n                    if (answerText.length > 0) {\r\n                        correctOption.innerHTML = `<strong>${answerText[0]}</strong>${answerText.slice(1)}`;\r\n                    }\r\n                    correctOption.style.color = \"#A9A9A9\";\r\n                }\r\n            } else if (inputElement) {\r\n                // ------ Przypadek: <input type=\"text\"> ------\r\n                // Tutaj userAnswer to słowo/wyrażenie np. \"wealthy\"\r\n                if (markingMode === \"default\") {\r\n                    // Wyświetlamy tekst poprawnej odpowiedzi na zielono POD polem\r\n                    // lub inna forma oznaczenia. Tutaj przykładowo tworzymy <div>:\r\n                    const answerDiv = document.createElement(\"div\");\r\n                    answerDiv.style.color = \"#4CAF50\";\r\n                    answerDiv.style.fontWeight = \"bold\";\r\n                    answerDiv.innerText = userAnswer;\r\n                    // wstawiamy po polu input\r\n                    inputElement.insertAdjacentElement(\"afterend\", answerDiv);\r\n\r\n                } else if (markingMode === \"immediate\") {\r\n                    // Wpisujemy poprawną odpowiedź do inputa\r\n                    inputElement.value = userAnswer;\r\n\r\n                } else if (markingMode === \"saveMode\") {\r\n                    // Ustawiamy placeholder z odpowiedzią, ale tylko widoczny przy kliknięciu\r\n                    inputElement.addEventListener(\"focus\", function () {\r\n                        inputElement.placeholder = userAnswer;\r\n                    });\r\n                    inputElement.addEventListener(\"blur\", function () {\r\n                        inputElement.placeholder = \"\";\r\n                    });\r\n                    // Przyciemniamy tekst, dopóki użytkownik nie wpisze niczego\r\n                    inputElement.style.color = \"#A9A9A9\";\r\n\r\n                    inputElement.addEventListener(\"input\", function handleUserInput() {\r\n                        inputElement.style.color = \"\";\r\n                    });\r\n                }\r\n            } else {\r\n                // Ani <select>, ani <input type=\"text\">\r\n                console.warn(`⚠ subquestion nr ${index + 1} nie zawiera <select> ani <input>.`);\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport async function handleShortAnswerQuestion(questionElement) {\r\n    const questionText = await extractShortAnswerQuestionText(questionElement);\r\n\r\n    const inputCount = questionElement.querySelectorAll(\"input[type='text']\").length;\r\n    const imageBase64Strings = await extractImageUrlsFromQuestion(questionElement);\r\n\r\n    // 1) pobierz numer aktualnej strony z URL lub w inny sposób\r\n    const currentPage = getCurrentPageNumber();\r\n\r\n    // 2) znajdź instrukcję w localStorage\r\n    const instructionText = getInstructionForPage(currentPage);\r\n\r\n    // 3) zbuduj prompt (np. scalamy instructionText i questionText)\r\n    // Może być w formie: \"Instrukcja:\\n${instructionText}\\nPytanie:\\n${questionText}\"\r\n    const combinedPrompt = formatPromptWithInstruction(questionText, instructionText);\r\n    sendQuestionToChatGPT(combinedPrompt, [], \"shortAnswer\", inputCount, [], false, imageBase64Strings)\r\n        .then(response => {\r\n            markCorrectAnswerForShortAnswer(questionElement, response);\r\n        })\r\n        .catch(error => {\r\n            console.error(\"Error processing short answer question with ChatGPT:\", error);\r\n        });\r\n}\r\n\r\nasync function extractShortAnswerQuestionText(questionElement) {\r\n    let questionText = \"\";\r\n\r\n    const qtextElement = questionElement.querySelector(\".qtext\");\r\n    if (qtextElement) {\r\n        questionText = qtextElement.textContent.trim();\r\n    } else {\r\n        const elements = questionElement.querySelectorAll(\"p, pre\");\r\n\r\n        elements.forEach(element => {\r\n            if (!element.querySelector(\".subquestion\")) {\r\n                questionText += element.textContent.trim() + \"\\n\";\r\n            }\r\n        });\r\n    }\r\n\r\n    return questionText.trim();\r\n}\r\nfunction markCorrectAnswerForShortAnswer(questionElement, correctAnswers) {\r\n    const inputElements = questionElement.querySelectorAll(\"input[type='text']\");\r\n    const answersArray = correctAnswers.split(\"\\n\").map(answer => answer.trim().toLowerCase());\r\n\r\n    chrome.storage.local.get(['markingMode'], (result) => {\r\n        const markingMode = result.markingMode || 'default';\r\n\r\n        inputElements.forEach((inputElement) => {\r\n            const matchingAnswer = answersArray.find(answer => answer === inputElement.value.trim().toLowerCase()) || answersArray[0];\r\n\r\n            if (markingMode === 'immediate') {\r\n                if (inputElement) {\r\n                    inputElement.value = matchingAnswer;\r\n                }\r\n            } else if (markingMode === 'saveMode') {\r\n                if (inputElement) {\r\n                    inputElement.addEventListener('focus', function () {\r\n                        inputElement.placeholder = matchingAnswer;\r\n                    });\r\n\r\n                    inputElement.addEventListener('blur', function () {\r\n                        inputElement.placeholder = '';\r\n                        inputElement.style.color = '';\r\n                    });\r\n                }\r\n            } else {\r\n                if (inputElement) {\r\n                    const correctAnswerDisplay = document.createElement('div');\r\n                    correctAnswerDisplay.style.color = '#4CAF50';\r\n                    correctAnswerDisplay.style.fontWeight = 'bold';\r\n                    correctAnswerDisplay.innerText = `${getLocalizedText('correctAnswer')} ${matchingAnswer}`;\r\n                    inputElement.parentNode.appendChild(correctAnswerDisplay);\r\n                }\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport async function handleLongAnswerQuestion(questionElement) {\r\n\r\n    const questionText = await extractLongAnswerQuestionText(questionElement);\r\n\r\n    sendQuestionToChatGPT(questionText, [], \"longAnswer\")\r\n        .then(response => {\r\n            applyLongAnswerResponse(questionElement, response);\r\n        })\r\n        .catch(error => {\r\n            console.error(\"Error processing long answer question with ChatGPT:\", error);\r\n        });\r\n}\r\nasync function extractLongAnswerQuestionText(questionElement) {\r\n    const questionTextElementP = questionElement.querySelector(\".qtext p\");\r\n    const questionTextElement = questionElement.querySelector(\".qtext\");\r\n    const text = questionTextElementP ? await convertMathJaxToText(questionTextElementP) : await convertMathJaxToText(questionTextElement);\r\n    return text.trim();\r\n}\r\n\r\n\r\n\r\nfunction applyLongAnswerResponse(questionElement, response) {\r\n    const textAreaElement = questionElement.querySelector(\"textarea.qtype_essay_plain\");\r\n    const iframe = questionElement.querySelector(\"iframe\");\r\n    let editorBody;\r\n\r\n    if (iframe) {\r\n        const editorDocument = iframe.contentDocument || iframe.contentWindow.document;\r\n        editorBody = editorDocument.querySelector(\"body\");\r\n    } else {\r\n        editorBody = questionElement.querySelector(\"textarea\");\r\n    }\r\n\r\n    chrome.storage.local.get(['markingMode'], (result) => {\r\n        const markingMode = result.markingMode || 'default';\r\n\r\n        if (markingMode === 'immediate') {\r\n            if (textAreaElement) {\r\n                textAreaElement.value = response.trim();\r\n            } else if (iframe) {\r\n                editorBody.innerHTML = `<p>${response.trim()}</p>`;\r\n            }\r\n        } else if (markingMode === 'saveMode') {\r\n            const words = response.trim().split(' ');\r\n            let currentWordIndex = 0;\r\n\r\n            const createOverlay = () => {\r\n                const overlay = document.createElement('div');\r\n                overlay.style.position = 'absolute';\r\n                overlay.style.color = '#999797';\r\n                overlay.style.pointerEvents = 'none';\r\n                overlay.style.whiteSpace = 'pre-wrap';\r\n                overlay.style.opacity = '0.5';\r\n                overlay.style.zIndex = '1';\r\n                return overlay;\r\n            };\r\n\r\n            const updateOverlayPosition = (inputElement, overlayElement) => {\r\n                const rect = inputElement.getBoundingClientRect();\r\n                overlayElement.style.top = `${rect.top + window.scrollY}px`;\r\n                overlayElement.style.left = `${rect.left + window.scrollX}px`;\r\n                overlayElement.style.width = `${rect.width}px`;\r\n                overlayElement.style.height = `${rect.height}px`;\r\n                overlayElement.style.padding = getComputedStyle(inputElement).padding;\r\n                overlayElement.style.fontSize = getComputedStyle(inputElement).fontSize;\r\n                overlayElement.style.lineHeight = getComputedStyle(inputElement).lineHeight;\r\n                overlayElement.style.fontFamily = getComputedStyle(inputElement).fontFamily;\r\n            };\r\n\r\n            const updateOverlayContent = (inputElement, overlayElement) => {\r\n                const currentText = inputElement.value;\r\n                let remainingWords = words.slice(currentWordIndex).join(' ');\r\n\r\n                if (currentText.trim()) {\r\n                    const typedWords = currentText.trim().split(' ');\r\n                    for (let i = 0; i < typedWords.length; i++) {\r\n                        if (words[i] && words[i].startsWith(typedWords[i])) {\r\n                            currentWordIndex = i + 1;\r\n                        } else {\r\n                            currentWordIndex = i;\r\n                            remainingWords = words.slice(currentWordIndex).join(' ');\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                overlayElement.innerHTML = `${currentText}${remainingWords ? ' ' + remainingWords : ''}`;\r\n            };\r\n\r\n            const handleKeyDown = (event, inputElement, overlayElement) => {\r\n                if (event.key === 'Tab') {\r\n                    event.preventDefault();\r\n                    if (currentWordIndex < words.length) {\r\n                        const currentWord = words[currentWordIndex] + ' ';\r\n                        inputElement.value += currentWord;\r\n                        currentWordIndex++;\r\n                        updateOverlayContent(inputElement, overlayElement);\r\n                    }\r\n                } else {\r\n                    updateOverlayContent(inputElement, overlayElement);\r\n                }\r\n            };\r\n\r\n            const setupOverlayForTextarea = (textarea) => {\r\n                const overlay = createOverlay();\r\n                document.body.appendChild(overlay);\r\n\r\n                updateOverlayPosition(textarea, overlay);\r\n                updateOverlayContent(textarea, overlay);\r\n\r\n                textarea.addEventListener('keydown', (event) => handleKeyDown(event, textarea, overlay));\r\n                textarea.addEventListener('input', () => updateOverlayContent(textarea, overlay));\r\n                window.addEventListener('resize', () => updateOverlayPosition(textarea, overlay));\r\n            };\r\n\r\n            if (textAreaElement) {\r\n                textAreaElement.style.position = 'relative';\r\n                setupOverlayForTextarea(textAreaElement);\r\n            } else if (iframe) {\r\n                const hintElement = document.createElement('div');\r\n                hintElement.style.color = '#999797';\r\n                hintElement.style.fontStyle = 'italic';\r\n                hintElement.innerText = `Sugestia: ${response.trim()}`;\r\n                iframe.closest('.qtype_essay_editor').appendChild(hintElement);\r\n\r\n                const overlay = createOverlay();\r\n                document.body.appendChild(overlay);\r\n\r\n                updateOverlayPosition(editorBody, overlay);\r\n                updateOverlayContent(editorBody, overlay);\r\n\r\n                editorBody.addEventListener('keydown', (event) => handleKeyDown(event, editorBody, overlay));\r\n                editorBody.addEventListener('input', () => updateOverlayContent(editorBody, overlay));\r\n                window.addEventListener('resize', () => updateOverlayPosition(editorBody, overlay));\r\n            }\r\n        } else {\r\n            if (textAreaElement) {\r\n                const correctAnswerDisplay = document.createElement('div');\r\n                correctAnswerDisplay.style.color = '#4CAF50';\r\n                correctAnswerDisplay.style.fontWeight = 'bold';\r\n                correctAnswerDisplay.innerText = `${getLocalizedText('correctAnswer')} ${response.trim()}`;\r\n                textAreaElement.parentNode.appendChild(correctAnswerDisplay);\r\n            } else if (iframe) {\r\n                const correctAnswerDisplay = document.createElement('div');\r\n                correctAnswerDisplay.style.color = '#4CAF50';\r\n                correctAnswerDisplay.style.fontWeight = 'bold';\r\n                correctAnswerDisplay.innerText = `${getLocalizedText('correctAnswer')} ${response.trim()}`;\r\n                iframe.closest('.qtype_essay_editor').appendChild(correctAnswerDisplay);\r\n\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n\r\n\r\n\r\nexport async function handleDragAndDropQuestion(questionElement) {\r\n\r\n    const questionText = await extractDragAndDropQuestionText(questionElement);\r\n\r\n    const possibleAnswers = await extractDragAndDropAnswers(questionElement);\r\n\r\n    if (!Array.isArray(possibleAnswers)) {\r\n        console.error(\"Possible answers are not an array:\", possibleAnswers);\r\n        return;\r\n    }\r\n\r\n    sendQuestionToChatGPT(questionText, possibleAnswers, \"dragAndDrop\")\r\n        .then(response => {\r\n            markCorrectAnswerForDragAndDrop(questionElement, response);\r\n        })\r\n        .catch(error => {\r\n            console.error(\"Error processing drag-and-drop question with ChatGPT:\", error);\r\n        });\r\n}\r\n\r\nasync function extractDragAndDropQuestionText(questionElement) {\r\n    const questionTextElement = questionElement.querySelector(\".qtext\");\r\n    return questionTextElement ? await convertMathJaxToText(questionTextElement) : \"\";\r\n}\r\n\r\nasync function extractDragAndDropAnswers(questionElement) {\r\n    const answerElements = questionElement.querySelectorAll(\".draghome.unplaced\");\r\n    const answers = [];\r\n\r\n    for (const el of answerElements) {\r\n        const processedText = await convertMathJaxToText(el);\r\n        answers.push(processedText.trim());\r\n    }\r\n    return answers;\r\n}\r\n\r\nfunction markCorrectAnswerForDragAndDrop(questionElement, correctAnswer) {\r\n    const correctAnswerIndexes = correctAnswer.split(',').map(num => parseInt(num.trim()) - 1);\r\n    const answerElements = questionElement.querySelectorAll(\".draghome.unplaced\");\r\n    const dropZones = questionElement.querySelectorAll(\".place1.drop, .place2.drop, .place3.drop, .place4.drop\");\r\n\r\n    chrome.storage.local.get(['markingMode'], (result) => {\r\n        const markingMode = result.markingMode || 'default';\r\n\r\n        if (dropZones.length > 1 && answerElements.length > 1) {\r\n            if (markingMode === 'immediate') {\r\n                correctAnswerIndexes.forEach((answerIndex, i) => {\r\n                    const correctAnswerElement = answerElements[answerIndex];\r\n                    const dropZone = dropZones[i];\r\n\r\n                    const startPos = correctAnswerElement.getBoundingClientRect();\r\n                    const endPos = dropZone.getBoundingClientRect();\r\n\r\n                    correctAnswerElement.dispatchEvent(new MouseEvent('mousedown', {\r\n                        bubbles: true,\r\n                        cancelable: true,\r\n                        clientX: startPos.left,\r\n                        clientY: startPos.top\r\n                    }));\r\n\r\n                    correctAnswerElement.dispatchEvent(new MouseEvent('mousemove', {\r\n                        bubbles: true,\r\n                        cancelable: true,\r\n                        clientX: endPos.left + endPos.width / 2,\r\n                        clientY: endPos.top + endPos.height / 2\r\n                    }));\r\n\r\n                    correctAnswerElement.dispatchEvent(new MouseEvent('mouseup', {\r\n                        bubbles: true,\r\n                        cancelable: true,\r\n                        clientX: endPos.left + endPos.width / 2,\r\n                        clientY: endPos.top + endPos.height / 2\r\n                    }));\r\n                });\r\n            } else if (markingMode === 'saveMode') {\r\n                correctAnswerIndexes.forEach((answerIndex) => {\r\n                    const correctAnswerElement = answerElements[answerIndex];\r\n                    const correctAnswerText = correctAnswerElement.innerText.trim();\r\n                    correctAnswerElement.innerHTML = `<span style=\"font-weight: 600;\">${correctAnswerText[0]}</span>${correctAnswerText.slice(1)}`;\r\n                });\r\n            } else {\r\n                correctAnswerIndexes.forEach((answerIndex, i) => {\r\n                    const correctAnswerElement = answerElements[answerIndex];\r\n                    const correctAnswerText = correctAnswerElement.innerText.trim();\r\n                    const correctAnswerDisplay = document.createElement('div');\r\n                    correctAnswerDisplay.style.color = '#4CAF50';\r\n                    correctAnswerDisplay.style.fontWeight = 'bold';\r\n                    correctAnswerDisplay.innerText = `${getLocalizedText('correctAnswer')} ${i + 1}: ${correctAnswerText}`;\r\n                    questionElement.appendChild(correctAnswerDisplay);\r\n                });\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n\r\n\r\nexport async function handleOrderingQuestion(questionElement) {\r\n\r\n    const questionText = await extractOrderingQuestionText(questionElement);\r\n\r\n    const currentOrder = await extractCurrentOrder(questionElement);\r\n\r\n    sendQuestionToChatGPT(questionText, currentOrder, \"ordering\")\r\n        .then(response => {\r\n            markCorrectOrder(questionElement, response);\r\n        })\r\n        .catch(error => {\r\n            console.error(\"Error processing ordering question with ChatGPT:\", error);\r\n        });\r\n\r\n}\r\n\r\nasync function extractOrderingQuestionText(questionElement) {\r\n    const questionTextElement = questionElement.querySelector(\".qtext\");\r\n    return questionTextElement ? questionTextElement.textContent.trim() : \"\";\r\n}\r\n\r\nasync function extractCurrentOrder(questionElement) {\r\n    const listItems = questionElement.querySelectorAll(\".sortablelist .sortableitem\");\r\n    const currentOrder = [];\r\n\r\n    listItems.forEach(item => {\r\n        const textElement = item.querySelector(\".flex-grow-1\");\r\n        if (textElement) {\r\n            currentOrder.push(textElement.textContent.trim());\r\n        }\r\n    });\r\n\r\n    return currentOrder;\r\n}\r\nfunction markCorrectOrder(questionElement, correctOrder) {\r\n    const correctItems = correctOrder.split(',').map(item => item.trim());\r\n    const listItems = Array.from(questionElement.querySelectorAll(\"li.sortableitem\"));\r\n\r\n    function updateArrowColors() {\r\n        listItems.forEach((itemElement, currentIndex) => {\r\n            const text = itemElement.querySelector(\".d-flex.align-items-center.flex-grow-1.px-2\").textContent.trim();\r\n            const correctIndex = correctItems.indexOf(text);\r\n\r\n            const upArrow = itemElement.querySelector(\"button[data-action='move-backward'] i\");\r\n            const downArrow = itemElement.querySelector(\"button[data-action='move-forward'] i\");\r\n\r\n            upArrow.style.color = '';\r\n            downArrow.style.color = '';\r\n\r\n            if (correctIndex !== currentIndex) {\r\n                if (correctIndex < currentIndex) {\r\n                    upArrow.style.color = '#999999';\r\n                } else if (correctIndex > currentIndex) {\r\n                    downArrow.style.color = '#999999';\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    chrome.storage.local.get(['markingMode'], (result) => {\r\n        const markingMode = result.markingMode || 'default';\r\n\r\n        if (markingMode === 'immediate') {\r\n            listItems.sort((a, b) => {\r\n                const aText = a.querySelector(\".d-flex.align-items-center.flex-grow-1.px-2\").textContent.trim();\r\n                const bText = b.querySelector(\".d-flex.align-items-center.flex-grow-1.px-2\").textContent.trim();\r\n                return correctItems.indexOf(aText) - correctItems.indexOf(bText);\r\n            });\r\n            const list = questionElement.querySelector(\"ul.sortablelist\");\r\n            listItems.forEach(item => list.appendChild(item));\r\n            updateArrowColors();\r\n        } else if (markingMode === 'saveMode') {\r\n            updateArrowColors();\r\n\r\n            listItems.forEach(itemElement => {\r\n                const upArrow = itemElement.querySelector(\"button[data-action='move-backward']\");\r\n                const downArrow = itemElement.querySelector(\"button[data-action='move-forward']\");\r\n\r\n                upArrow.addEventListener('click', () => {\r\n                    setTimeout(() => {\r\n                        updateArrowColors();\r\n                    }, 100);\r\n                });\r\n\r\n                downArrow.addEventListener('click', () => {\r\n                    setTimeout(() => {\r\n                        updateArrowColors();\r\n                    }, 100);\r\n                });\r\n            });\r\n        } else {\r\n            listItems.forEach((itemElement, index) => {\r\n                const text = itemElement.querySelector(\".d-flex.align-items-center.flex-grow-1.px-2\").textContent.trim();\r\n                const correctIndex = correctItems.indexOf(text);\r\n                if (correctIndex !== -1) {\r\n                    itemElement.querySelector(\".d-flex.align-items-center.flex-grow-1.px-2\").innerHTML = `<span style=\"color: #4CAF50; font-weight: bold;\">${correctIndex + 1}. </span>${text}`;\r\n                } else {\r\n                    console.warn(`No match found for: ${text}`);\r\n                }\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\n\r\n\r\nfunction waitForStableDOMAndMathJax(containerSelector, quietPeriod = 2000) {\r\n    return new Promise((resolve, reject) => {\r\n        const container = document.querySelector(containerSelector);\r\n        if (!container) {\r\n            return reject(new Error(`Nie znaleziono kontenera: ${containerSelector}`));\r\n        }\r\n\r\n        let lastMutationTime = Date.now();\r\n\r\n        const observer = new MutationObserver(() => {\r\n            lastMutationTime = Date.now();\r\n        });\r\n\r\n        observer.observe(container, {\r\n            childList: true,\r\n            subtree: true,\r\n            attributes: true,\r\n            characterData: true\r\n        });\r\n\r\n\r\n        const checkInterval = setInterval(() => {\r\n            const now = Date.now();\r\n\r\n            if (now - lastMutationTime > quietPeriod) {\r\n                clearInterval(checkInterval);\r\n                observer.disconnect();\r\n\r\n\r\n                if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {\r\n                    MathJax.typesetPromise().then(() => {\r\n                        resolve();\r\n                    }).catch(err => reject(err));\r\n                } else {\r\n\r\n                    resolve();\r\n                }\r\n            }\r\n        }, 500);\r\n    });\r\n}\r\n\r\nexport async function handleQuizSummary(summaryElement, navElement, userEmail) {\r\n    const quizData = extractQuizDataFromSummary(summaryElement);\r\n\r\n    await waitForStableDOMAndMathJax('.questionflagsaveform');\r\n\r\n    if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {\r\n        await MathJax.typesetPromise();\r\n    } else {\r\n        await new Promise(res => setTimeout(res, 2000));\r\n    }\r\n\r\n    const quizQuestions = extractQuestionsFromSummary();\r\n\r\n    let courseName = \"NA\";\r\n    let testName = \"NA\";\r\n\r\n    if (navElement) {\r\n        const breadcrumbItems = navElement.querySelectorAll(\".breadcrumb-item\");\r\n        if (breadcrumbItems.length > 0) {\r\n            const courseElement = breadcrumbItems[0].querySelector(\"a\");\r\n            courseName = courseElement ? courseElement.innerText.trim() : \"NA\";\r\n        }\r\n        if (breadcrumbItems.length > 1) {\r\n            const testElement = breadcrumbItems[1].querySelector(\"span\");\r\n            testName = testElement ? testElement.innerText.trim() : \"NA\";\r\n        }\r\n    }\r\n\r\n    const currentUrl = window.location.href;\r\n    const universityUrl = new URL(currentUrl).origin;\r\n    const startTime = new Date().toISOString();\r\n\r\n    const quizIdentifierBase = `${testName}-${quizData.map(item => item.value).join('-')}`;\r\n    const existingIdentifier = localStorage.getItem('quizIdentifier');\r\n    if (existingIdentifier === quizIdentifierBase) {\r\n        return;\r\n    }\r\n    localStorage.setItem('quizIdentifier', quizIdentifierBase);\r\n\r\n    const payload = {\r\n        userEmail: userEmail,\r\n        courseName: courseName,\r\n        testName: testName,\r\n        universityUrl: universityUrl,\r\n        quizData: quizData,\r\n        startTime: startTime,\r\n        quizQuestions: quizQuestions\r\n    };\r\n\r\n    try {\r\n        const response = await fetch('https://us-central1-quizonator-a4513.cloudfunctions.net/api/save-quiz-summary-new', {\r\n            method: 'POST',\r\n            headers: {\r\n                'Content-Type': 'application/json'\r\n            },\r\n            body: JSON.stringify(payload)\r\n        });\r\n\r\n        if (!response.ok) {\r\n            throw new Error(`Failed to save quiz summary: ${response.statusText}`);\r\n        }\r\n\r\n    } catch (error) {\r\n        console.error(\"Error saving quiz summary:\", error);\r\n    }\r\n}\r\n\r\nfunction extractQuizDataFromSummary(summaryElement) {\r\n    const rows = summaryElement.querySelectorAll(\"tr\");\r\n    const quizData = [];\r\n    rows.forEach(row => {\r\n        const keyEl = row.querySelector(\"th\");\r\n        const valEl = row.querySelector(\"td\");\r\n        if (!keyEl || !valEl) return;\r\n        const key = keyEl.innerText.trim();\r\n        const value = valEl.innerText.trim();\r\n        quizData.push({ key, value });\r\n    });\r\n    return quizData;\r\n}\r\n\r\nfunction extractQuestionsFromSummary() {\r\n    const questionElements = document.querySelectorAll('.que');\r\n    const questions = [];\r\n    questionElements.forEach(el => {\r\n        const questionType = getQuestionType(el);\r\n        if (questionType === 'multichoice') {\r\n            questions.push(extractMultipleChoice(el));\r\n        } else if (questionType === 'truefalse') {\r\n            questions.push(extractTrueFalse(el));\r\n        } else if (questionType === 'shortanswer') {\r\n            questions.push(extractShortAnswer(el));\r\n        }\r\n    });\r\n    return questions;\r\n}\r\nfunction getQuestionType(questionElement) {\r\n    const classes = questionElement.className.split(' ');\r\n    if (classes.includes('multichoice')) {\r\n        return 'multichoice';\r\n    } else if (classes.includes('truefalse')) {\r\n        return 'truefalse';\r\n    } else if (classes.includes('shortanswer')) {\r\n        return 'shortanswer';\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction extractMultipleChoice(questionElement) {\r\n    const answerRows = questionElement.querySelectorAll('.answer > div[class^=\"r\"]');\r\n    const finalAnswers = [];\r\n    const seenAnswers = new Set();\r\n\r\n    const questionTextHTML = extractQuestionHTML(questionElement);\r\n    const questionText = extractQuestionText(questionElement);\r\n\r\n\r\n    let globalCorrectness = getGlobalQuestionCorrectness(questionElement);\r\n\r\n    answerRows.forEach(row => {\r\n        const input = row.querySelector('input[type=\"radio\"], input[type=\"checkbox\"]');\r\n        if (!input) return;\r\n\r\n        const labelContainer = row.querySelector('[data-region=\"answer-label\"]');\r\n        if (!labelContainer) return;\r\n\r\n        const tempContainer = labelContainer.cloneNode(true);\r\n        tempContainer.querySelectorAll('.MathJax_Preview, .MJX_Assistive_MathML').forEach(el => el.remove());\r\n        tempContainer.querySelectorAll('script[type=\"math/tex\"]').forEach(el => el.remove());\r\n\r\n        const answerHTML = tempContainer.innerHTML.trim();\r\n        if (!answerHTML) return;\r\n        if (seenAnswers.has(answerHTML)) return;\r\n        seenAnswers.add(answerHTML);\r\n\r\n        const textContainer = document.createElement('div');\r\n        textContainer.innerHTML = answerHTML;\r\n        let answerText = cleanText(textContainer.innerText.trim());\r\n\r\n        const selected = input.checked;\r\n\r\n        let correct = null;\r\n        if (row.classList.contains('correct')) {\r\n            correct = true;\r\n        } else if (row.classList.contains('incorrect')) {\r\n            correct = false;\r\n        } else {\r\n\r\n            const rightAnswerEl = questionElement.querySelector('.rightanswer');\r\n            if (rightAnswerEl) {\r\n                const correctText = rightAnswerEl.innerText\r\n                    .replace(\"The correct answer is:\", \"\")\r\n                    .replace(\"Poprawna odpowiedź to:\", \"\")\r\n                    .trim();\r\n                correct = (answerText === correctText);\r\n            }\r\n\r\n        }\r\n\r\n        finalAnswers.push({\r\n            html: answerHTML,\r\n            text: answerText,\r\n            selected: selected,\r\n            correct: correct\r\n        });\r\n    });\r\n\r\n    return {\r\n        questionHTML: questionTextHTML,\r\n        questionText: questionText,\r\n        answers: finalAnswers\r\n    };\r\n}\r\n\r\nfunction extractTrueFalse(questionElement) {\r\n    const questionTextHTML = extractQuestionHTML(questionElement);\r\n    const questionText = extractQuestionText(questionElement);\r\n\r\n    const answerRows = questionElement.querySelectorAll('.answer > div');\r\n    const finalAnswers = [];\r\n    const seenAnswers = new Set();\r\n\r\n    let globalCorrectness = getGlobalQuestionCorrectness(questionElement);\r\n\r\n    answerRows.forEach(row => {\r\n        const input = row.querySelector('input[type=\"radio\"]');\r\n        if (!input) return;\r\n\r\n        const label = row.querySelector('label');\r\n        if (!label) return;\r\n\r\n        const answerText = cleanText(label.innerText.trim());\r\n        if (seenAnswers.has(answerText)) return;\r\n        seenAnswers.add(answerText);\r\n\r\n        const selected = input.checked;\r\n        let correct = null;\r\n\r\n        const rightAnswerEl = questionElement.querySelector('.rightanswer');\r\n        if (rightAnswerEl) {\r\n            const text = rightAnswerEl.innerText.trim();\r\n            // Create regex patterns for each language\r\n            const patterns = [\r\n                /The correct answer is:/i,\r\n                /Poprawna odpowiedź to:/i,\r\n                /Правильный ответ:/i,\r\n                /Правильна відповідь:/i\r\n            ];\r\n\r\n            // Try each pattern\r\n            let cleanedText = text;\r\n            for (const pattern of patterns) {\r\n                cleanedText = cleanedText.replace(pattern, '').trim();\r\n                if (cleanedText !== text) break; // Found a match\r\n            }\r\n\r\n            const correctText = cleanText(cleanedText);\r\n            correct = (answerText === correctText);\r\n        } else if (globalCorrectness !== null) {\r\n            if (selected && globalCorrectness === true) {\r\n                correct = true;\r\n            } else if (selected && globalCorrectness === false) {\r\n                correct = false;\r\n            }\r\n        }\r\n\r\n        finalAnswers.push({\r\n            text: answerText,\r\n            selected: selected,\r\n            correct: correct\r\n        });\r\n    });\r\n\r\n    return {\r\n        type: 'truefalse',\r\n        questionHTML: questionTextHTML,\r\n        questionText: questionText,\r\n        answers: finalAnswers\r\n    };\r\n}\r\nfunction extractShortAnswer(questionElement) {\r\n    const questionTextHTML = extractQuestionHTML(questionElement);\r\n    const questionText = extractQuestionText(questionElement);\r\n\r\n    const answerInput = questionElement.querySelector('.ablock input[type=\"text\"]');\r\n    const correctAnswerEl = questionElement.querySelector('.rightanswer');\r\n\r\n    const userAnswer = answerInput ? cleanText(answerInput.value.trim()) : null;\r\n    let correctAnswer = null;\r\n    if (correctAnswerEl) {\r\n        const text = correctAnswerEl.innerText.trim();\r\n        // Create regex patterns for each language\r\n        const patterns = [\r\n            /The correct answer is:/i,\r\n            /Poprawna odpowiedź to:/i,\r\n            /Правильный ответ:/i,\r\n            /Правильна відповідь:/i\r\n        ];\r\n\r\n        // Try each pattern\r\n        let cleanedText = text;\r\n        for (const pattern of patterns) {\r\n            cleanedText = cleanedText.replace(pattern, '').trim();\r\n            if (cleanedText !== text) break; // Found a match\r\n        }\r\n\r\n        correctAnswer = cleanText(cleanedText);\r\n    };\r\n\r\n    let globalCorrectness = getGlobalQuestionCorrectness(questionElement);\r\n\r\n    let isCorrect = null;\r\n    if (correctAnswer && userAnswer) {\r\n        isCorrect = (userAnswer === correctAnswer);\r\n    } else {\r\n        if (globalCorrectness !== null) {\r\n            isCorrect = (globalCorrectness === true);\r\n        } else {\r\n            const gradeElement = questionElement.querySelector('.grade');\r\n            if (gradeElement) {\r\n                isCorrect = interpretGradeAsCorrectness(gradeElement.innerText);\r\n            }\r\n\r\n            if (isCorrect === null) {\r\n                const iconSuccess = questionElement.querySelector('.fa-circle-check.text-success');\r\n                if (iconSuccess) {\r\n                    isCorrect = true;\r\n                } else if (answerInput && answerInput.classList.contains('correct')) {\r\n                    isCorrect = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (isCorrect === true && correctAnswer === null && userAnswer) {\r\n            correctAnswer = userAnswer;\r\n        }\r\n    }\r\n\r\n    return {\r\n        type: 'shortanswer',\r\n        questionHTML: questionTextHTML,\r\n        questionText: questionText,\r\n        userAnswer: userAnswer,\r\n        correctAnswer: correctAnswer,\r\n        isCorrect: isCorrect\r\n    };\r\n}\r\n\r\n\r\nfunction getGlobalQuestionCorrectness(questionElement) {\r\n    const classes = questionElement.className.split(' ');\r\n    if (classes.includes('correct')) {\r\n        return true;\r\n    } else if (classes.includes('incorrect')) {\r\n        return false;\r\n    } else if (classes.includes('partiallycorrect')) {\r\n        return 'partial';\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction interpretGradeAsCorrectness(gradeText) {\r\n    const match = gradeText.match(/Mark\\s+([\\d.,]+)\\s+out of\\s+([\\d.,]+)/i);\r\n    if (match) {\r\n        const obtained = parseFloat(match[1].replace(',', '.'));\r\n        const total = parseFloat(match[2].replace(',', '.'));\r\n        if (!isNaN(obtained) && !isNaN(total) && total > 0) {\r\n            if (obtained === total) {\r\n                return true;\r\n            } else if (obtained === 0) {\r\n                return false;\r\n            } else {\r\n                return 'partial';\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction extractQuestionHTML(questionElement) {\r\n    const qTextEl = questionElement.querySelector('.qtext');\r\n    if (!qTextEl) return '';\r\n    const tempContainer = qTextEl.cloneNode(true);\r\n    tempContainer.querySelectorAll('.MathJax_Preview, .MJX_Assistive_MathML').forEach(el => el.remove());\r\n    return tempContainer.innerHTML.trim();\r\n}\r\n\r\nfunction extractQuestionText(questionElement) {\r\n    const qTextEl = questionElement.querySelector('.qtext');\r\n    if (!qTextEl) return '';\r\n    const tempContainer = qTextEl.cloneNode(true);\r\n    tempContainer.querySelectorAll('.MathJax_Preview, .MJX_Assistive_MathML').forEach(el => el.remove());\r\n    tempContainer.querySelectorAll('script[type=\"math/tex\"]').forEach(el => el.remove());\r\n    return tempContainer.innerText.trim();\r\n}\r\nfunction cleanText(text) {\r\n    return text.replace(/^[a-zA-Z]\\.|^[a-zA-Z]\\)|^\\d+\\./, '').trim();\r\n}\r\n\r\n\r\n\r\n\r\n","import { sendQuestionToChatGPTMicrosoftForms } from '../core/api.js';\r\n\r\n/*************************************************\r\n * 1. DETEKCJA RODZAJU PYTANIA DLA TESTPORTAL\r\n *************************************************/\r\nfunction detectQuestionTypeTestPortal(questionElement) {\r\n    // W TestPortalu rodzaj pytania zwykle siedzi w polu hidden: input[name=\"givenAnswer.questionType\"]\r\n    const questionTypeInput = questionElement.querySelector('input[name=\"givenAnswer.questionType\"]');\r\n    if (!questionTypeInput) {\r\n        console.warn(\"Nie znaleziono typu pytania w:\", questionElement);\r\n        return \"unknown\";\r\n    }\r\n\r\n    const questionTypeValue = questionTypeInput.value;\r\n    switch (questionTypeValue) {\r\n        case \"TRUE_FALSE\":\r\n            return \"trueFalse\";\r\n        case \"SINGLE_ANSWER\":\r\n        case \"SURVEY\":\r\n            return \"singleChoice\";\r\n        case \"MULTI_ANSWER\":\r\n            return \"multipleChoice\";\r\n        case \"SHORT_ANSWER\":\r\n            return \"shortAnswer\";\r\n        case \"DESCRIPTIVE\":\r\n            return \"openText\";\r\n        default:\r\n            return \"unknown\";\r\n    }\r\n}\r\n\r\n/*************************************************\r\n * 2. FUNKCJE POMOCNICZE DO OBRAZKÓW\r\n *************************************************/\r\n\r\nasync function isImagePublic(url) {\r\n    try {\r\n        const response = await fetch(url, { method: \"HEAD\" });\r\n        return response.ok;\r\n    } catch (error) {\r\n        return false;\r\n    }\r\n}\r\n\r\nasync function convertUrlToImageDataUrl(url, forceMime = \"image/jpeg\") {\r\n    const response = await fetch(url);\r\n    if (!response.ok) {\r\n        throw new Error(`Błąd fetch: ${response.status} - ${response.statusText}`);\r\n    }\r\n\r\n    let contentType = response.headers.get(\"content-type\") || \"\";\r\n    if (!contentType.startsWith(\"image/\")) {\r\n        contentType = forceMime;\r\n    }\r\n\r\n    let blob = await response.blob();\r\n    blob = new Blob([blob], { type: contentType });\r\n\r\n    return new Promise((resolve, reject) => {\r\n        const reader = new FileReader();\r\n        reader.onload = () => resolve(reader.result);\r\n        reader.onerror = err => reject(err);\r\n        reader.readAsDataURL(blob);\r\n    });\r\n}\r\n\r\n\r\nasync function ensureImageString(url) {\r\n    const publicAvailable = await isImagePublic(url);\r\n    return publicAvailable ? url : await convertUrlToImageDataUrl(url);\r\n}\r\n\r\n\r\nasync function extractImagesFromTestPortal(element) {\r\n    if (!element) return [];\r\n    const imgs = element.querySelectorAll(\"img\");\r\n    const promises = Array.from(imgs).map(async (img) => {\r\n        const src = img.getAttribute(\"src\");\r\n        if (!src) return null;\r\n        return {\r\n            url: await ensureImageString(src),\r\n            alt: img.alt || \"\"\r\n        };\r\n    });\r\n    const results = await Promise.all(promises);\r\n    return results.filter(Boolean);\r\n}\r\n\r\n/*************************************************\r\n * 3. BUDOWANIE \"UNIFIED\" OBIEKTU PYTANIA \r\n *************************************************/\r\n\r\nasync function buildUnifiedQuestionTestPortal(questionElement) {\r\n    const detectedType = detectQuestionTypeTestPortal(questionElement);\r\n\r\n    const questionTextElement = questionElement.querySelector(\".question_essence\");\r\n    let questionText = questionTextElement ? questionTextElement.innerText.trim() : \"\";\r\n    const questionImages = await extractImagesFromTestPortal(questionTextElement);\r\n\r\n    const unified = {\r\n        id: questionElement.getAttribute('id') || `q-${Date.now()}`,\r\n        text: questionText,\r\n        images: questionImages,\r\n        metadata: { difficulty: \"unknown\" },\r\n    };\r\n\r\n    switch (detectedType) {\r\n        case \"trueFalse\":\r\n        case \"singleChoice\":\r\n            unified.type = \"singlechoice\";\r\n            unified.options = await extractMultipleChoiceAnswersTestPortal(questionElement);\r\n            unified.format = {\r\n                responseType: \"optionId\",\r\n                description: \"Odpowiedz jako pojedyncza litera lub numer odpowiadający właściwej opcji.\"\r\n            };\r\n            break;\r\n\r\n        case \"multipleChoice\":\r\n            unified.type = \"multiple\";\r\n            unified.options = await extractMultipleChoiceAnswersTestPortal(questionElement);\r\n            unified.format = {\r\n                responseType: \"optionIds\",\r\n                description: 'Odpowiedz jako tablica numerów/oznaczeń [np. [\"1\", \"3\"]].'\r\n            };\r\n            break;\r\n\r\n        case \"shortAnswer\":\r\n            unified.type = \"shortanswer\";\r\n            unified.options = [];\r\n            unified.placeholder = \"Wpisz krótką odpowiedź\";\r\n\r\n            const inputShort = questionElement.querySelector(\".all_short_answers input[type='text']\");\r\n            if (inputShort) {\r\n                unified.answerLength = \"short\";\r\n            } else {\r\n                unified.answerLength = \"long\";\r\n            }\r\n            if (unified.answerLength === \"long\") {\r\n                unified.format = {\r\n                    responseType: \"text\",\r\n                    description: \"Podaj wyczerpującą odpowiedź.\"\r\n                };\r\n            } else {\r\n                unified.format = {\r\n                    responseType: \"text\",\r\n                    description: \"Podaj krótką odpowiedź.\"\r\n                };\r\n            }\r\n            break;\r\n\r\n        case \"openText\":\r\n            unified.type = \"shortanswer\";\r\n            unified.options = [];\r\n            unified.placeholder = \"Wpisz odpowiedź opisową\";\r\n            unified.answerLength = \"long\";\r\n            unified.format = {\r\n                responseType: \"text\",\r\n                description: \"Podaj rozwiniętą odpowiedź tekstową (descriptive).\"\r\n            };\r\n            break;\r\n\r\n        default:\r\n            return null;\r\n    }\r\n\r\n    return unified;\r\n}\r\n\r\n/*************************************************\r\n * 4. EKSTRAKCJA OPCJI (multiple/single/trueFalse)\r\n *************************************************/\r\nasync function extractMultipleChoiceAnswersTestPortal(questionElement) {\r\n    const answerElements = questionElement.querySelectorAll(\".question_answers .answer_container\");\r\n    const options = [];\r\n    const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n\r\n    for (let i = 0; i < answerElements.length; i++) {\r\n        const el = answerElements[i];\r\n        const answerBody = el.querySelector(\".answer_body\");\r\n        if (!answerBody) continue;\r\n\r\n        const answerText = answerBody.innerText.trim();\r\n        const images = await extractImagesFromTestPortal(answerBody);\r\n\r\n        options.push({\r\n            id: letters[i],\r\n            label: answerText,\r\n            images\r\n        });\r\n    }\r\n\r\n    return options;\r\n}\r\n\r\n/*************************************************\r\n * 5. OZNACZANIE POPRAWNEJ ODPOWIEDZI W TESTPORTAL\r\n *************************************************/\r\nfunction markCorrectAnswerTestPortal(questionElement, correctAnswerObj, unifiedQuestion, mode) {\r\n    mode = (mode || \"default\").toLowerCase();\r\n    const qType = unifiedQuestion.type;\r\n    if (questionElement.querySelector(\".correct-answer-info\")) {\r\n        return;\r\n    }\r\n    if (questionElement.dataset.alreadyMarked) {\r\n        return;\r\n    }\r\n    questionElement.dataset.alreadyMarked = 'true';\r\n    /******************************************************\r\n     * 1) SINGLECHOICE / MULTIPLE\r\n     ******************************************************/\r\n    if (qType === \"singlechoice\" || qType === \"multiple\") {\r\n        const answerContainers = questionElement.querySelectorAll(\".question_answers .answer_container\");\r\n        if (!answerContainers || answerContainers.length === 0) return;\r\n\r\n        let correctIds = [];\r\n        if (Array.isArray(correctAnswerObj)) {\r\n            correctIds = correctAnswerObj.map((item) => item.trim().toUpperCase());\r\n        } else if (typeof correctAnswerObj === \"string\") {\r\n            if (correctAnswerObj.includes(\",\")) {\r\n                correctIds = correctAnswerObj.split(\",\").map(s => s.trim().toUpperCase());\r\n            } else {\r\n                correctIds = [correctAnswerObj.trim().toUpperCase()];\r\n            }\r\n        }\r\n\r\n        answerContainers.forEach((container, i) => {\r\n            const optionLetter = unifiedQuestion.options[i]?.id.toUpperCase();\r\n            if (!optionLetter) return;\r\n\r\n            const isCorrect = correctIds.includes(optionLetter);\r\n            if (isCorrect) {\r\n                const inputElement = container.querySelector(\"input[type='checkbox'], input[type='radio']\");\r\n                const answerBody = container.querySelector(\".answer_body\");\r\n                if (!answerBody) return;\r\n\r\n                const textContent = answerBody.innerText\r\n                    .replace(/zoom-in\\s*Powiększ obraz/i, \"\")\r\n                    .trim();\r\n                const isTextEmpty = textContent.length === 0;\r\n\r\n                if (mode === 'immediate' || (isTextEmpty && (mode === 'default' || mode === 'savemode'))) {\r\n                    if (inputElement) {\r\n                        inputElement.checked = true;\r\n                        inputElement.dispatchEvent(new Event('change', { bubbles: true }));\r\n                    }\r\n                }\r\n                else if (mode === 'savemode') {\r\n                    const originalText = answerBody.innerText;\r\n                    if (originalText.length > 0) {\r\n                        answerBody.innerHTML = `<span style=\"font-weight: 600;\">${originalText[0]}</span>${originalText.slice(1)}`;\r\n                    }\r\n                }\r\n                else {\r\n                    answerBody.style.color = '#4CAF50';\r\n                    answerBody.style.fontWeight = '700';\r\n                }\r\n\r\n            }\r\n        });\r\n    }\r\n\r\n    /******************************************************\r\n     * 2) SHORTANSWER (w tym openText)\r\n     ******************************************************/\r\n    else if (qType === \"shortanswer\") {\r\n        let inputEl = questionElement.querySelector(\".all_short_answers input[type='text']\");\r\n        if (!inputEl) {\r\n            inputEl = questionElement.querySelector(\".rich-text-answer-area\");\r\n        }\r\n        if (!inputEl) return;\r\n\r\n        let correctAnswerString = \"\";\r\n        if (typeof correctAnswerObj === \"string\") {\r\n            correctAnswerString = correctAnswerObj.trim();\r\n        } else if (correctAnswerObj && correctAnswerObj.value) {\r\n            correctAnswerString = String(correctAnswerObj.value).trim();\r\n        }\r\n\r\n        if (mode === 'immediate') {\r\n            if (inputEl.tagName.toLowerCase() === \"input\") {\r\n                inputEl.value = correctAnswerString;\r\n                inputEl.dispatchEvent(new Event('input', { bubbles: true }));\r\n                inputEl.dispatchEvent(new Event('change', { bubbles: true }));\r\n            } else {\r\n                const hiddenField = document.getElementById(\"givenAnswer\");\r\n                if (hiddenField) {\r\n                    hiddenField.value = correctAnswerString;\r\n                    hiddenField.dispatchEvent(new Event(\"input\", { bubbles: true }));\r\n                    hiddenField.dispatchEvent(new Event(\"change\", { bubbles: true }));\r\n                }\r\n                const iframe = document.getElementById(\"givenAnswer_ifr\");\r\n                if (iframe) {\r\n                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;\r\n                    const edytorBody = iframeDoc.querySelector(\".mce-content-body\") || iframeDoc.body;\r\n                    edytorBody.innerHTML = `<p>${correctAnswerString}</p>`;\r\n                }\r\n            }\r\n        }\r\n        else if (mode === 'savemode') {\r\n            if (inputEl.tagName.toLowerCase() === \"input\") {\r\n                inputEl.value = \"\";\r\n                inputEl.placeholder = \"\";\r\n                inputEl.addEventListener('focus', () => {\r\n                    inputEl.placeholder = correctAnswerString;\r\n                });\r\n                inputEl.addEventListener('blur', () => {\r\n                    inputEl.placeholder = \"\";\r\n                });\r\n            } else {\r\n                const hint = document.createElement(\"div\");\r\n                hint.textContent = `Podpowiedź: ${correctAnswerString}`;\r\n\r\n                // Inline style\r\n                hint.style.color = \"#ccc\";\r\n                hint.style.fontSize = \"0.8em\";\r\n                hint.style.opacity = \"0.1\";\r\n                hint.style.transition = \"opacity 0.2s ease\";\r\n                hint.style.marginTop = \"4px\";\r\n                hint.style.userSelect = \"text\"; // Zmieniono z \"none\" na \"text\" aby można było kopiować\r\n\r\n                // Pokaż hint w pełnej widoczności przy najechaniu\r\n                hint.addEventListener('mouseenter', () => {\r\n                    hint.style.opacity = \"1\";\r\n                });\r\n                hint.addEventListener('mouseleave', () => {\r\n                    hint.style.opacity = \"0.1\";\r\n                });\r\n\r\n                // Wstawiamy zaraz po elemencie\r\n                inputEl.insertAdjacentElement(\"afterend\", hint);\r\n            }\r\n        }\r\n        else {\r\n            // default → wyświetlamy zielony tekst POD polem\r\n            const hint = document.createElement(\"div\");\r\n            hint.classList.add(\"correct-answer-info\");\r\n\r\n            // Style dla kontenera odpowiedzi\r\n            hint.style.background = \"#f0fff0\";\r\n            hint.style.border = \"1px solid #ddeedd\";\r\n            hint.style.borderRadius = \"4px\";\r\n            hint.style.marginTop = \"10px\";\r\n            hint.style.marginBottom = \"10px\";\r\n            hint.style.padding = \"8px 12px\";\r\n            hint.style.width = \"100%\";\r\n            hint.style.boxSizing = \"border-box\";\r\n            hint.style.fontSize = \"14px\";\r\n            hint.style.color = \"green\";\r\n\r\n            // Struktura: nagłówek + treść\r\n            hint.innerHTML = `\r\n                <div style=\"font-weight: bold; margin-bottom: 4px;\">Poprawna odpowiedź:</div>\r\n                <div>${correctAnswerString}</div>\r\n            `;\r\n\r\n            if (inputEl.tagName.toLowerCase() === \"input\") {\r\n                const parentContainer = inputEl.closest(\".all_short_answers\");\r\n                if (parentContainer) {\r\n                    parentContainer.appendChild(hint);\r\n                } else {\r\n                    inputEl.insertAdjacentElement(\"afterend\", hint);\r\n                }\r\n            } else {\r\n                // Dla .rich-text-answer-area\r\n                inputEl.insertAdjacentElement(\"afterend\", hint);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/*************************************************\r\n * 6. OBSŁUGA POJEDYNCZEGO PYTANIA\r\n *************************************************/\r\nasync function handleQuestionTestPortal(questionElement, mode, userEmail) {\r\n    // === POCZĄTEK SUGEROWANEJ ZMIANY ===\r\n\r\n    // Sprawdź, czy pytanie nie zostało już przetworzone, aby uniknąć duplikatów zapytań API\r\n    if (questionElement.dataset.alreadyHandled === 'true') {\r\n        // console.log(\"Pytanie już obsłużone, pomijam:\", questionElement.id);\r\n        return null;\r\n    }\r\n    // Ustaw flagę natychmiast, aby zablokować kolejne próby przetworzenia tego samego pytania\r\n    questionElement.dataset.alreadyHandled = 'true';\r\n\r\n    // === KONIEC SUGEROWANEJ ZMIANY ===\r\n\r\n    const unifiedQuestion = await buildUnifiedQuestionTestPortal(questionElement);\r\n    if (!unifiedQuestion) {\r\n        // Jeśli pytanie jest nieprawidłowe, usuń flagę, aby umożliwić ewentualną ponowną próbę\r\n        delete questionElement.dataset.alreadyHandled;\r\n        return null;\r\n    }\r\n\r\n    return sendQuestionToChatGPTMicrosoftForms(unifiedQuestion, userEmail, mode)\r\n        .then(response => {\r\n            if (response && response.correctAnswer) {\r\n                markCorrectAnswerTestPortal(\r\n                    questionElement,\r\n                    response.correctAnswer,\r\n                    unifiedQuestion,\r\n                    mode\r\n                );\r\n                // Flaga alreadyHandled pozostaje 'true' po sukcesie\r\n                return response.correctAnswer;\r\n            } else {\r\n                // Jeśli nie ma odpowiedzi, usuń flagę, aby pozwolić na ponowną próbę\r\n                delete questionElement.dataset.alreadyHandled;\r\n            }\r\n            return null;\r\n        })\r\n        .catch(err => {\r\n            console.error(\"Błąd zapytania do endpointu /query-chatgpt-mf (TestPortal):\", err);\r\n            // W przypadku błędu sieciowego również usuń flagę\r\n            delete questionElement.dataset.alreadyHandled;\r\n            return null;\r\n        });\r\n}\r\n\r\n\r\n\r\n/*************************************************\r\n * 7. OBSŁUGA WSZYSTKICH PYTAŃ NA STRONIE\r\n *************************************************/\r\nexport async function processTestPortalLikeMicrosoftForms(userEmail) {\r\n\r\n    const { markingMode } = await new Promise((resolve) => {\r\n        chrome.storage.local.get(['markingMode'], (result) => {\r\n            resolve({ markingMode: result.markingMode || 'default' });\r\n        });\r\n    });\r\n\r\n    const questions = document.querySelectorAll(\".test-question-body\");\r\n    if (!questions.length) {\r\n        return;\r\n    }\r\n\r\n    // === POCZĄTEK SUGEROWANEJ ZMIANY ===\r\n\r\n    // Przetwarzaj wszystkie znalezione pytania równolegle, zamiast jedno po drugim\r\n    const processingPromises = Array.from(questions).map(questionElement =>\r\n        handleQuestionTestPortal(questionElement, markingMode, userEmail)\r\n    );\r\n\r\n    // Poczekaj na zakończenie wszystkich operacji\r\n    const results = await Promise.all(processingPromises);\r\n}\r\n","import { sendQuestionToChatGPTMicrosoftForms } from '../core/api.js';\r\n\r\n/*************************************************\r\n * FUNKCJA POBIERAJĄCA OBRAZY\r\n *************************************************/\r\n// Dodaj funkcję pomocniczą, która czeka na załadowanie obrazu\r\nasync function waitForImageLoad(img, timeout = 5000) {\r\n    return new Promise(resolve => {\r\n        if (img.complete && img.naturalWidth !== 0) {\r\n            return resolve();\r\n        }\r\n        const timer = setTimeout(resolve, timeout);\r\n        img.addEventListener(\"load\", () => {\r\n            clearTimeout(timer);\r\n            resolve();\r\n        });\r\n        img.addEventListener(\"error\", () => {\r\n            clearTimeout(timer);\r\n            resolve();\r\n        });\r\n    });\r\n}\r\n\r\nasync function extractImages(element) {\r\n    const imageElements = element.querySelectorAll('img');\r\n    const images = [];\r\n    for (const img of imageElements) {\r\n        await waitForImageLoad(img);  // czekamy na załadowanie obrazu\r\n        images.push({\r\n            url: img.src,\r\n            alt: img.alt || \"\"\r\n        });\r\n    }\r\n    return images;\r\n}\r\n\r\n\r\n/*************************************************\r\n * 0. FUNKCJA POMOCNICZA DO EKSTRAKCJI ZAPISU MATEMATYCZNEGO\r\n *************************************************/\r\n/**\r\n * Funkcja do ekstrakcji zapisu matematycznego z danego elementu.\r\n * Jeśli elementy MathJax lub te z atrybutem data-mathml nie są od razu dostępne,\r\n * funkcja wykonuje synchroniczne oczekiwanie (busy-waiting) przez określony czas.\r\n *\r\n * @param {HTMLElement} element - Element, z którego pobieramy zapis matematyczny.\r\n * @param {number} timeout - Maksymalny czas oczekiwania (w ms), domyślnie 300 ms.\r\n * @returns {string} - Wyekstrahowany zapis matematyczny.\r\n */\r\nfunction extractMathContent(element, timeout = 300) {\r\n    const pollInterval = 10;\r\n    const startTime = Date.now();\r\n    return new Promise((resolve) => {\r\n        function poll() {\r\n            // Jeśli istnieje element <script type=\"math/tex\">, pobieramy jego treść\r\n            const scriptEl = element.querySelector('script[type=\"math/tex\"]');\r\n            if (scriptEl) {\r\n                return resolve(scriptEl.textContent.trim());\r\n            }\r\n            // Inaczej szukamy elementów MathJax lub [data-mathml]\r\n            const mathElements = element.querySelectorAll('.MathJax, [data-mathml]');\r\n            if (mathElements.length > 0 || (Date.now() - startTime) >= timeout) {\r\n                let mathContent = \"\";\r\n                mathElements.forEach(mathEl => {\r\n                    if (mathEl.hasAttribute('data-mathml')) {\r\n                        mathContent += \" \" + mathEl.getAttribute('data-mathml').trim();\r\n                    } else if (mathEl.innerText && mathEl.innerText.trim().length > 0) {\r\n                        mathContent += \" \" + mathEl.innerText.trim();\r\n                    }\r\n                });\r\n                // Dodatkowo przeszukujemy HTML w poszukiwaniu LaTeX otoczonego dolarami\r\n                const rawHTML = element.innerHTML;\r\n                const latexRegex = /\\$(.*?)\\$/g;\r\n                let match;\r\n                while ((match = latexRegex.exec(rawHTML)) !== null) {\r\n                    if (match[1] && match[1].trim().length > 0) {\r\n                        mathContent += \" \" + match[1].trim();\r\n                    }\r\n                }\r\n                resolve(mathContent.trim());\r\n            } else {\r\n                setTimeout(poll, pollInterval);\r\n            }\r\n        }\r\n        poll();\r\n    });\r\n}\r\n\r\n\r\n/*************************************************\r\n * 1. DETEKCJA RODZAJU PYTANIA\r\n *************************************************/\r\nexport function detectQuestionTypeMicrosoftForms(questionElement) {\r\n    // Jeśli widoczna jest struktura Likerta (np. tabele z nagłówkami lub wierszami Likerta)\r\n    if (\r\n        questionElement.querySelector('[data-automation-id=\"likerTableTh\"]') ||\r\n        questionElement.querySelector('[data-automation-id=\"likerTableTr\"]')\r\n    ) {\r\n        return \"likert\";\r\n    }\r\n    // Mobile: Likert – struktura z subquestion\r\n    if (questionElement.querySelector('[data-automation-id=\"likerSubQuestion\"]')) {\r\n        return \"likert\";\r\n    }\r\n\r\n    // Spróbuj wykryć typ pytania na podstawie tekstu tytułu\r\n    const questionInfo = questionElement.querySelector('[data-automation-id=\"questionTitle\"] [aria-hidden=\"true\"]');\r\n    if (questionInfo) {\r\n        const questionType = questionInfo.innerText.toLowerCase().trim();\r\n        // Dla pytań jednokrotnego wyboru\r\n        if (questionType.includes(\"pojedynczy wybór\") || questionType.includes(\"jednokrotny wybór\")) {\r\n            return \"singleChoice\";\r\n        }\r\n        // Dla pytań wielokrotnego wyboru\r\n        else if (questionType.includes(\"wielokrotny wybór\") || questionType.includes(\"multi wybór\")) {\r\n            return \"multipleChoice\";\r\n        }\r\n        // Dla pytań związanych z datą\r\n        else if (questionType.includes(\"data\")) {\r\n            return \"date\";\r\n        }\r\n        // Dla pytań otwartych (tekstowych)\r\n        else if (questionType.includes(\"tekst\")) {\r\n            return \"openText\";\r\n        }\r\n        // Dla pytań typu ranking lub klasyfikacja\r\n        else if (questionType.includes(\"klasyfikacja\")) {\r\n            return \"ranking\";\r\n        }\r\n    }\r\n\r\n    // Alternatywne podejście - wykrywanie po strukturze DOM\r\n    if (questionElement.querySelector('input[type=\"radio\"]')) {\r\n        return \"singleChoice\";\r\n    }\r\n    if (questionElement.querySelector('input[type=\"checkbox\"]')) {\r\n        return \"multipleChoice\";\r\n    }\r\n    if (questionElement.querySelector('[data-automation-id=\"textInput\"]') || questionElement.querySelector('textarea')) {\r\n        return \"openText\";\r\n    }\r\n    if (questionElement.querySelector('[data-automation-id=\"dateContainer\"]')) {\r\n        return \"date\";\r\n    }\r\n    if (questionElement.querySelector('[data-automation-id=\"rankingItemContent\"]')) {\r\n        return \"ranking\";\r\n    }\r\n\r\n    return \"unknown\";\r\n}\r\n\r\n\r\n/*************************************************\r\n * 2. EKSTRAKCJA TEKSTU PYTANIA\r\n *************************************************/\r\nasync function extractQuestionTextMicrosoftForms(questionElement) {\r\n    const mainTitleEl = questionElement.querySelector('[data-automation-id=\"questionTitle\"] .text-format-content');\r\n    const subTitleEl = questionElement.querySelector('[data-automation-id=\"questionSubTitle\"] .text-format-content');\r\n    let questionText = \"\";\r\n    if (mainTitleEl) {\r\n        questionText += mainTitleEl.innerText.trim();\r\n        // Dodajemy zapis matematyczny z głównego tytułu\r\n        const mathFromMain = await extractMathContent(mainTitleEl);\r\n        if (mathFromMain) {\r\n            questionText += \"\\n\" + mathFromMain;\r\n        }\r\n    }\r\n    if (subTitleEl) {\r\n        questionText += \"\\n\" + subTitleEl.innerText.trim();\r\n        // Dodajemy zapis matematyczny z podtytułu\r\n        const mathFromSub = await extractMathContent(subTitleEl);\r\n        if (mathFromSub) {\r\n            questionText += \"\\n\" + mathFromSub;\r\n        }\r\n    }\r\n\r\n    const questionContent = questionElement.querySelector(':not([data-automation-id=\"choiceItem\"])');\r\n    const mathFromQuestion = questionContent ? await extractMathContent(questionContent) : \"\";\r\n    if (mathFromQuestion && !questionText.includes(mathFromQuestion)) {\r\n        questionText += \"\\n\" + mathFromQuestion;\r\n    }\r\n    const images = await extractImages(questionElement);\r\n    return { text: questionText.trim(), images };\r\n}\r\n\r\n/*************************************************\r\n * 3. EKSTRAKCJA ODPOWIEDZI DLA PYTAŃ SINGLE/MULTIPLE CHOICE\r\n *************************************************/\r\nasync function extractMultipleChoiceAnswersMicrosoftForms(questionElement) {\r\n    let answerElements = questionElement.querySelectorAll('[data-automation-id=\"choiceItem\"]');\r\n    const options = [];\r\n    const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n    let idx = 0;\r\n\r\n    // Jeśli nie znaleziono żadnych elementów opcji (np. dla pytań, gdzie opcje są obrazami),\r\n    // spróbuj znaleźć <img> w kontenerze odpowiedzi (np. w div.-bT-49)\r\n    if (!answerElements || answerElements.length === 0) {\r\n        const container = questionElement.querySelector('div.-bT-49');\r\n        if (container) {\r\n            const imgs = container.querySelectorAll('img');\r\n            imgs.forEach((img, index) => {\r\n                const id = letters[index] || (\"\" + (index + 1));\r\n                options.push({\r\n                    id,\r\n                    // Jeśli nie mamy sensownego labela, używamy domyślnego \"Opcja X\"\r\n                    label: `Opcja ${index + 1}`,\r\n                    images: [{ url: img.src, alt: img.alt || \"\" }]\r\n                });\r\n            });\r\n            return options;\r\n        }\r\n    }\r\n\r\n    // Jeśli znaleziono elementy opcji – postępuj jak dotychczas\r\n    for (let answerElement of answerElements) {\r\n        let answerText = \"\";\r\n        // Najpierw sprawdzamy, czy istnieje atrybut data-automation-value\r\n        const autoVal = answerElement.querySelector('[data-automation-value]');\r\n        if (autoVal) {\r\n            answerText = autoVal.getAttribute('data-automation-value').trim();\r\n        } else {\r\n            const scriptEl = answerElement.querySelector('script[type=\"math/tex\"]');\r\n            if (scriptEl) {\r\n                answerText = scriptEl.textContent.trim();\r\n            } else {\r\n                const mathContent = await extractMathContent(answerElement);\r\n                const textContent = answerElement.querySelector('.text-format-content')?.innerText.trim() || \"\";\r\n                answerText = textContent + (mathContent ? (\"\\n\" + mathContent) : \"\");\r\n            }\r\n        }\r\n        const images = await extractImages(answerElement);\r\n        const id = letters[idx] || (\"\" + (idx + 1));\r\n        options.push({\r\n            id,\r\n            label: answerText,\r\n            images\r\n        });\r\n        idx++;\r\n    }\r\n    return options;\r\n}\r\n\r\n\r\n\r\n/*************************************************\r\n * 4. EKSTRAKCJA DLA PYTAŃ OPEN TEXT\r\n *************************************************/\r\nasync function extractOpenTextQuestionMicrosoftForms(questionElement) {\r\n    // Dla pytań openText nie mamy opcji – przekazujemy jedynie placeholder oraz ewentualne obrazy\r\n    const inputElement = questionElement.querySelector('input[type=\"text\"], textarea');\r\n    const images = await extractImages(questionElement);\r\n    return {\r\n        placeholder: inputElement ? inputElement.placeholder || \"Wprowadź odpowiedź\" : \"Wprowadź odpowiedź\",\r\n        images\r\n    };\r\n}\r\n\r\n/*************************************************\r\n * 5. EKSTRAKCJA DLA PYTAŃ RANKING\r\n *************************************************/\r\nasync function extractRankingQuestionMicrosoftForms(questionElement) {\r\n    // Zakładamy, że ranking itemy posiadają atrybut data-automation-id=\"rankingItemContent\"\r\n    const rankingItemElements = questionElement.querySelectorAll('[data-automation-id=\"rankingItemContent\"]');\r\n    // Tworzymy tablicę obiektów – przyjmujemy, że kolejność w DOM-ie to oryginalna kolejność\r\n    const ranking = Array.from(rankingItemElements).map((item, index) => ({\r\n        id: index + 1,  // oryginalna pozycja\r\n        label: item.innerText.trim()\r\n    }));\r\n    return { ranking };\r\n}\r\n\r\n/*************************************************\r\n * 5. EKSTRAKCJA DLA PYTAŃ DATE\r\n *************************************************/\r\nasync function extractDateQuestionMicrosoftForms(questionElement) {\r\n    // Szukamy kontenera, który zawiera pole daty – w Twojej strukturze atrybut data-automation-id=\"dateContainer\"\r\n    const dateContainer = questionElement.querySelector('[data-automation-id=\"dateContainer\"]');\r\n    let placeholder = \"Wprowadź datę (dd.MM.yyyy)\";\r\n    if (dateContainer) {\r\n        // Pobieramy pole input typu text w obrębie kontenera\r\n        const inputElement = dateContainer.querySelector('input[type=\"text\"]');\r\n        if (inputElement) {\r\n            placeholder = inputElement.placeholder || placeholder;\r\n        }\r\n    }\r\n    const images = await extractImages(questionElement);\r\n    return { placeholder, images };\r\n}\r\n\r\n\r\n/*************************************************\r\n * 5. EKSTRAKCJA DLA PYTAŃ LIKERT\r\n *************************************************/\r\nasync function extractLikertQuestionMicrosoftForms(questionElement) {\r\n    // Jeśli mamy strukturę desktopową (tabela)\r\n    if (questionElement.querySelector('[data-automation-id=\"likerTableTr\"]')) {\r\n        const statementElements = questionElement.querySelectorAll('[data-automation-id=\"likerStatementTd\"] .text-format-content');\r\n        const optionElements = questionElement.querySelectorAll('[data-automation-id=\"likerTableTh\"] .text-format-content');\r\n\r\n        const statements = await Promise.all(\r\n            Array.from(statementElements).map(async (el, idx) => {\r\n                const images = await extractImages(el);\r\n                return { id: `s${idx + 1}`, text: el.innerText.trim(), images };\r\n            })\r\n        );\r\n\r\n        const letters = [\"P\", \"F\"];\r\n        const commonOptions = await Promise.all(\r\n            Array.from(optionElements).map(async (el, idx) => {\r\n                const images = await extractImages(el);\r\n                let id = letters[idx] || String.fromCharCode(65 + idx);\r\n                return { id, label: el.innerText.trim(), images };\r\n            })\r\n        );\r\n\r\n        return { commonOptions, statements };\r\n    }\r\n    // Jeśli mamy strukturę mobilną (subquestion)\r\n    else if (questionElement.querySelector('[data-automation-id=\"likerSubQuestion\"]')) {\r\n        const subQuestionElements = questionElement.querySelectorAll('[data-automation-id=\"likerSubQuestion\"]');\r\n        const statements = await Promise.all(\r\n            Array.from(subQuestionElements).map(async (subQ, idx) => {\r\n                const stmtEl = subQ.querySelector('.-q--329 .text-format-content');\r\n                const images = stmtEl ? await extractImages(stmtEl) : [];\r\n                return { id: `s${idx + 1}`, text: stmtEl ? stmtEl.innerText.trim() : \"\", images };\r\n            })\r\n        );\r\n        // Zakładamy, że opcje są takie same we wszystkich subquestion – pobieramy z pierwszego\r\n        const firstSubQ = questionElement.querySelector('[data-automation-id=\"likerSubQuestion\"]');\r\n        let optionElements = [];\r\n        if (firstSubQ) {\r\n            optionElements = firstSubQ.querySelectorAll('[data-automation-id=\"likerOption\"]');\r\n        }\r\n        const letters = [\"P\", \"F\"];\r\n        const commonOptions = await Promise.all(\r\n            Array.from(optionElements).map(async (optEl, idx) => {\r\n                const labelEl = optEl.querySelector('.-jt-333 .text-format-content');\r\n                const images = labelEl ? await extractImages(labelEl) : [];\r\n                let id = letters[idx] || String.fromCharCode(65 + idx);\r\n                const label = labelEl ? labelEl.innerText.trim() : \"\";\r\n                return { id, label, images };\r\n            })\r\n        );\r\n        return { commonOptions, statements };\r\n    }\r\n\r\n    // Fallback – jeśli struktura nie jest rozpoznana\r\n    return { commonOptions: [], statements: [] };\r\n}\r\n\r\n/*************************************************\r\n * 6. BUDOWANIE UNIFIKOWANEJ STRUKTURY PYTANIA\r\n *************************************************/\r\nasync function buildUnifiedQuestion(questionElement) {\r\n    const detectedType = detectQuestionTypeMicrosoftForms(questionElement);\r\n    const { text, images } = await extractQuestionTextMicrosoftForms(questionElement);\r\n    let unified = {\r\n        id: questionElement.getAttribute('id') || `q-${Date.now()}`, // unikalny identyfikator\r\n        text,\r\n        images,\r\n        metadata: { difficulty: \"unknown\" } // Możesz to rozszerzyć\r\n    };\r\n\r\n    // Mapowanie typu: singleChoice -> singlechoice, multipleChoice -> multiple, openText -> shortanswer, likert -> likert\r\n    switch (detectedType) {\r\n        case \"singleChoice\":\r\n            unified.type = \"singlechoice\";\r\n            unified.options = await extractMultipleChoiceAnswersMicrosoftForms(questionElement);\r\n            unified.format = {\r\n                responseType: \"optionId\",\r\n                description: \"Odpowiedz jako pojedyncza litera odpowiadająca właściwej opcji.\"\r\n            };\r\n            break;\r\n        case \"multipleChoice\":\r\n            unified.type = \"multiple\";\r\n            unified.options = await extractMultipleChoiceAnswersMicrosoftForms(questionElement);\r\n            unified.format = {\r\n                responseType: \"optionIds\",\r\n                description: \"Odpowiedz jako tablica liter odpowiadających właściwym opcjom (np. [\\\"A\\\", \\\"C\\\"]).\"\r\n            };\r\n            break;\r\n        case \"date\":\r\n            unified.type = \"date\";\r\n            const dateData = await extractDateQuestionMicrosoftForms(questionElement);\r\n            unified.options = [];  // Dla dat nie ma opcji wyboru\r\n            unified.placeholder = dateData.placeholder;\r\n            unified.format = {\r\n                responseType: \"date\",\r\n                description: \"Podaj datę w formacie dd.MM.yyyy.\"\r\n            };\r\n            break;\r\n\r\n        case \"openText\":\r\n            unified.type = \"shortanswer\";\r\n            const openData = await extractOpenTextQuestionMicrosoftForms(questionElement);\r\n            unified.options = [];\r\n            unified.placeholder = openData.placeholder;\r\n\r\n            // Sprawdzamy, czy odpowiedź jest \"krótka\" (input) czy \"długa\" (textarea)\r\n            const inputElement = questionElement.querySelector('input[type=\"text\"], textarea');\r\n            if (inputElement) {\r\n                if (inputElement.tagName.toLowerCase() === \"textarea\") {\r\n                    unified.answerLength = \"long\";\r\n                } else {\r\n                    unified.answerLength = \"short\";\r\n                }\r\n            } else {\r\n                unified.answerLength = \"short\";\r\n            }\r\n\r\n            // Ustawiamy format zależnie od długości odpowiedzi\r\n            if (unified.answerLength === \"long\") {\r\n                unified.format = {\r\n                    responseType: \"text\",\r\n                    description: \"Podaj wyczerpującą, szczegółową odpowiedź tekstową.\"\r\n                };\r\n            } else {\r\n                unified.format = {\r\n                    responseType: \"text\",\r\n                    description: \"Podaj krótką odpowiedź tekstową.\"\r\n                };\r\n            }\r\n            break;\r\n        case \"likert\":\r\n            unified.type = \"likert\";\r\n            const likertData = await extractLikertQuestionMicrosoftForms(questionElement);\r\n            unified.commonOptions = likertData.commonOptions;\r\n            unified.statements = likertData.statements;\r\n            unified.format = {\r\n                responseType: \"matrix\",\r\n                description: \"Odpowiedz jako obiekt JSON, gdzie każdy klucz to id stwierdzenia (np. 's1'), a wartość to identyfikator wybranej opcji ('P' dla Prawda lub 'F' dla Fałsz).\"\r\n            };\r\n            break;\r\n        case \"ranking\":\r\n            unified.type = \"ranking\";\r\n            const rankingData = await extractRankingQuestionMicrosoftForms(questionElement);\r\n            unified.ranking = rankingData.ranking; // Tablica ranking itemów\r\n            unified.format = {\r\n                responseType: \"ranking\",\r\n                description: \"Podaj poprawną kolejność elementów jako uporządkowaną listę numerów, np. [2, 1, 3, 4].\"\r\n            };\r\n            break;\r\n\r\n\r\n\r\n        default:\r\n            // console.warn(\"Nieobsługiwany typ pytania:\", detectedType);\r\n            return null;\r\n    }\r\n    return unified;\r\n}\r\n\r\nfunction getCorrectAnswerText() {\r\n    // Pobierz język przeglądarki\r\n    const browserLang = navigator.language || navigator.userLanguage;\r\n    const lang = browserLang.split('-')[0];\r\n\r\n    const translations = {\r\n        'pl': 'Poprawna odpowiedź:',\r\n        'en': 'Correct answer:',\r\n        'de': 'Richtige Antwort:',\r\n        'es': 'Respuesta correcta:',\r\n        'fr': 'Réponse correcte:',\r\n        'it': 'Risposta corretta:',\r\n        'ru': 'Правильный ответ:',\r\n        'cs': 'Správná odpověď:',\r\n        'sk': 'Správna odpoveď:',\r\n        'uk': 'Правильна відповідь:'\r\n    };\r\n\r\n    return translations[lang] || translations['en'];\r\n}\r\n\r\n\r\n/*************************************************\r\n * 7. ZAZNACZANIE POPRAWNEJ ODPOWIEDZI – UNIFIKOWANE\r\n *************************************************/\r\nfunction markCorrectAnswerUnified(questionElement, correctAnswerObj, unifiedQuestion, mode) {\r\n    mode = mode.toLowerCase()\r\n    // console.log(\"Markowanie odpowiedzi dla pytania:\", unifiedQuestion.id, \"tryb:\", mode);\r\n    const qType = unifiedQuestion.type;\r\n\r\n    if (qType === \"singlechoice\" || qType === \"multiple\") {\r\n        let answerElements = questionElement.querySelectorAll('[data-automation-id=\"choiceItem\"]');\r\n        if (!answerElements || answerElements.length === 0) {\r\n            answerElements = questionElement.querySelectorAll('div.-mf-91');\r\n        }\r\n\r\n        const isIndexMode = typeof correctAnswerObj === \"string\" && /^[\\d,\\s]+$/.test(correctAnswerObj.trim());\r\n        let correctIndexes = [];\r\n        let correctLetters = [];\r\n        if (isIndexMode) {\r\n            correctIndexes = correctAnswerObj\r\n                .split(\",\")\r\n                .map(str => parseInt(str.trim(), 10) - 1)\r\n                .filter(n => !isNaN(n) && n >= 0);\r\n        } else if (Array.isArray(correctAnswerObj)) {\r\n            correctLetters = correctAnswerObj.map(letter => letter.toUpperCase());\r\n        } else if (typeof correctAnswerObj === \"string\") {\r\n            correctLetters = [correctAnswerObj.trim().toUpperCase()];\r\n        }\r\n\r\n        // console.log(\"Oczekiwane indeksy:\", correctIndexes, \"lub litery:\", correctLetters);\r\n        // console.log(answerElements)\r\n        answerElements.forEach((answerElement, idx) => {\r\n            // Pobieramy element zawierający treść (MathJax lub tekst)\r\n            const answerTextEl = answerElement.querySelector('.text-format-content') || answerElement;\r\n            // Ustalamy identyfikator opcji – jeśli nie ma, używamy domyślnego: A, B, C, …\r\n            const optionLetter = unifiedQuestion.options[idx]?.id || String.fromCharCode(65 + idx);\r\n            let isCorrect = false;\r\n            if (isIndexMode) {\r\n                if (correctIndexes.includes(idx)) {\r\n                    isCorrect = true;\r\n                }\r\n            } else {\r\n                if (optionLetter && correctLetters.includes(optionLetter.toUpperCase())) {\r\n                    isCorrect = true;\r\n                }\r\n            }\r\n\r\n            // console.log(`Opcja ${idx}: identyfikator = ${optionLetter}, jest poprawna?`, isCorrect);\r\n\r\n            if (isCorrect) {\r\n                // console.log(answerElement)\r\n                if (mode === \"default\") {\r\n                    // Najpierw próbujemy oznaczyć zapis matematyczny, jeśli istnieje\r\n                    const mathEl = answerTextEl.querySelector('.MathJax');\r\n                    // console.log(mathEl)\r\n\r\n                    if (mathEl) {\r\n                        if (mathEl.getBoundingClientRect().height < 5) {\r\n                            setTimeout(() => {\r\n                                mathEl.style.boxShadow = \"0 0 10px rgba(0, 128, 0, 0.7)\";\r\n                                mathEl.style.border = \"2px solid rgba(0, 128, 0, 0.7)\";\r\n                                mathEl.style.backgroundColor = \"rgba(0, 128, 0, 0.1)\";\r\n                                mathEl.style.transition = \"all 0.3s ease\";\r\n                                mathEl.style.padding = \"10px\";\r\n                                mathEl.style.borderRadius = \"5px\";\r\n                            }, 200);\r\n                        } else {\r\n                            mathEl.style.boxShadow = \"0 0 10px rgba(0, 128, 0, 0.7)\";\r\n                            mathEl.style.border = \"2px solid rgba(0, 128, 0, 0.7)\";\r\n                            mathEl.style.backgroundColor = \"rgba(0, 128, 0, 0.1)\";\r\n                            mathEl.style.transition = \"all 0.3s ease\";\r\n                            mathEl.style.padding = \"10px\";\r\n                            mathEl.style.borderRadius = \"5px\";\r\n                        }\r\n                    } else {\r\n                        answerTextEl.style.color = \"green\";\r\n                        answerTextEl.style.fontWeight = \"700\";\r\n                    }\r\n\r\n                    // Teraz obsługa obrazków\r\n                    const imgEl = answerElement.querySelector('img');\r\n                    // console.log(imgEl)\r\n                    if (imgEl) {\r\n                        if (imgEl.naturalWidth < 20) { // obraz nie jest jeszcze załadowany\r\n                            setTimeout(() => {\r\n                                answerTextEl.style.boxShadow = \"0 0 10px rgba(0, 128, 0, 0.7)\";\r\n                                answerTextEl.style.border = \"2px solid rgba(0, 128, 0, 0.7)\";\r\n                                answerTextEl.style.backgroundColor = \"rgba(0, 128, 0, 0.1)\";\r\n                                answerTextEl.style.transition = \"all 0.3s ease\";\r\n                                answerTextEl.style.padding = \"10px\";\r\n                                answerTextEl.style.borderRadius = \"5px\";\r\n                            }, 300);\r\n                        } else {\r\n                            answerTextEl.style.boxShadow = \"0 0 10px rgba(0, 128, 0, 0.7)\";\r\n                            answerTextEl.style.border = \"2px solid rgba(0, 128, 0, 0.7)\";\r\n                            answerTextEl.style.backgroundColor = \"rgba(0, 128, 0, 0.1)\";\r\n                            answerTextEl.style.transition = \"all 0.3s ease\";\r\n                            answerTextEl.style.padding = \"10px\";\r\n                            answerTextEl.style.borderRadius = \"5px\";\r\n                        }\r\n                    } else {\r\n                        // Jeśli nie ma obrazka, zmieniamy styl tekstu\r\n                        answerTextEl.style.color = \"green\";\r\n                        answerTextEl.style.fontWeight = \"700\";\r\n                    }\r\n                } else if (mode === \"immediate\") {\r\n                    // W trybie immediate spróbuj symulować kliknięcie na input\r\n                    const inputEl = answerElement.querySelector('input[type=\"radio\"], input[type=\"checkbox\"]');\r\n                    if (inputEl) {\r\n                        if (inputEl.type === \"checkbox\") {\r\n                            if (!inputEl.checked) {\r\n                                inputEl.checked = true;\r\n                            }\r\n                        } else {\r\n                            inputEl.click();\r\n                        }\r\n                        inputEl.dispatchEvent(new Event('input', { bubbles: true }));\r\n                        inputEl.dispatchEvent(new Event('change', { bubbles: true }));\r\n                    }\r\n                } else if (mode === \"savemode\") {\r\n                    const mathEl = answerTextEl.querySelector('.MathJax');\r\n                    if (mathEl) {\r\n                        mathEl.style.boxShadow = \"0 0 0 1px rgba(0, 128, 0, 0.03)\";\r\n                        mathEl.style.border = \"1px solid rgba(0, 128, 0, 0.03)\";\r\n                        mathEl.style.backgroundColor = \"rgba(0, 128, 0, 0.01)\";\r\n                        mathEl.style.padding = \"2px\";\r\n                        mathEl.style.borderRadius = \"3px\";\r\n                    } else {\r\n                        const text = answerTextEl.textContent;\r\n                        if (text.length > 0) {\r\n                            answerTextEl.innerHTML = `<span style=\"font-weight:600; opacity:0.8;\">${text.charAt(0)}</span>${text.slice(1)}`;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    else if (qType === \"shortanswer\") {\r\n        // Pobieramy element input lub textarea\r\n        const inputElement = questionElement.querySelector('[data-automation-id=\"textInput\"]');\r\n        if (!inputElement) return;\r\n\r\n        if (!inputElement.classList.contains('savemode-input')) {\r\n            inputElement.classList.add('savemode-input');\r\n        }\r\n\r\n        if (mode === \"default\") {\r\n            // Dla długiej odpowiedzi (textarea) ustawiamy placeholder i dodajemy treść odpowiedzi\r\n            const inputEl = questionElement.querySelector('[data-automation-id=\"textInput\"]');\r\n            if (!inputEl) return;\r\n\r\n            // Upewniamy się, że kontener inputa (rodzic) ma styl block,\r\n            // dzięki czemu element wstawiony za nim pojawi się w nowej linii.\r\n            const container = inputEl.parentElement;\r\n            container.style.display = \"block\";\r\n\r\n            // Szukamy istniejącego elementu z informacją lub tworzymy nowy\r\n            let info = container.querySelector('.correct-answer-info');\r\n            if (!info) {\r\n                info = document.createElement(\"div\");\r\n                info.classList.add(\"correct-answer-info\");\r\n                info.style.display = \"block\";\r\n                info.style.marginTop = \"10px\";\r\n                info.style.marginBottom = \"5px\";\r\n                info.style.color = \"green\";\r\n                info.style.fontWeight = \"500\";\r\n                info.style.whiteSpace = \"normal\";\r\n                info.style.overflow = \"auto\";\r\n                info.style.width = \"100%\";\r\n                info.style.boxSizing = \"border-box\";\r\n                info.style.position = \"relative\";\r\n                info.style.zIndex = \"10\";\r\n                info.style.padding = \"8px\";\r\n                info.style.border = \"1px solid #e0e0e0\";\r\n                info.style.borderRadius = \"4px\";\r\n                info.style.backgroundColor = \"#f0f8f0\";\r\n                info.style.fontSize = \"14px\";\r\n                info.style.lineHeight = \"1.5\";\r\n                info.style.wordWrap = \"break-word\";\r\n                // Ustawiamy treść odpowiedzi z wykorzystaniem tłumaczenia nagłówka\r\n                info.innerText = `${getCorrectAnswerText()} ${correctAnswerObj}`;\r\n                // Wstawiamy element informacyjny po kontenerze inputa\r\n                container.insertAdjacentElement(\"afterend\", info);\r\n            }\r\n        } else if (mode === \"immediate\") {\r\n            // Dla obu rodzajów elementów ustawiamy wartość i wywołujemy eventy\r\n            inputElement.value = String(correctAnswerObj);\r\n            inputElement.dispatchEvent(new Event('input', { bubbles: true }));\r\n            inputElement.dispatchEvent(new Event('change', { bubbles: true }));\r\n            inputElement.focus();\r\n            inputElement.blur();\r\n        } else if (mode === \"savemode\") {\r\n            // Używamy selektora opartego na data-automation-id, aby znaleźć element input lub textarea\r\n            const inputEl = questionElement.querySelector('[data-automation-id=\"textInput\"]');\r\n            if (!inputEl) return;\r\n\r\n            if (!inputEl.classList.contains('savemode-input')) {\r\n                inputEl.classList.add('savemode-input');\r\n            }\r\n\r\n            // Zapisujemy oryginalny placeholder, aby móc go później przywrócić\r\n            const originalPlaceholder = inputEl.getAttribute('placeholder') || '';\r\n            inputEl.dataset.originalPlaceholder = originalPlaceholder;\r\n\r\n            // Pobieramy domyślny element placeholder generowany przez stronę (np. Google)\r\n            const googlePlaceholder = questionElement.querySelector('div[jsname=\"LwH6nd\"]');\r\n\r\n            // Dodajemy event listenery dla trybu savemode\r\n            inputEl.addEventListener('focus', function () {\r\n                if (this.value === '') {\r\n                    this.placeholder = String(correctAnswerObj);\r\n                }\r\n                // Ukrywamy dodatkowy element z placeholderem, jeśli istnieje\r\n                if (googlePlaceholder) {\r\n                    googlePlaceholder.style.display = \"none\";\r\n                }\r\n            });\r\n\r\n            inputEl.addEventListener('blur', function () {\r\n                // Przywracamy oryginalny placeholder zapisany w dataset\r\n                this.placeholder = this.dataset.originalPlaceholder;\r\n                // Przywracamy domyślną widoczność dodatkowego placeholdera\r\n                if (googlePlaceholder) {\r\n                    googlePlaceholder.style.display = \"\";\r\n                }\r\n            });\r\n\r\n            inputEl.addEventListener('input', function () {\r\n                if (this.value !== '') {\r\n                    this.placeholder = '';\r\n                } else if (document.activeElement === this) {\r\n                    this.placeholder = String(correctAnswerObj);\r\n                }\r\n            });\r\n\r\n            // Dodajemy reguły CSS dla pseudo-elementu ::placeholder tylko raz\r\n            if (!document.getElementById('savemode-placeholder-style')) {\r\n                const style = document.createElement('style');\r\n                style.id = 'savemode-placeholder-style';\r\n                style.textContent = `\r\n                    /* Gdy input ma fokus, placeholder w kolorze jasno szarym */\r\n                    .savemode-input:focus::placeholder {\r\n                        color: #ccc !important;\r\n                    }\r\n                    /* Gdy input nie ma fokusu, placeholder w kolorze czarnym */\r\n                    .savemode-input:not(:focus)::placeholder {\r\n                        color: #000 !important;\r\n                    }\r\n                `;\r\n                document.head.appendChild(style);\r\n            }\r\n        }\r\n\r\n    }\r\n    else if (qType === \"ranking\") {\r\n        // Zakładamy, że backend zwraca correctAnswerObj jako tablicę liczb, np. [1, 3, 2, 4]\r\n        if (typeof correctAnswerObj === \"string\") {\r\n            try {\r\n                correctAnswerObj = JSON.parse(correctAnswerObj);\r\n            } catch (e) {\r\n                // console.error(\"Nie udało się sparsować correctAnswerObj:\", e);\r\n            }\r\n        }\r\n        if (mode === \"default\") {\r\n            // Default mode: pod kontenerem rankingowym wyświetlamy czytelny komunikat\r\n            const rankingContainer = questionElement.querySelector('.lrp-ranking-container');\r\n            if (!rankingContainer) {\r\n                // console.warn(\"Nie znaleziono kontenera rankingowego.\");\r\n                return;\r\n            }\r\n            // Funkcja sprawdzająca kolejność rankingowych elementów\r\n            function checkRankingOrder() {\r\n                const rankItems = Array.from(rankingContainer.querySelectorAll('.rank-item'));\r\n                // Upewniamy się, że każdy rank-item ma ustawiony atrybut data-original-id (raz, przy pierwszym uruchomieniu)\r\n                rankItems.forEach((item, index) => {\r\n                    if (!item.getAttribute('data-original-id')) {\r\n                        item.setAttribute('data-original-id', index + 1);\r\n                    }\r\n                });\r\n                // Obliczamy aktualną kolejność – jako tablicę liczb pobranych z atrybutu data-original-id\r\n                const currentOrder = rankItems.map(item => parseInt(item.getAttribute('data-original-id')));\r\n                // Dla każdego elementu porównujemy, czy jego wartość w currentOrder odpowiada wartości z correctAnswerObj\r\n                rankItems.forEach((item, idx) => {\r\n                    if (currentOrder[idx] !== correctAnswerObj[idx]) {\r\n                        // Jeśli element jest w niewłaściwej kolejności – czerwone obramowanie\r\n                        item.style.border = \"2px solid red\";\r\n                    } else {\r\n                        // Jeśli element jest poprawnie ustawiony – zielone obramowanie\r\n                        item.style.border = \"2px solid green\";\r\n                    }\r\n                });\r\n            }\r\n            // Wywołujemy sprawdzenie kolejności od razu\r\n            checkRankingOrder();\r\n            // Ustawiamy MutationObserver, aby przy każdej zmianie (np. przesuwaniu elementów przez użytkownika)\r\n            // wywołać funkcję sprawdzającą kolejność i aktualizować obramowania\r\n            const observer = new MutationObserver(() => {\r\n                checkRankingOrder();\r\n            });\r\n            observer.observe(rankingContainer, { childList: true, subtree: true });\r\n            // console.log(\"Tryb default aktywny – elementy są podświetlane: błędne na czerwono, poprawne na zielono.\");\r\n        }\r\n\r\n        if (mode === \"immediate\") {\r\n            // TRYB IMMEDIATE – automatyczne ustawienie kolejności rankingowych elementów\r\n            const rankingContainer = questionElement.querySelector('.lrp-ranking-container');\r\n            if (!rankingContainer) {\r\n                // console.warn(\"Nie znaleziono kontenera rankingowego.\");\r\n                return;\r\n            }\r\n            // Pobieramy wszystkie rank-itemy i ustawiamy atrybut data-original-id, jeśli jeszcze nie jest ustawiony\r\n            const rankItems = Array.from(rankingContainer.querySelectorAll('.rank-item'));\r\n            rankItems.forEach((item, index) => {\r\n                if (!item.getAttribute('data-original-id')) {\r\n                    item.setAttribute('data-original-id', index + 1);\r\n                }\r\n            });\r\n            // Zakładamy, że correctAnswerObj to tablica liczb, np. [1, 3, 2, 4]\r\n            // Konwertujemy liczby na stringi, aby porównania atrybutów działały poprawnie\r\n            const correctOrder = correctAnswerObj.map(String);\r\n            // Tworzymy nową kolejność: dla każdej pozycji z correctOrder szukamy rank-itemu,\r\n            // którego data-original-id odpowiada tej wartości\r\n            const newOrder = correctOrder.map(id =>\r\n                rankItems.find(item => item.getAttribute('data-original-id') === id)\r\n            );\r\n            if (newOrder.includes(undefined)) {\r\n                // console.warn(\"Nie udało się przestawić rankingowych elementów – sprawdź strukturę DOM.\");\r\n                return;\r\n            }\r\n            // Czyścimy kontener i wstawiamy elementy w nowej kolejności\r\n            rankingContainer.innerHTML = '';\r\n            newOrder.forEach(item => rankingContainer.appendChild(item));\r\n            // console.log(\"Kolejność została ustawiona automatycznie:\", newOrder.map(item => item.getAttribute('data-original-id')));\r\n        }\r\n        else if (mode === \"savemode\") {\r\n            // TRYB SAVEMODE – podświetlanie elementów, które są w złej kolejności\r\n            const rankingContainer = questionElement.querySelector('.lrp-ranking-container');\r\n            if (!rankingContainer) {\r\n                // console.warn(\"Nie znaleziono kontenera rankingowego.\");\r\n                return;\r\n            }\r\n            // Funkcja sprawdzająca kolejność rankingowych elementów\r\n            function checkRankingOrder() {\r\n                const rankItems = Array.from(rankingContainer.querySelectorAll('.rank-item'));\r\n                // Upewnij się, że każdy rank-item ma ustawiony atrybut data-original-id (raz, przy pierwszym uruchomieniu)\r\n                rankItems.forEach((item, index) => {\r\n                    if (!item.getAttribute('data-original-id')) {\r\n                        item.setAttribute('data-original-id', index + 1);\r\n                    }\r\n                });\r\n                // Obliczamy aktualną kolejność – jako tablicę liczb pobranych z atrybutu data-original-id\r\n                const currentOrder = rankItems.map(item => parseInt(item.getAttribute('data-original-id')));\r\n                // Dla każdego elementu porównujemy, czy jego wartość w currentOrder odpowiada wartości z correctAnswerObj\r\n                rankItems.forEach((item, idx) => {\r\n                    if (currentOrder[idx] !== correctAnswerObj[idx]) {\r\n                        // Podświetlamy element, który jest w niewłaściwym miejscu\r\n                        item.style.border = \"1px solid #ebebeb\";\r\n                    } else {\r\n                        // Jeśli element jest już poprawnie ustawiony – usuwamy podświetlenie\r\n                        item.style.border = \"\";\r\n                    }\r\n                });\r\n            }\r\n            // Wywołujemy sprawdzenie kolejności od razu\r\n            checkRankingOrder();\r\n            // Ustawiamy MutationObserver, aby przy każdej zmianie (np. przesuwaniu elementów przez użytkownika)\r\n            // wywołać funkcję sprawdzającą kolejność i odpowiednio aktualizować podświetlenia.\r\n            const observer = new MutationObserver(() => {\r\n                checkRankingOrder();\r\n            });\r\n            observer.observe(rankingContainer, { childList: true, subtree: true });\r\n            // console.log(\"Tryb savemode aktywny – niewłaściwie ustawione elementy będą podświetlone.\");\r\n        }\r\n\r\n    }\r\n    else if (qType === \"date\") {\r\n        // Szukamy kontenera daty\r\n        const dateContainer = questionElement.querySelector('[data-automation-id=\"dateContainer\"]');\r\n        if (!dateContainer) {\r\n            // console.warn(\"Nie znaleziono kontenera daty dla pytania:\", unifiedQuestion.id);\r\n            return;\r\n        }\r\n        // Pobieramy pole input typu text w kontenerze daty\r\n        const inputElement = dateContainer.querySelector('input[type=\"text\"]');\r\n        if (!inputElement) {\r\n            // console.warn(\"Nie znaleziono pola daty dla pytania:\", unifiedQuestion.id);\r\n            return;\r\n        }\r\n\r\n        if (mode === \"default\") {\r\n            // Wstawiamy komunikat z poprawną datą pod kontenerem daty\r\n            let info = dateContainer.parentElement.querySelector('.correct-answer-date-info');\r\n            if (!info) {\r\n                info = document.createElement(\"div\");\r\n                info.classList.add(\"correct-answer-date-info\");\r\n                info.style.display = \"block\";\r\n                info.style.marginTop = \"5px\";\r\n                info.style.color = \"green\";\r\n                info.style.fontWeight = \"700\";\r\n                dateContainer.parentElement.insertAdjacentElement(\"afterend\", info);\r\n            }\r\n            info.innerText = `Poprawna data: ${correctAnswerObj}`;\r\n        } else if (mode === \"immediate\") {\r\n            // Automatycznie wpisujemy poprawną datę do pola\r\n            inputElement.value = String(correctAnswerObj);\r\n            inputElement.dispatchEvent(new Event('input', { bubbles: true }));\r\n            inputElement.dispatchEvent(new Event('change', { bubbles: true }));\r\n            inputElement.focus();\r\n            inputElement.blur();\r\n        } else if (mode === \"savemode\") {\r\n            // Dodajemy event listenery, aby przy focusie ustawić placeholder na poprawną datę,\r\n            // a przy blur przywrócić domyślny placeholder.\r\n            inputElement.addEventListener('focus', function () {\r\n                inputElement.placeholder = String(correctAnswerObj);\r\n            });\r\n            inputElement.addEventListener('blur', function () {\r\n                inputElement.placeholder = unified.placeholder;  // domyślny placeholder z obiektu unified\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n\r\n    else if (qType === \"likert\") {\r\n\r\n        // Obsługa przypadku, gdy correctAnswerObj.value to string\r\n        if (typeof correctAnswerObj.value === \"string\") {\r\n            const numericStr = correctAnswerObj.value;\r\n            const numericValues = numericStr.split(\",\").filter(v => v !== \"\");\r\n            let mapping = {};\r\n            if (unifiedQuestion.commonOptions && unifiedQuestion.commonOptions.length > 0) {\r\n                unifiedQuestion.commonOptions.forEach((opt, idx) => {\r\n                    mapping[idx + 1] = opt.id.toUpperCase();\r\n                });\r\n            }\r\n            // Szukamy desktopowych wierszy, a jeśli ich nie ma – mobilnych subquestion\r\n            let statementRows = questionElement.querySelectorAll('[data-automation-id=\"likerTableTr\"]');\r\n            if (statementRows.length === 0) {\r\n                statementRows = questionElement.querySelectorAll('[data-automation-id=\"likerSubQuestion\"]');\r\n            }\r\n            // Ustalamy, czy mamy do czynienia z mobilną wersją\r\n            const isMobile = statementRows.length > 0 &&\r\n                statementRows[0].getAttribute('data-automation-id') === 'likerSubQuestion';\r\n            statementRows.forEach((row, idx) => {\r\n                const desiredLetter = mapping[numericValues[idx]];\r\n                if (!desiredLetter) return;\r\n                const inputSelector = `input[data-choice-id=\"${numericValues[idx]}\"]`;\r\n                const inputEl = row.querySelector(inputSelector);\r\n                if (inputEl) {\r\n                    if (mode === \"immediate\") {\r\n                        // Dla mobilnej wersji klikamy w label, co lepiej symuluje dotyk\r\n                        if (isMobile) {\r\n                            const labelEl = inputEl.closest('label');\r\n                            if (labelEl) {\r\n                                labelEl.click();\r\n                            }\r\n                        } else {\r\n                            inputEl.click();\r\n                        }\r\n                    }\r\n                    // Aktualizacja stylów – najpierw próbujemy znaleźć element graficzny (SVG)\r\n                    const svgPath = inputEl.parentElement.querySelector(\"svg path\");\r\n                    if (svgPath) {\r\n                        if (mode === \"savemode\") {\r\n                            svgPath.style.stroke = \"#ccc\";\r\n                            svgPath.style.strokeWidth = \"2\";\r\n                        } else if (mode === \"default\") {\r\n                            svgPath.style.stroke = \"green\";\r\n                            svgPath.style.strokeWidth = \"2\";\r\n                        }\r\n                    } else {\r\n                        // Jeśli nie znaleziono SVG, zmieniamy styl tekstu\r\n                        const answerTextEl = row.querySelector('.text-format-content');\r\n                        if (answerTextEl) {\r\n                            if (mode === \"savemode\") {\r\n                                answerTextEl.style.color = \"gray\";\r\n                            } else {\r\n                                answerTextEl.style.color = \"green\";\r\n                                answerTextEl.style.fontWeight = \"700\";\r\n                            }\r\n                        }\r\n                    }\r\n                    // Dla mobilnej wersji – zmieniamy styl właściwego kontenera odpowiedzi,\r\n                    // szukając od inputa najbliższego elementu z data-automation-id=\"likerOption\"\r\n                    if (isMobile) {\r\n                        const mobileTarget = inputEl.closest('[data-automation-id=\"likerOption\"]');\r\n                        if (mobileTarget) {\r\n                            if (mode === \"savemode\") {\r\n                                mobileTarget.style.border = \"2px solid lightgray\";\r\n                            } else if (mode === \"default\") {\r\n                                mobileTarget.style.border = \"2px solid green\";\r\n                                mobileTarget.style.fontWeight = \"700\";\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        // Obsługa przypadku, gdy correctAnswerObj.value to obiekt (np. { s1: 'P', s2: 'F', ... })\r\n        else if (typeof correctAnswerObj.value === \"object\" && correctAnswerObj.value !== null) {\r\n            let inverseMapping = {};\r\n            if (unifiedQuestion.commonOptions && unifiedQuestion.commonOptions.length > 0) {\r\n                unifiedQuestion.commonOptions.forEach((opt, idx) => {\r\n                    inverseMapping[opt.id.toUpperCase()] = idx + 1;\r\n                });\r\n            }\r\n            let numericAnswers = [];\r\n            if (unifiedQuestion.statements && unifiedQuestion.statements.length > 0) {\r\n                unifiedQuestion.statements.forEach((stmt) => {\r\n                    let letter = correctAnswerObj.value[stmt.id];\r\n                    if (letter) {\r\n                        let numeric = inverseMapping[letter.toUpperCase()];\r\n                        numericAnswers.push(numeric !== undefined ? numeric : letter);\r\n                    } else {\r\n                        numericAnswers.push(\"\");\r\n                    }\r\n                });\r\n            }\r\n            const numericAnswerString = numericAnswers.join(\",\") + \",\";\r\n            correctAnswerObj = { value: numericAnswerString, answerRepresentation: \"numeric\" };\r\n\r\n            const numericStr = correctAnswerObj.value;\r\n            const numericValues = numericStr.split(\",\").filter(v => v !== \"\");\r\n            let mapping = {};\r\n            if (unifiedQuestion.commonOptions && unifiedQuestion.commonOptions.length > 0) {\r\n                unifiedQuestion.commonOptions.forEach((opt, idx) => {\r\n                    mapping[idx + 1] = opt.id.toUpperCase();\r\n                });\r\n            }\r\n            let statementRows = questionElement.querySelectorAll('[data-automation-id=\"likerTableTr\"]');\r\n            if (statementRows.length === 0) {\r\n                statementRows = questionElement.querySelectorAll('[data-automation-id=\"likerSubQuestion\"]');\r\n            }\r\n            const isMobile = statementRows.length > 0 &&\r\n                statementRows[0].getAttribute('data-automation-id') === 'likerSubQuestion';\r\n            statementRows.forEach((row, idx) => {\r\n                const desiredLetter = mapping[numericValues[idx]];\r\n                if (!desiredLetter) return;\r\n                const inputSelector = `input[data-choice-id=\"${numericValues[idx]}\"]`;\r\n                const inputEl = row.querySelector(inputSelector);\r\n                if (inputEl) {\r\n                    if (mode === \"immediate\") {\r\n                        if (isMobile) {\r\n                            const labelEl = inputEl.closest('label');\r\n                            if (labelEl) {\r\n                                labelEl.click();\r\n                            }\r\n                        } else {\r\n                            inputEl.click();\r\n                        }\r\n                    }\r\n                    const svgPath = inputEl.parentElement.querySelector(\"svg path\");\r\n                    if (svgPath) {\r\n                        if (mode === \"savemode\") {\r\n                            svgPath.style.stroke = \"#ccc\";\r\n                            svgPath.style.strokeWidth = \"2\";\r\n                        } else if (mode === \"default\") {\r\n                            svgPath.style.stroke = \"green\";\r\n                            svgPath.style.strokeWidth = \"2\";\r\n                        }\r\n                    } else {\r\n                        const answerTextEl = row.querySelector('.text-format-content');\r\n                        if (answerTextEl) {\r\n                            if (mode === \"savemode\") {\r\n                                answerTextEl.style.color = \"gray\";\r\n                            } else if (mode === \"default\") {\r\n                                answerTextEl.style.color = \"green\";\r\n                                answerTextEl.style.fontWeight = \"700\";\r\n                            }\r\n                        }\r\n                    }\r\n                    // Dla mobilnej wersji – wyszukujemy kontener odpowiedzi od inputa\r\n                    if (isMobile) {\r\n                        const mobileTarget = inputEl.closest('[data-automation-id=\"likerOption\"]');\r\n                        if (mobileTarget) {\r\n                            if (mode === \"savemode\") {\r\n                                mobileTarget.style.border = \"2px solid lightgray\";\r\n                            } else if (mode === \"default\") {\r\n                                mobileTarget.style.border = \"2px solid green\";\r\n                                mobileTarget.style.fontWeight = \"700\";\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            // console.warn(\"Niepoprawny format odpowiedzi dla likert.\");\r\n            return;\r\n        }\r\n    }\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n/*************************************************\r\n * 8. PRZETWARZANIE POJEDYNCZEGO PYTANIA\r\n *************************************************/\r\nasync function handleQuestionMicrosoftForms(questionElement, mode) {\r\n    // === POCZĄTEK SUGEROWANEJ ZMIANY (BLOKADA DUPLIKATÓW) ===\r\n    if (questionElement.dataset.alreadyHandled === 'true') {\r\n        return null;\r\n    }\r\n    questionElement.dataset.alreadyHandled = 'true';\r\n    // === KONIEC SUGEROWANEJ ZMIANY ===\r\n\r\n    const unifiedQuestion = await buildUnifiedQuestion(questionElement);\r\n    if (!unifiedQuestion) {\r\n        // Jeśli pytanie jest nieprawidłowe, pozostawiamy flagę, aby nie próbować ponownie.\r\n        return null;\r\n    }\r\n\r\n    if (![\"singlechoice\", \"multiple\", \"shortanswer\", \"likert\", \"ranking\", \"date\"].includes(unifiedQuestion.type)) {\r\n        return unifiedQuestion; // Zwróć dane, nawet jeśli nie wysyłamy do API\r\n    }\r\n\r\n    // === POCZĄTEK SUGEROWANEJ ZMIANY (POPRAWNA OBSŁUGA ASYNC) ===\r\n    try {\r\n        const response = await sendQuestionToChatGPTMicrosoftForms(unifiedQuestion);\r\n\r\n        if (response && response.correctAnswer) {\r\n            const correctAnswer = response.correctAnswer;\r\n            markCorrectAnswerUnified(questionElement, correctAnswer, unifiedQuestion, mode);\r\n        } else {\r\n            console.error(\"Brak pola 'correctAnswer' w odpowiedzi z backendu:\", response);\r\n        }\r\n    } catch (error) {\r\n        console.error(\"Błąd podczas wysyłania pytania do ChatGPT:\", error);\r\n        // W przypadku błędu usuń flagę, aby umożliwić ponowną próbę\r\n        delete questionElement.dataset.alreadyHandled;\r\n    }\r\n    // === KONIEC SUGEROWANEJ ZMIANY ===\r\n\r\n    return unifiedQuestion;\r\n}\r\n\r\n/*************************************************\r\n * 9. PRZETWARZANIE WSZYSTKICH PYTANIA\r\n *************************************************/\r\nexport async function processMicrosoftForms() {\r\n    function shouldProcessMicrosoftForms() {\r\n        const infoElement = document.querySelector(\r\n            '[aria-label*=\"Informacje o uczniu\"], [aria-label*=\"Student Information\"]'\r\n        );\r\n        return !infoElement;\r\n    }\r\n\r\n    if (!shouldProcessMicrosoftForms()) {\r\n        return;\r\n    }\r\n\r\n    const { markingMode } = await new Promise((resolve) => {\r\n        chrome.storage.local.get(['markingMode'], (result) => {\r\n            resolve({ markingMode: result.markingMode || 'default' });\r\n        });\r\n    });\r\n\r\n    const questions = document.querySelectorAll('[data-automation-id=\"questionItem\"]');\r\n    if (questions.length === 0) {\r\n        // console.log(\"Nie znaleziono pytań na stronie Microsoft Forms.\");\r\n        return;\r\n    }\r\n\r\n    // === POCZĄTEK SUGEROWANEJ ZMIANY (PRZETWARZANIE RÓWNOLEGŁE) ===\r\n\r\n    // Utwórz tablicę obietnic, bez sztucznych opóźnień.\r\n    const processingPromises = Array.from(questions).map(questionElement =>\r\n        handleQuestionMicrosoftForms(questionElement, markingMode)\r\n    );\r\n\r\n    // Poczekaj na zakończenie wszystkich operacji jednocześnie.\r\n    const results = await Promise.all(processingPromises);\r\n    const successfulResults = results.filter(r => r !== null);\r\n\r\n    // console.log(`Przetworzono ${successfulResults.length} z ${questions.length} pytań.`);\r\n\r\n}","let quizizzAnswersCache = null;\r\nlet quizizzInterval = null;\r\nlet mode = 'default';\r\nlet lastQuestionText = null;\r\nlet waitingForQuizElement = false;\r\nlet quizPollingInterval = null;\r\n\r\nexport function initQuizizzHandler() {\r\n    quizizzAnswersCache = null;\r\n    lastQuestionText = null;\r\n    stopCheckingCurrentQuestion();\r\n\r\n    if (window.location.href.includes(\"quizizz.com/join/game/\")) {\r\n        startWaitingForQuizElements();\r\n    }\r\n}\r\n\r\nfunction startWaitingForQuizElements() {\r\n    if (waitingForQuizElement || quizPollingInterval) {\r\n        return;\r\n    }\r\n    waitingForQuizElement = true;\r\n    checkAndHandleQuizElements();\r\n    quizPollingInterval = setInterval(checkAndHandleQuizElements, 1000);\r\n}\r\n\r\nfunction checkAndHandleQuizElements() {\r\n    const questionContainer = document.querySelector('[data-testid=\"question-container\"]');\r\n    const questionTextEl = document.querySelector('#questionText');\r\n    if (questionContainer && questionTextEl) {\r\n        waitingForQuizElement = false;\r\n        clearInterval(quizPollingInterval);\r\n        quizPollingInterval = null;\r\n        handleQuizizzAnswers();\r\n        setupQuizizzNavObserver();\r\n    }\r\n}\r\n\r\nfunction extractCurrentQuizizzQuestion() {\r\n    const domQuestion = document.querySelector('[data-testid=\"question-container\"]');\r\n    if (!domQuestion) {\r\n        console.warn(\"Nie znaleziono kontenera pytania\");\r\n        return null;\r\n    }\r\n\r\n    const questionParagraph = domQuestion.querySelector('#questionText');\r\n    if (!questionParagraph) {\r\n        console.warn(\"Nie znaleziono elementu tekstu pytania\");\r\n        return null;\r\n    }\r\n\r\n    let rawQuestion = questionParagraph.textContent.replace(/\\n/g, ' ').replace(/\\s+/g, ' ').trim();\r\n    let questionText = fixMathNotation(rawQuestion);\r\n\r\n    const quizContainer = domQuestion.closest('.quiz-container');\r\n    if (!quizContainer) {\r\n        console.warn(\"Nie znaleziono kontenera quizu\");\r\n        return null;\r\n    }\r\n\r\n    const optionButtons = quizContainer.querySelectorAll('.options-grid .option');\r\n    const options = [];\r\n    optionButtons.forEach((btn, index) => {\r\n        const optionTextEl = btn.querySelector('#optionText');\r\n        if (optionTextEl) {\r\n            let rawOpt = optionTextEl.textContent.replace(/\\n/g, ' ').replace(/\\s+/g, ' ').trim();\r\n            let optionText = fixMathNotation(rawOpt);\r\n            options.push({\r\n                text: optionText,\r\n                id: String(index + 1)\r\n            });\r\n        } else {\r\n            console.warn(`Opcja ${index + 1} nie ma elementu #optionText`);\r\n        }\r\n    });\r\n\r\n    const isMultipleChoice = !!(\r\n        document.querySelector('.multiple-choice-metadata-title') ||\r\n        document.querySelector('[data-test=\"multiple-choice-info\"]') ||\r\n        document.querySelector('.msq-text') ||\r\n        document.querySelector('.is-msq')\r\n    );\r\n\r\n    const questionType = isMultipleChoice ? \"MSQ\" : \"MCQ\";\r\n\r\n\r\n    const questionData = {\r\n        question: { text: questionText },\r\n        options: options,\r\n        type: questionType\r\n    };\r\n\r\n    return questionData;\r\n}\r\n\r\nexport async function handleQuizizzAnswers() {\r\n    try {\r\n        await waitForQuizizzElements();\r\n    } catch (error) {\r\n        console.warn(\"Timeout podczas oczekiwania na elementy Quizizz\", error);\r\n        return;\r\n    }\r\n\r\n    const currentQuestionData = extractCurrentQuizizzQuestion();\r\n    if (!currentQuestionData || !currentQuestionData.question?.text) {\r\n        console.warn(\"Nie można pobrać tekstu aktualnego pytania\");\r\n        return;\r\n    }\r\n\r\n    const currentQuestionText = currentQuestionData.question.text;\r\n    const currentUrl = window.location.href;\r\n\r\n    if (quizizzAnswersCache && lastQuestionText === currentQuestionText) {\r\n        chrome.storage.local.get(['markingMode', 'autoMode'], (result) => {\r\n            mode = result.markingMode || 'default';\r\n            const autoMode = !!result.autoMode;\r\n            autoMode ? startCheckingCurrentQuestion() : stopCheckingCurrentQuestion();\r\n        });\r\n        return;\r\n    }\r\n\r\n    quizizzAnswersCache = null;\r\n    lastQuestionText = currentQuestionText;\r\n\r\n    chrome.storage.local.get(['markingMode', 'userEmail', 'sessionId', 'autoMode'], (result) => {\r\n        mode = result.markingMode || 'default';\r\n        const userEmail = result.userEmail;\r\n        const sessionId = result.sessionId;\r\n        const autoMode = !!result.autoMode;\r\n        if (!sessionId || !userEmail) {\r\n            console.error(\"Brak danych uwierzytelniających\");\r\n            return;\r\n        }\r\n        if (!autoMode) {\r\n            return;\r\n        }\r\n        const quizId = extractQuizIdFromUrl(currentUrl);\r\n        const quizPin = getQuizPin();\r\n\r\n        chrome.runtime.sendMessage({\r\n            type: \"QUERY_CHATGPT_MF\",\r\n            platform: \"quizizz\",\r\n            quizId: currentUrl,\r\n            quizSimpleId: quizId,\r\n            pin: quizPin,\r\n            mode: mode,\r\n            userEmail: userEmail,\r\n            questionData: currentQuestionData\r\n        }, (response) => {\r\n            if (response && response.answer) {\r\n                quizizzAnswersCache = response.answer.correctAnswer;\r\n                if (autoMode) {\r\n                    if (typeof startCheckingCurrentQuestion === 'function') {\r\n                        startCheckingCurrentQuestion();\r\n                    } else {\r\n                        console.error(\"Funkcja startCheckingCurrentQuestion nie jest zdefiniowana!\");\r\n                    }\r\n                }\r\n            } else {\r\n                console.error(\"❌ Błąd:\", response?.error || \"Brak odpowiedzi\");\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction getQuizPin() {\r\n    // First try to get the pin from the button element\r\n    const pinButton = document.querySelector('.v-popper--theme-tooltip button.room-code');\r\n    if (pinButton) {\r\n        return pinButton.innerText.replace(/\\s+/g, '');\r\n    }\r\n\r\n    // If not found in the DOM, try to get it from localStorage\r\n    try {\r\n        const previousContext = localStorage.getItem('previousContext');\r\n        if (previousContext) {\r\n            const parsedContext = JSON.parse(previousContext);\r\n            if (parsedContext && parsedContext.game && parsedContext.game.roomCode) {\r\n                return parsedContext.game.roomCode;\r\n            }\r\n        }\r\n    } catch (error) {\r\n        console.error('Error reading from localStorage:', error);\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction extractQuizIdFromUrl(url) {\r\n    try {\r\n        const urlObj = new URL(url);\r\n        const parts = urlObj.pathname.split('/');\r\n        const gameIndex = parts.indexOf('game');\r\n        if (gameIndex !== -1 && gameIndex + 1 < parts.length) {\r\n            return parts[gameIndex + 1];\r\n        }\r\n        return url.split('?')[0];\r\n    } catch (e) {\r\n        console.error(\"Błąd przy ekstrakcji ID quizu:\", e);\r\n        return url;\r\n    }\r\n}\r\n\r\nfunction cleanupFailedQuizitCache() {\r\n    chrome.storage.local.get(['failedQuizitQuizzes'], (result) => {\r\n        if (result.failedQuizitQuizzes) {\r\n            try {\r\n                const cache = JSON.parse(result.failedQuizitQuizzes);\r\n                const now = Date.now();\r\n                const oneWeek = 7 * 24 * 60 * 60 * 1000;\r\n                let updatedCache = {};\r\n                let needsUpdate = false;\r\n                for (const [quizId, value] of Object.entries(cache)) {\r\n                    if (typeof value === 'boolean') {\r\n                        updatedCache[quizId] = { failed: true, timestamp: now };\r\n                        needsUpdate = true;\r\n                    } else if (typeof value === 'object' && value.timestamp) {\r\n                        if (now - value.timestamp < oneWeek) {\r\n                            updatedCache[quizId] = value;\r\n                        } else {\r\n                            needsUpdate = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (needsUpdate) {\r\n                    chrome.storage.local.set({ failedQuizitQuizzes: JSON.stringify(updatedCache) });\r\n                }\r\n            } catch (e) {\r\n                console.error(\"Błąd przy czyszczeniu cache:\", e);\r\n            }\r\n        }\r\n    });\r\n}\r\nsetTimeout(cleanupFailedQuizitCache, 5000);\r\nfunction waitForQuizizzElements() {\r\n    return new Promise((resolve) => {\r\n        function check() {\r\n            chrome.storage.local.get('autoMode', (result) => {\r\n                const autoMode = !!result.autoMode;\r\n                if (!autoMode) {\r\n                    resolve();\r\n                    return;\r\n                }\r\n                const questionContainer = document.querySelector('[data-testid=\"question-container\"]');\r\n                const questionTextEl = document.querySelector('#questionText');\r\n                if (questionContainer && questionTextEl) {\r\n                    resolve();\r\n                } else {\r\n                    setTimeout(check, 500);\r\n                }\r\n            });\r\n        }\r\n        if (!document.body) {\r\n            const interval = setInterval(() => {\r\n                if (document.body) {\r\n                    clearInterval(interval);\r\n                    check();\r\n                }\r\n            }, 100);\r\n        } else {\r\n            check();\r\n        }\r\n    });\r\n}\r\n\r\n\r\nfunction highlightCurrentQuizizzQuestion(answersData) {\r\n\r\n    const domQuestionData = extractCurrentQuizizzQuestion();\r\n    if (!domQuestionData || !domQuestionData.question?.text) {\r\n        console.warn(\"Nie można pobrać aktualnego pytania (DOM)\");\r\n        return;\r\n    }\r\n    const domQuestionText = domQuestionData.question.text;\r\n\r\n    const matchedQuestion = findMatchingQuestion(domQuestionText, answersData);\r\n    if (!matchedQuestion) {\r\n        console.warn(\"Nie znaleziono dopasowania dla pytania:\", domQuestionText);\r\n        return;\r\n    }\r\n    const correctAnswers = matchedQuestion.answers;\r\n\r\n    const domQuestion = document.querySelector('[data-testid=\"question-container\"]');\r\n    if (!domQuestion) {\r\n        console.warn(\"Nie znaleziono kontenera pytania\");\r\n        return;\r\n    }\r\n    const quizContainer = domQuestion.closest('.quiz-container');\r\n    if (!quizContainer) {\r\n        console.warn(\"Nie znaleziono kontenera quizu\");\r\n        return;\r\n    }\r\n    const optionButtons = quizContainer.querySelectorAll('.options-grid .option');\r\n    switch (mode) {\r\n        case 'immediate':\r\n            markCorrectAnswersImmediate(optionButtons, correctAnswers);\r\n            break;\r\n        case 'saveMode':\r\n            markCorrectAnswersSavemode(optionButtons, correctAnswers);\r\n            break;\r\n        default:\r\n            markCorrectAnswersDefault(optionButtons, correctAnswers);\r\n            break;\r\n    }\r\n}\r\n\r\n\r\nfunction debounce(func, wait) {\r\n    let timeout;\r\n    return function (...args) {\r\n        const context = this;\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(() => func.apply(context, args), wait);\r\n    };\r\n}\r\n\r\nfunction setupQuizizzNavObserver() {\r\n    const observer = new MutationObserver(debounce(() => {\r\n        if (!window.location.href.includes(\"quizizz.com/join/game/\")) return;\r\n        chrome.storage.local.get('autoMode', (result) => {\r\n            const autoMode = !!result.autoMode;\r\n            if (!autoMode) return;\r\n            const currentQuestionData = extractCurrentQuizizzQuestion();\r\n            if (!currentQuestionData || !currentQuestionData.question?.text) return;\r\n            const currentQuestionText = currentQuestionData.question.text;\r\n            if (lastQuestionText !== currentQuestionText) {\r\n                handleQuizizzAnswers();\r\n            }\r\n        });\r\n    }, 300));\r\n    observer.observe(document.body, { childList: true, subtree: true, attributes: true });\r\n    return observer;\r\n}\r\n\r\nfunction normalizeText(text) {\r\n    return stripHtml(text).toLowerCase()\r\n        .normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\")\r\n        .replace(/\\s+/g, ' ').trim();\r\n}\r\nfunction markCorrectAnswersDefault(optionButtons, correctAnswers) {\r\n    const container = document.querySelector('[data-testid=\"question-container\"]').closest('.quiz-container');\r\n    const textarea = container.querySelector('textarea.typed-option-input');\r\n    if (textarea) {\r\n        const answerText = (Array.isArray(correctAnswers) && correctAnswers.length > 0 && correctAnswers[0].text)\r\n            ? stripHtml(correctAnswers[0].text).trim()\r\n            : \"\";\r\n        let answerDiv = container.querySelector('.bg-correct-answer');\r\n        if (!answerDiv) {\r\n            answerDiv = document.createElement('div');\r\n            answerDiv.classList.add('bg-correct-answer');\r\n            answerDiv.style.color = 'green';\r\n            answerDiv.style.fontWeight = \"700\";\r\n            answerDiv.style.marginTop = '5px';\r\n            textarea.parentElement.appendChild(answerDiv);\r\n        }\r\n        answerDiv.textContent = answerText;\r\n        return;\r\n    }\r\n\r\n\r\n    if (!Array.isArray(correctAnswers)) {\r\n        console.error(\"correctAnswers nie jest tablicą:\", correctAnswers);\r\n        return;\r\n    }\r\n\r\n\r\n    correctAnswers.forEach((ans) => {\r\n        let ansTextClean = \"\";\r\n        if (typeof ans === 'object' && ans.text) {\r\n            ansTextClean = stripHtml(ans.text).trim();\r\n        } else if (typeof ans === 'string') {\r\n            ansTextClean = stripHtml(ans).trim();\r\n        } else if (typeof ans === 'number') {\r\n            ansTextClean = String(ans);\r\n        } else {\r\n            console.warn(\"Nieznany format odpowiedzi:\", ans);\r\n            return;\r\n        }\r\n\r\n        let answerNumbers = [];\r\n        if (ansTextClean.indexOf(',') > -1) {\r\n            answerNumbers = ansTextClean.split(',').map(s => s.trim());\r\n        } else {\r\n            answerNumbers.push(ansTextClean);\r\n        }\r\n\r\n        answerNumbers.forEach(answerNum => {\r\n            let matchFound = false;\r\n            optionButtons.forEach((btn, index) => {\r\n                const optionTextEl = btn.querySelector('#optionText');\r\n                if (!optionTextEl) return;\r\n                const optionText = optionTextEl.innerText.trim();\r\n\r\n                let isCorrect = optionText === answerNum;\r\n                if (!isCorrect) {\r\n                    const normalizedAns = normalizeText(answerNum);\r\n                    const normalizedOpt = normalizeText(optionText);\r\n                    isCorrect = normalizedOpt === normalizedAns;\r\n                }\r\n                if (!isCorrect && !isNaN(parseInt(answerNum))) {\r\n                    const ansIndex = parseInt(answerNum) - 1;\r\n                    isCorrect = index === ansIndex;\r\n                }\r\n                if (isCorrect) {\r\n                    matchFound = true;\r\n                    btn.style.border = '3px solid #2ecc71';\r\n                    btn.style.boxShadow = '0 0 10px rgba(46, 204, 113, 0.7)';\r\n                    btn.style.backgroundColor = 'rgba(46, 204, 113, 0.2)';\r\n                }\r\n            });\r\n            if (!matchFound) {\r\n                console.warn(`⚠️ Nie znaleziono dopasowania dla backendowej odpowiedzi: \"${answerNum}\"`);\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nlet markedAnswersCache = {};\r\nfunction markCorrectAnswersImmediate(optionButtons, correctAnswers) {\r\n    const container = document.querySelector('[data-testid=\"question-container\"]').closest('.quiz-container');\r\n    const textarea = container.querySelector('textarea.typed-option-input');\r\n    if (textarea) {\r\n        const answerText = (Array.isArray(correctAnswers) && correctAnswers.length > 0 && correctAnswers[0].text)\r\n            ? stripHtml(correctAnswers[0].text).trim()\r\n            : \"\";\r\n        textarea.value = answerText;\r\n        textarea.dispatchEvent(new Event('input', { bubbles: true }));\r\n        return;\r\n    }\r\n    const questionTextElement = document.querySelector('[data-testid=\"question-container\"] #questionText');\r\n    if (!questionTextElement) return;\r\n    const currentQuestion = questionTextElement.innerText.trim();\r\n    const questionKey = normalizeText(currentQuestion).substring(0, 50);\r\n    if (markedAnswersCache[questionKey]) {\r\n        return;\r\n    }\r\n    const buttonsToClick = [];\r\n    correctAnswers.forEach((ans) => {\r\n        let ansTextClean = \"\";\r\n        if (typeof ans === 'object' && ans.text) {\r\n            ansTextClean = stripHtml(ans.text).trim();\r\n        } else if (typeof ans === 'string') {\r\n            ansTextClean = stripHtml(ans).trim();\r\n        } else if (typeof ans === 'number') {\r\n            ansTextClean = String(ans);\r\n        } else {\r\n            console.warn(\"Nieznany format odpowiedzi:\", ans);\r\n            return;\r\n        }\r\n\r\n        let answerNumbers = [];\r\n        if (ansTextClean.indexOf(',') > -1) {\r\n            answerNumbers = ansTextClean.split(',').map(s => s.trim());\r\n        } else {\r\n            answerNumbers.push(ansTextClean);\r\n        }\r\n        answerNumbers.forEach(answerNum => {\r\n            optionButtons.forEach((btn, index) => {\r\n                const optionTextEl = btn.querySelector('#optionText');\r\n                if (!optionTextEl) return;\r\n                const optionText = optionTextEl.innerText.trim();\r\n                let isCorrect = optionText === answerNum ||\r\n                    normalizeText(optionText) === normalizeText(answerNum);\r\n                if (!isCorrect && !isNaN(parseInt(answerNum))) {\r\n                    const ansIndex = parseInt(answerNum) - 1;\r\n                    isCorrect = index === ansIndex;\r\n                }\r\n                if (isCorrect) {\r\n                    buttonsToClick.push(index);\r\n                }\r\n            });\r\n        });\r\n    });\r\n    if (buttonsToClick.length > 0) {\r\n        buttonsToClick.forEach((index, i) => {\r\n            setTimeout(() => {\r\n                try {\r\n                    const btn = optionButtons[index];\r\n                    if (btn) {\r\n                        btn.click();\r\n                    }\r\n                } catch (e) {\r\n                    console.error(`Błąd podczas klikania opcji ${index}:`, e);\r\n                }\r\n            }, i * 300);\r\n        });\r\n        markedAnswersCache[questionKey] = buttonsToClick;\r\n        const cacheKeys = Object.keys(markedAnswersCache);\r\n        if (cacheKeys.length > 20) {\r\n            delete markedAnswersCache[cacheKeys[0]];\r\n        }\r\n    }\r\n}\r\nfunction markCorrectAnswersSavemode(optionButtons, correctAnswers) {\r\n    // Check if we're on mobile layout by examining the DOM structure\r\n    const optionsGrid = document.querySelector('.options-grid');\r\n    const isMobileLayout = optionsGrid && optionsGrid.classList.contains('flex-col');\r\n\r\n    // Handle text input questions\r\n    const container = document.querySelector('[data-testid=\"question-container\"]')?.closest('.quiz-container');\r\n    if (!container) {\r\n        console.warn(\"Nie znaleziono kontenera quizu\");\r\n        return;\r\n    }\r\n\r\n    const textarea = container.querySelector('textarea.typed-option-input');\r\n    if (textarea) {\r\n        const answerText = (Array.isArray(correctAnswers) && correctAnswers.length > 0 && correctAnswers[0].text)\r\n            ? stripHtml(correctAnswers[0].text).trim()\r\n            : \"\";\r\n        textarea.addEventListener('focus', function () {\r\n            textarea.setAttribute('placeholder', answerText);\r\n        });\r\n        textarea.addEventListener('blur', function () {\r\n            textarea.setAttribute('placeholder', '');\r\n        });\r\n        return;\r\n    }\r\n\r\n    // Process each correct answer\r\n    correctAnswers.forEach((ans) => {\r\n        let ansTextClean = \"\";\r\n        if (typeof ans === 'object' && ans.text) {\r\n            ansTextClean = stripHtml(ans.text).trim();\r\n        } else if (typeof ans === 'string') {\r\n            ansTextClean = stripHtml(ans).trim();\r\n        } else if (typeof ans === 'number') {\r\n            ansTextClean = String(ans);\r\n        } else {\r\n            console.warn(\"Nieznany format odpowiedzi:\", ans);\r\n            return;\r\n        }\r\n\r\n        // Process each option button to find matches\r\n        optionButtons.forEach((btn, index) => {\r\n            // Find the option text element regardless of the layout\r\n            const optionTextEl = btn.querySelector('#optionText');\r\n\r\n            if (!optionTextEl) return;\r\n\r\n            // Get the text content from the element\r\n            const optionText = optionTextEl.innerText.trim();\r\n\r\n            let isCorrect = optionText === ansTextClean ||\r\n                normalizeText(optionText) === normalizeText(ansTextClean);\r\n\r\n            // Try index-based matching if text matching fails\r\n            if (!isCorrect && !isNaN(parseInt(ansTextClean))) {\r\n                const ansIndex = parseInt(ansTextClean) - 1;\r\n                isCorrect = index === ansIndex;\r\n            }\r\n\r\n            // Apply different highlighting based on layout\r\n            if (isCorrect) {\r\n                if (isMobileLayout) {\r\n                    // Mobile layout (vertical options)\r\n                    btn.style.boxShadow = '0 0 5px 3px rgba(255, 255, 255, 0.2)';\r\n                    // Add a subtle background color for better visibility on mobile\r\n                    btn.style.backgroundColor = 'rgba(255, 255, 255, 0.05)';\r\n                } else {\r\n                    // Desktop layout\r\n                    btn.style.boxShadow = '0 0 5px 3px rgba(255, 255, 255, 0.2)';\r\n                }\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n\r\nfunction startCheckingCurrentQuestion() {\r\n    stopCheckingCurrentQuestion();\r\n    markedAnswersCache = {};\r\n    quizizzInterval = setInterval(() => {\r\n        chrome.storage.local.get('autoMode', async (result) => {\r\n            const autoMode = !!result.autoMode;\r\n            if (!autoMode) {\r\n                stopCheckingCurrentQuestion();\r\n                return;\r\n            }\r\n            try {\r\n                const currentQuestionData = extractCurrentQuizizzQuestion();\r\n                if (!currentQuestionData || !currentQuestionData.question?.text) {\r\n                    console.warn(\"Nie można pobrać tekstu aktualnego pytania\");\r\n                    return;\r\n                }\r\n                const currentQuestionText = currentQuestionData.question.text;\r\n                if (lastQuestionText !== currentQuestionText) {\r\n                    await handleQuizizzAnswers();\r\n                    return;\r\n                }\r\n                if (quizizzAnswersCache) {\r\n                    highlightCurrentQuizizzQuestion(quizizzAnswersCache);\r\n                }\r\n            } catch (e) {\r\n                console.error(\"Błąd podczas sprawdzania pytania:\", e);\r\n            }\r\n        });\r\n    }, 1000);\r\n}\r\n\r\nfunction stopCheckingCurrentQuestion() {\r\n    if (quizizzInterval) {\r\n        clearInterval(quizizzInterval);\r\n        quizizzInterval = null;\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction stripHtml(htmlString) {\r\n    return htmlString.replace(/<[^>]*>/g, '');\r\n}\r\n\r\nfunction findMatchingQuestion(domQuestionText, questionsArray) {\r\n\r\n    const normalizedDom = domQuestionText.replace(/\\s+/g, '');\r\n\r\n    for (const q of questionsArray) {\r\n        if (!q.question || !q.question.text) {\r\n            console.warn(\"Nieprawidłowa struktura pytania:\", q);\r\n            continue;\r\n        }\r\n        const questionTextClean = stripHtml(q.question.text).trim();\r\n        const normalizedBackend = questionTextClean.replace(/\\s+/g, '');\r\n\r\n\r\n        if (normalizedDom === normalizedBackend) {\r\n            return q;\r\n        }\r\n\r\n        const normDom = normalizeText(domQuestionText);\r\n        const normBackend = normalizeText(questionTextClean);\r\n\r\n        if (normDom.includes(normBackend) || normBackend.includes(normDom)) {\r\n            return q;\r\n        }\r\n    }\r\n\r\n    if (questionsArray.length === 1) {\r\n        return questionsArray[0];\r\n    }\r\n\r\n    console.warn(\"Nie znaleziono dopasowania\");\r\n    return null;\r\n}\r\nfunction fixMathNotation(text) {\r\n    text = text.replace(/[\\u{1D434}-\\u{1D44D}]/gu, match =>\r\n        String.fromCharCode(match.codePointAt(0) - 0x1D434 + 0x41));\r\n    text = text.replace(/[\\u{1D44E}-\\u{1D467}]/gu, match =>\r\n        String.fromCharCode(match.codePointAt(0) - 0x1D44E + 0x61));\r\n    return text;\r\n}\r\n","import { sendQuestionToChatGPTGoogleForms } from '../core/api.js';\r\n// Also listen for URL changes to handle SPA navigation\r\nlet lastUrl = location.href;\r\n\r\n/*************************************************\r\n * HELPER FUNCTIONS\r\n *************************************************/\r\n\r\n// Function to wait for an image to load\r\nasync function waitForImageLoad(img, timeout = 5000) {\r\n    return new Promise(resolve => {\r\n        if (img.complete && img.naturalWidth !== 0) {\r\n            return resolve();\r\n        }\r\n        const timer = setTimeout(resolve, timeout);\r\n        img.addEventListener(\"load\", () => {\r\n            clearTimeout(timer);\r\n            resolve();\r\n        });\r\n        img.addEventListener(\"error\", () => {\r\n            clearTimeout(timer);\r\n            resolve();\r\n        });\r\n    });\r\n}\r\n\r\n// Extract images from an element\r\nasync function extractImages(element) {\r\n    const imageElements = element.querySelectorAll('img');\r\n    const images = [];\r\n    for (const img of imageElements) {\r\n        await waitForImageLoad(img);\r\n        images.push({\r\n            url: img.src,\r\n            alt: img.alt || \"\"\r\n        });\r\n    }\r\n    return images;\r\n}\r\n\r\n// Extract mathematical content if present\r\nfunction extractMathContent(element, timeout = 300) {\r\n    const pollInterval = 10;\r\n    const startTime = Date.now();\r\n    return new Promise((resolve) => {\r\n        function poll() {\r\n            // Look for math elements in Google Forms\r\n            const mathElements = element.querySelectorAll('.mathml, .katex, [data-math]');\r\n            if (mathElements.length > 0 || (Date.now() - startTime) >= timeout) {\r\n                let mathContent = \"\";\r\n                mathElements.forEach(mathEl => {\r\n                    if (mathEl.hasAttribute('data-math')) {\r\n                        mathContent += \" \" + mathEl.getAttribute('data-math').trim();\r\n                    } else if (mathEl.innerText && mathEl.innerText.trim().length > 0) {\r\n                        mathContent += \" \" + mathEl.innerText.trim();\r\n                    }\r\n                });\r\n\r\n                // Look for LaTeX in HTML\r\n                const rawHTML = element.innerHTML;\r\n                const latexRegex = /\\$(.*?)\\$/g;\r\n                let match;\r\n                while ((match = latexRegex.exec(rawHTML)) !== null) {\r\n                    if (match[1] && match[1].trim().length > 0) {\r\n                        mathContent += \" \" + match[1].trim();\r\n                    }\r\n                }\r\n                resolve(mathContent.trim());\r\n            } else {\r\n                setTimeout(poll, pollInterval);\r\n            }\r\n        }\r\n        poll();\r\n    });\r\n}\r\n\r\n/*************************************************\r\n * 1. QUESTION TYPE DETECTION\r\n *************************************************/\r\nfunction detectQuestionTypeGoogleForms(questionElement) {\r\n    //console.log(\"Wykrywanie typu pytania...\");\r\n\r\n    // Check if this is a name/email input that should be skipped\r\n    // Look for common patterns in name/email fields across different languages\r\n    const questionText = questionElement.querySelector('.M7eMe')?.innerText?.toLowerCase() || '';\r\n    if (questionText.includes('email') ||\r\n        questionText.includes('e-mail') ||\r\n        questionText.includes('imię') ||\r\n        questionText.includes('imie') ||\r\n        questionText.includes('nazwisko') ||\r\n        questionText.includes('name') ||\r\n        questionText.match(/^\\s*name\\s*$/i)) {\r\n        //console.log(\"Wykryto pole osobowe (email/imię/nazwisko) - pomijamy\");\r\n        return \"personal\";\r\n    }\r\n\r\n    // Check for grid/matrix questions with radio buttons\r\n    if (questionElement.querySelector('.lLfZXe[role=\"radiogroup\"]') &&\r\n        questionElement.querySelector('.V4d7Ke.wzWPxe.OIC90c') &&\r\n        questionElement.querySelectorAll('.lLfZXe[role=\"radiogroup\"]').length > 1) {\r\n        //console.log(\"Wykryto pytanie typu: grid/matrix z radio buttons\");\r\n        return \"grid\";\r\n    }\r\n\r\n    // Check for checkbox grid questions\r\n    if (questionElement.querySelector('.mxSrOe') &&\r\n        questionElement.querySelectorAll('.q9ZqCb').length > 0) {\r\n        //console.log(\"Wykryto pytanie typu: grid/matrix z checkboxami\");\r\n        return \"checkboxGrid\";\r\n    }\r\n\r\n    // Check for scale questions (linear scale)\r\n    if (questionElement.querySelector('.N9Qcwe') &&\r\n        questionElement.querySelector('.lLfZXe.fnxRtf.BpKDyb[role=\"radiogroup\"]')) {\r\n        //console.log(\"Wykryto pytanie typu: skala liniowa\");\r\n        return \"scale\";\r\n    }\r\n\r\n    // Check for radio buttons (single choice)\r\n    if (questionElement.querySelector('.Od2TWd[role=\"radio\"]')) {\r\n        //console.log(\"Wykryto pytanie typu: singleChoice (radio)\");\r\n        return \"singleChoice\";\r\n    }\r\n\r\n    // Check for checkboxes (multiple choice)\r\n    if (questionElement.querySelector('.uVccjd[role=\"checkbox\"]')) {\r\n        //console.log(\"Wykryto pytanie typu: multipleChoice (checkbox)\");\r\n        return \"multipleChoice\";\r\n    }\r\n\r\n    // Check for dropdown lists - improved detection\r\n    if (questionElement.querySelector('.jgvuAb[role=\"listbox\"]') ||\r\n        questionElement.querySelector('.MocG8c[role=\"option\"]')) {\r\n        //console.log(\"Wykryto pytanie typu: dropdown\");\r\n        return \"dropdown\";\r\n    }\r\n\r\n    // Check for date pickers\r\n    if (questionElement.querySelector('input[type=\"date\"]') ||\r\n        questionElement.querySelector('[data-includesyear=\"true\"]')) {\r\n        //console.log(\"Wykryto pytanie typu: date\");\r\n        return \"date\";\r\n    }\r\n\r\n    // Check for time pickers\r\n    if (questionElement.querySelector('.ocBCTb[role=\"group\"]') ||\r\n        questionElement.querySelector('[jscontroller=\"OZjhxc\"]')) {\r\n        //console.log(\"Wykryto pytanie typu: time\");\r\n        return \"time\";\r\n    }\r\n\r\n    // Look for text inputs (short answer)\r\n    if (questionElement.querySelector('input[type=\"text\"]:not([role=\"combobox\"]), textarea')) {\r\n        // Check if it's a long answer (textarea) or short answer (input)\r\n        if (questionElement.querySelector('textarea')) {\r\n            //console.log(\"Wykryto pytanie typu: longText (textarea)\");\r\n            return \"longText\";\r\n        } else {\r\n            //console.log(\"Wykryto pytanie typu: shortText (input)\");\r\n            return \"shortText\";\r\n        }\r\n    }\r\n\r\n    //console.log(\"Nie udało się wykryć typu pytania. Sprawdzam alternatywne selektory.\");\r\n\r\n    // Alternatywne selektory w przypadku nieznalezienia podstawowych\r\n    if (questionElement.querySelector('.rFrNMe')) {\r\n        //console.log(\"Wykryto pytanie typu alternatywnie: openText (via .rFrNMe)\");\r\n        return \"openText\";\r\n    }\r\n\r\n    if (questionElement.querySelector('.lLfZXe[role=\"radiogroup\"]')) {\r\n        //console.log(\"Wykryto pytanie typu alternatywnie: singleChoice (via radiogroup)\");\r\n        return \"singleChoice\";\r\n    }\r\n\r\n    //console.log(\"Nie udało się wykryć typu pytania - zwracam unknown\");\r\n    return \"unknown\";\r\n}\r\n\r\n\r\n/*************************************************\r\n * EXTRACT SCALE QUESTION\r\n *************************************************/\r\nasync function extractScaleQuestionGoogleForms(questionElement) {\r\n    //console.log(\"Wyciąganie danych pytania typu skala...\");\r\n\r\n    // Extract scale options (the numbers or values in the scale)\r\n    const scaleOptions = [];\r\n    const scaleItems = questionElement.querySelectorAll('.T5pZmf');\r\n\r\n    scaleItems.forEach((item, index) => {\r\n        const optionValue = item.querySelector('.Zki2Ve')?.innerText.trim();\r\n        if (optionValue) {\r\n            scaleOptions.push({\r\n                id: String(index + 1),\r\n                label: optionValue\r\n            });\r\n            //console.log(`Wyciągnięto opcję skali ${index + 1}: ${optionValue}`);\r\n        }\r\n    });\r\n\r\n    // Extract scale labels (like \"Strongly disagree\" to \"Strongly agree\")\r\n    const lowLabel = questionElement.querySelector('.g4s2gf')?.innerText.trim() || \"\";\r\n    const highLabel = questionElement.querySelector('[jsname=\"jq1lEb\"]')?.innerText.trim() || \"\";\r\n\r\n    //console.log(`Etykiety skali: \"${lowLabel}\" do \"${highLabel}\"`);\r\n\r\n    return {\r\n        options: scaleOptions,\r\n        lowLabel,\r\n        highLabel\r\n    };\r\n}\r\n\r\n/*************************************************\r\n * EXTRACT DROPDOWN QUESTION\r\n *************************************************/\r\nasync function extractDropdownQuestionGoogleForms(questionElement) {\r\n    //console.log(\"Wyciąganie opcji z listy rozwijanej...\");\r\n\r\n    const options = [];\r\n    const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n\r\n    // Find all dropdown options\r\n    const dropdownOptions = questionElement.querySelectorAll('.MocG8c[role=\"option\"]');\r\n\r\n    // Skip the first option if it's a placeholder (like \"Choose\")\r\n    const startIdx = dropdownOptions.length > 0 &&\r\n        dropdownOptions[0].classList.contains('LMgvRb') ? 1 : 0;\r\n\r\n    for (let i = startIdx; i < dropdownOptions.length; i++) {\r\n        const option = dropdownOptions[i];\r\n        const optionText = option.querySelector('.vRMGwf')?.innerText.trim() || \"\";\r\n\r\n        if (optionText) {\r\n            const id = letters[i - startIdx] || String(i - startIdx + 1);\r\n            options.push({\r\n                id,\r\n                label: optionText\r\n            });\r\n            //console.log(`Wyciągnięto opcję dropdown ${id}: ${optionText}`);\r\n        }\r\n    }\r\n\r\n    return options;\r\n}\r\n\r\n/*************************************************\r\n * EXTRACT CHECKBOX GRID QUESTION\r\n *************************************************/\r\nasync function extractCheckboxGridGoogleForms(questionElement) {\r\n    //console.log(\"Wyciąganie danych pytania typu grid z checkboxami...\");\r\n\r\n    // Try multiple selectors for row headers (statements/terms)\r\n    const rowSelectors = [\r\n        '.V4d7Ke.wzWPxe.OIC90c',  // Main selector\r\n        '.V4d7Ke.wzWPxe',         // Alternative selector\r\n        '.mxSrOe .V4d7Ke.wzWPxe.OIC90c'  // Another alternative\r\n    ];\r\n\r\n    const statements = [];\r\n    const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n    let rowElements = [];\r\n\r\n    // Try each selector until we find row elements\r\n    for (const selector of rowSelectors) {\r\n        rowElements = questionElement.querySelectorAll(selector);\r\n        if (rowElements.length > 0) {\r\n            //console.log(`Znaleziono ${rowElements.length} wierszy używając selektora: ${selector}`);\r\n            break;\r\n        }\r\n    }\r\n\r\n    // Special case - if we still don't have rows but grid is detected, try looking at element text content\r\n    if (rowElements.length === 0) {\r\n        // Try to find rows directly in the grid by looking at row text\r\n        const allGridTexts = questionElement.querySelectorAll('.mxSrOe');\r\n\r\n        // Collect row texts that are likely to be row labels\r\n        const possibleRows = [];\r\n        allGridTexts.forEach((element, index) => {\r\n            const rowText = element.querySelector('.wzWPxe')?.textContent.trim();\r\n            if (rowText && rowText.length > 3) {\r\n                possibleRows.push({ element, text: rowText });\r\n            }\r\n        });\r\n\r\n        //console.log(`Alternatywnie znaleziono ${possibleRows.length} możliwych etykiet wierszy`);\r\n\r\n        // Generate statements from these possible rows\r\n        possibleRows.forEach((row, index) => {\r\n            const id = letters[index] || String(index + 1);\r\n            statements.push({\r\n                id,\r\n                text: row.text\r\n            });\r\n            //console.log(`Wyciągnięto wiersz (alternatywnie) ${id}: ${row.text}`);\r\n        });\r\n    } else {\r\n        // Process found rows normally\r\n        for (let i = 0; i < rowElements.length; i++) {\r\n            const rowText = rowElements[i].textContent.trim();\r\n            if (rowText) {\r\n                const id = letters[i] || String(i + 1);\r\n                statements.push({\r\n                    id,\r\n                    text: rowText\r\n                });\r\n                //console.log(`Wyciągnięto wiersz ${id}: ${rowText}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Try multiple selectors for column headers (options)\r\n    const columnSelectors = [\r\n        '.ssX1Bd.KZt9Tc .V4d7Ke.OIC90c',  // Main selector\r\n        '.ssX1Bd.KZt9Tc > .V4d7Ke',       // Alternative selector\r\n        '.V4d7Ke.OIC90c'                  // More general selector\r\n    ];\r\n\r\n    const commonOptions = [];\r\n    let columnHeaderElements = [];\r\n\r\n    // Try each selector until we find column elements\r\n    for (const selector of columnSelectors) {\r\n        columnHeaderElements = questionElement.querySelectorAll(selector);\r\n        // Skip the first element if it's empty (usually the grid corner)\r\n        const startIndex = columnHeaderElements.length > 0 &&\r\n            !columnHeaderElements[0].textContent.trim() ? 1 : 0;\r\n\r\n        if (columnHeaderElements.length > startIndex) {\r\n            //console.log(`Znaleziono ${columnHeaderElements.length - startIndex} kolumn używając selektora: ${selector}`);\r\n\r\n            // Process the column headers\r\n            for (let i = startIndex; i < columnHeaderElements.length; i++) {\r\n                const columnText = columnHeaderElements[i].textContent.trim();\r\n                if (columnText) {\r\n                    const id = String(i - startIndex + 1);\r\n                    commonOptions.push({\r\n                        id,\r\n                        label: columnText\r\n                    });\r\n                    //console.log(`Wyciągnięto kolumnę ${id}: ${columnText}`);\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n\r\n    // If we still don't have columns but have rows, create default columns\r\n    if (commonOptions.length === 0 && statements.length > 0) {\r\n        //console.log(\"Nie znaleziono kolumn. Tworzenie domyślnych opcji.\");\r\n\r\n        // Look for checkbox elements to count columns\r\n        const firstRow = questionElement.querySelector('.mxSrOe');\r\n        const checkboxesInFirstRow = firstRow ? firstRow.querySelectorAll('.uVccjd[role=\"checkbox\"]') : [];\r\n\r\n        const columnCount = checkboxesInFirstRow.length > 0 ?\r\n            checkboxesInFirstRow.length : 3; // Default to 3 if can't determine\r\n\r\n        // Create default column options\r\n        for (let i = 0; i < columnCount; i++) {\r\n            const id = String(i + 1);\r\n            const defaultLabel = `Opcja ${id}`;\r\n            commonOptions.push({\r\n                id,\r\n                label: defaultLabel\r\n            });\r\n            //console.log(`Utworzono domyślną kolumnę ${id}: ${defaultLabel}`);\r\n        }\r\n    }\r\n\r\n    return { statements, commonOptions };\r\n}\r\n\r\n/*************************************************\r\n * EXTRACT DATE AND TIME QUESTION\r\n *************************************************/\r\nasync function extractDateQuestionGoogleForms(questionElement) {\r\n    //console.log(\"Wyciąganie danych pytania typu data...\");\r\n\r\n    const dateInput = questionElement.querySelector('input[type=\"date\"]');\r\n    const dateFormat = dateInput?.placeholder || \"YYYY-MM-DD\";\r\n\r\n    //console.log(`Format daty: ${dateFormat}`);\r\n\r\n    return { format: dateFormat };\r\n}\r\n\r\nasync function extractTimeQuestionGoogleForms(questionElement) {\r\n    //console.log(\"Wyciąganie danych pytania typu czas...\");\r\n\r\n    const hourInput = questionElement.querySelector('[jsname=\"MKaSrf\"] input');\r\n    const minuteInput = questionElement.querySelector('[jsname=\"QbtXXe\"] input');\r\n\r\n    const format = hourInput && minuteInput ? \"HH:MM\" : \"unknown\";\r\n    //console.log(`Format czasu: ${format}`);\r\n\r\n    return { format };\r\n}\r\n\r\n/*************************************************\r\n * 2. QUESTION TEXT EXTRACTION\r\n *************************************************/\r\nasync function extractQuestionTextGoogleForms(questionElement) {\r\n    //console.log(\"Wyciąganie tekstu pytania...\");\r\n\r\n    // Find the question title element\r\n    const titleElement = questionElement.querySelector('.M7eMe');\r\n    let questionText = \"\";\r\n\r\n    if (titleElement) {\r\n        questionText = titleElement.innerText.trim();\r\n        //console.log(\"Wyciągnięty tekst pytania:\", questionText);\r\n\r\n        // Extract math content if present\r\n        const mathContent = await extractMathContent(titleElement);\r\n        if (mathContent) {\r\n            questionText += \"\\n\" + mathContent;\r\n        }\r\n    } else {\r\n        //console.log(\"Nie znaleziono elementu tytułu pytania (.M7eMe)\");\r\n    }\r\n\r\n    // Extract any description text\r\n    const descriptionElement = questionElement.querySelector('.gubaDc.OIC90c.RjsPE');\r\n    if (descriptionElement && descriptionElement.innerText.trim()) {\r\n        const descText = descriptionElement.innerText.trim();\r\n        questionText += \"\\n\" + descText;\r\n        //console.log(\"Wyciągnięty opis pytania:\", descText);\r\n    }\r\n\r\n    // Extract images\r\n    const images = await extractImages(questionElement);\r\n    if (images.length > 0) {\r\n        //console.log(`Znaleziono ${images.length} obrazków w pytaniu`);\r\n    }\r\n\r\n    return { text: questionText, images };\r\n}\r\n\r\n/*************************************************\r\n * 3. EXTRACT ANSWERS FOR CHOICE QUESTIONS\r\n *************************************************/\r\nasync function extractChoiceAnswersGoogleForms(questionElement) {\r\n    //console.log(\"Wyciąganie opcji odpowiedzi...\");\r\n\r\n    // Different question types have different structures\r\n    let answerElements = [];\r\n\r\n    // For multiple choice questions (checkboxes)\r\n    if (questionElement.querySelector('.uVccjd[role=\"checkbox\"]')) {\r\n        answerElements = questionElement.querySelectorAll('.eBFwI[role=\"listitem\"]');\r\n        //console.log(`Znaleziono ${answerElements.length} opcji wielokrotnego wyboru (checkbox)`);\r\n    }\r\n    // For single choice questions (radio buttons)\r\n    else if (questionElement.querySelector('.Od2TWd[role=\"radio\"]')) {\r\n        answerElements = questionElement.querySelectorAll('.nWQGrd.zwllIb');\r\n        //console.log(`Znaleziono ${answerElements.length} opcji pojedynczego wyboru (radio)`);\r\n    }\r\n    // For dropdown questions\r\n    else if (questionElement.querySelector('.MocG8c[role=\"option\"]')) {\r\n        answerElements = questionElement.querySelectorAll('.MocG8c[role=\"option\"]:not(:first-child)');\r\n        //console.log(`Znaleziono ${answerElements.length} opcji w dropdown`);\r\n    }\r\n    // Alternative single choice layout\r\n    else if (questionElement.querySelector('.lLfZXe[role=\"radiogroup\"]')) {\r\n        answerElements = questionElement.querySelectorAll('.nWQGrd.zwllIb');\r\n        //console.log(`Znaleziono ${answerElements.length} opcji pojedynczego wyboru (alternatywny radio)`);\r\n\r\n        // Alternatywny selektor jeśli powyższy nie działa\r\n        if (answerElements.length === 0) {\r\n            answerElements = questionElement.querySelectorAll('.lLfZXe[role=\"radiogroup\"] .docssharedWizToggleLabeledContainer');\r\n            //console.log(`Znaleziono ${answerElements.length} opcji pojedynczego wyboru (głębszy alternatywny selektor)`);\r\n        }\r\n    }\r\n\r\n    if (answerElements.length === 0) {\r\n        //console.log(\"Nie znaleziono elementów odpowiedzi. Struktura HTML może być inna.\");\r\n    }\r\n\r\n    const options = [];\r\n    const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n\r\n    for (let i = 0; i < answerElements.length; i++) {\r\n        const answerElement = answerElements[i];\r\n\r\n        // Skip \"other\" option if present\r\n        if (answerElement.classList.contains('vm96I')) {\r\n            continue;\r\n        }\r\n\r\n        // Extract the option text based on question type\r\n        let answerText = \"\";\r\n\r\n        // For multiple choice\r\n        const checkboxLabel = answerElement.querySelector('.aDTYNe, .ulDsOb span');\r\n        // For single choice\r\n        const radioLabel = answerElement.querySelector('.aDTYNe.snByac.OvPDhc');\r\n        // For dropdown\r\n        const dropdownOption = answerElement.querySelector('.vRMGwf.oJeWuf');\r\n\r\n        if (checkboxLabel) {\r\n            answerText = checkboxLabel.textContent;\r\n        } else if (radioLabel) {\r\n            answerText = radioLabel.textContent;\r\n        } else if (dropdownOption) {\r\n            answerText = dropdownOption.textContent;\r\n        } else {\r\n            // Fallback: try to get any visible text\r\n            answerText = answerElement.textContent;\r\n        }\r\n\r\n        // Extract math content if present\r\n        const mathContent = await extractMathContent(answerElement);\r\n        if (mathContent) {\r\n            answerText += \"\\n\" + mathContent;\r\n        }\r\n\r\n        // Extract images\r\n        const images = await extractImages(answerElement);\r\n\r\n        const id = letters[i] || String(i + 1);\r\n        options.push({\r\n            id,\r\n            label: answerText.trim(),\r\n            images\r\n        });\r\n\r\n        //console.log(`Wyciągnięto opcję ${id}: ${answerText.trim()}`);\r\n    }\r\n\r\n    return options;\r\n}\r\n\r\n/*************************************************\r\n * 4. EXTRACT OPEN TEXT QUESTIONS\r\n *************************************************/\r\nasync function extractOpenTextQuestionGoogleForms(questionElement) {\r\n    //console.log(\"Wyciąganie danych pytania otwartego...\");\r\n\r\n    const inputElement = questionElement.querySelector('input[type=\"text\"]:not([role=\"combobox\"]), textarea');\r\n\r\n    if (inputElement) {\r\n        //console.log(`Znaleziono element input z placeholder: \"${inputElement.placeholder || 'Wprowadź odpowiedź'}\"`);\r\n    } else {\r\n        //console.log(\"Nie znaleziono elementu input dla pytania otwartego\");\r\n    }\r\n\r\n    const images = await extractImages(questionElement);\r\n\r\n    return {\r\n        placeholder: inputElement ? inputElement.placeholder || \"Wprowadź odpowiedź\" : \"Wprowadź odpowiedź\",\r\n        images\r\n    };\r\n}\r\n/*************************************************\r\n * EXTRACT GRID/MATRIX QUESTIONS DATA\r\n *************************************************/\r\n\r\nasync function extractGridQuestionGoogleForms(questionElement) {\r\n    //console.log(\"Wyciąganie danych pytania typu grid/matrix...\");\r\n\r\n    // 1. Extract the row headers (statements/terms) - używamy lepszego selektora\r\n    const rowSelectors = [\r\n        '.lLfZXe[role=\"radiogroup\"] .V4d7Ke.wzWPxe.OIC90c', // Główny selektor\r\n        '.V4d7Ke.wzWPxe.OIC90c'                             // Alternatywny selektor\r\n    ];\r\n\r\n    let rowElements = [];\r\n    // Próbujemy różnych selektorów, aż znajdziemy pasujące elementy\r\n    for (const selector of rowSelectors) {\r\n        rowElements = questionElement.querySelectorAll(selector);\r\n        if (rowElements.length > 0) {\r\n            //console.log(`Znaleziono ${rowElements.length} wierszy (terminów) używając selektora: ${selector}`);\r\n            break;\r\n        }\r\n    }\r\n\r\n    // Utworzenie tablicy na unikalne statements\r\n    const statements = [];\r\n    const seenTexts = new Set(); // Do śledzenia unikalnych tekstów\r\n    const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n\r\n    for (let i = 0; i < rowElements.length; i++) {\r\n        const rowElement = rowElements[i];\r\n        const rowText = rowElement.textContent.trim();\r\n\r\n        // Sprawdzamy, czy ten tekst już został dodany\r\n        if (rowText && !seenTexts.has(rowText)) {\r\n            seenTexts.add(rowText); // Oznaczamy jako widziany\r\n            const id = letters[statements.length] || String(statements.length + 1);\r\n            statements.push({\r\n                id,\r\n                text: rowText\r\n            });\r\n            //console.log(`Wyciągnięto wiersz ${id}: ${rowText}`);\r\n        }\r\n    }\r\n\r\n    //console.log(`Znaleziono ${statements.length} unikalnych wierszy`);\r\n\r\n    // 2. Extract the column headers (options/definitions)\r\n    // Najpierw szukamy nagłówków kolumn (pierwszy wiersz z definicjami)\r\n    const columnHeaderRow = questionElement.querySelector('.ssX1Bd.KZt9Tc');\r\n    const columnElements = columnHeaderRow ? columnHeaderRow.querySelectorAll('.V4d7Ke.OIC90c') : [];\r\n\r\n    const commonOptions = [];\r\n\r\n    for (let i = 0; i < columnElements.length; i++) {\r\n        const columnElement = columnElements[i];\r\n        const columnText = columnElement.textContent.trim();\r\n        if (columnText) {\r\n            const id = String(i + 1);\r\n            commonOptions.push({\r\n                id,\r\n                label: columnText\r\n            });\r\n            //console.log(`Wyciągnięto kolumnę ${id}: ${columnText}`);\r\n        }\r\n    }\r\n\r\n    // Jeśli nie znaleziono opcji, spróbuj alternatywnej metody\r\n    if (commonOptions.length === 0) {\r\n        // Znajdź pierwsze pytanie i wydobądź opcje z data-value\r\n        const firstRow = questionElement.querySelector('.lLfZXe[role=\"radiogroup\"]');\r\n        if (firstRow) {\r\n            const optionElements = firstRow.querySelectorAll('.Od2TWd[role=\"radio\"]');\r\n            optionElements.forEach((option, index) => {\r\n                const optionValue = option.getAttribute('data-value');\r\n                if (optionValue) {\r\n                    commonOptions.push({\r\n                        id: String(index + 1),\r\n                        label: optionValue\r\n                    });\r\n                    //console.log(`Wyciągnięto opcję (alternatywnie) ${index + 1}: ${optionValue}`);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    return { statements, commonOptions };\r\n}\r\n\r\n/*************************************************\r\n * UPDATE BUILD UNIFIED QUESTION FOR GRID TYPES\r\n *************************************************/\r\nasync function buildUnifiedQuestion(questionElement) {\r\n    //console.log(\"Budowanie ujednoliconej struktury pytania...\");\r\n\r\n    const detectedType = detectQuestionTypeGoogleForms(questionElement);\r\n\r\n    // Skip personal info questions\r\n    if (detectedType === \"personal\") {\r\n        //console.log(\"Pomijam pytanie o dane osobowe\");\r\n        return null;\r\n    }\r\n\r\n    const { text, images } = await extractQuestionTextGoogleForms(questionElement);\r\n\r\n    // For grid/matrix questions, don't require text to be present (some forms have empty heading)\r\n    if (!text && (detectedType !== \"grid\" && detectedType !== \"checkboxGrid\")) {\r\n        //console.log(\"Nie udało się wyciągnąć tekstu pytania\");\r\n        return null;\r\n    }\r\n\r\n    let unified = {\r\n        id: questionElement.id || `q-${Date.now()}`,\r\n        text,\r\n        images,\r\n        metadata: { difficulty: \"unknown\" }\r\n    };\r\n\r\n    // Map Google Forms question types to the unified format\r\n    switch (detectedType) {\r\n        case \"grid\":\r\n            //console.log(\"Budowanie ujednoliconego pytania typu grid\");\r\n            unified.type = \"likert\";\r\n\r\n            // Wyciągnij dane pytania typu grid\r\n            const gridData = await extractGridQuestionGoogleForms(questionElement);\r\n            unified.statements = gridData.statements;\r\n            unified.commonOptions = gridData.commonOptions;\r\n\r\n            unified.format = {\r\n                responseType: \"matrix\",\r\n                description: \"Podaj odpowiedź dla każdego wiersza, wybierając poprawną opcję z kolumny.\"\r\n            };\r\n\r\n            //console.log(\"Zbudowano pytanie typu grid z\", unified.statements.length, \"wierszami i\", unified.commonOptions.length, \"opcjami\");\r\n            break;\r\n\r\n        case \"checkboxGrid\":\r\n            //console.log(\"Budowanie ujednoliconego pytania typu checkbox grid\");\r\n            unified.type = \"checkboxGrid\";\r\n\r\n            // Wyciągnij dane pytania typu checkbox grid\r\n            const checkboxGridData = await extractCheckboxGridGoogleForms(questionElement);\r\n            unified.statements = checkboxGridData.statements;\r\n            unified.commonOptions = checkboxGridData.commonOptions;\r\n\r\n            unified.format = {\r\n                responseType: \"checkboxMatrix\",\r\n                description: \"Zaznacz odpowiednie opcje dla każdego wiersza, odpowiedź jako obiekt {wiersz: [kolumny]}.\"\r\n            };\r\n\r\n            //console.log(\"Zbudowano pytanie typu checkbox grid z\", unified.statements.length, \"wierszami i\", unified.commonOptions.length, \"opcjami\");\r\n            break;\r\n\r\n        case \"scale\":\r\n            //console.log(\"Budowanie ujednoliconego pytania typu skala\");\r\n            unified.type = \"scale\";\r\n\r\n            // Wyciągnij dane pytania typu skala\r\n            const scaleData = await extractScaleQuestionGoogleForms(questionElement);\r\n            unified.options = scaleData.options;\r\n            unified.lowLabel = scaleData.lowLabel;\r\n            unified.highLabel = scaleData.highLabel;\r\n\r\n            unified.format = {\r\n                responseType: \"optionId\",\r\n                description: \"Odpowiedz jako numer odpowiadający wartości na skali.\"\r\n            };\r\n\r\n            //console.log(\"Zbudowano pytanie typu skala z\", unified.options.length, \"opcjami\");\r\n            break;\r\n\r\n        case \"singleChoice\":\r\n            unified.type = \"singlechoice\";\r\n            unified.options = await extractChoiceAnswersGoogleForms(questionElement);\r\n            unified.format = {\r\n                responseType: \"optionId\",\r\n                description: \"Odpowiedz jako pojedyncza litera odpowiadająca właściwej opcji.\"\r\n            };\r\n            break;\r\n\r\n        case \"multipleChoice\":\r\n            unified.type = \"multiple\";\r\n            unified.options = await extractChoiceAnswersGoogleForms(questionElement);\r\n            unified.format = {\r\n                responseType: \"optionIds\",\r\n                description: \"Odpowiedz jako tablica liter odpowiadających właściwym opcjom (np. [\\\"A\\\", \\\"C\\\"]).\"\r\n            };\r\n            break;\r\n\r\n        case \"dropdown\":\r\n            unified.type = \"dropdown\";\r\n            unified.options = await extractDropdownQuestionGoogleForms(questionElement);\r\n            unified.format = {\r\n                responseType: \"optionId\",\r\n                description: \"Odpowiedz jako pojedyncza litera odpowiadająca właściwej opcji z listy rozwijanej.\"\r\n            };\r\n            //console.log(\"Zbudowano pytanie typu dropdown z\", unified.options.length, \"opcjami\");\r\n            break;\r\n\r\n        case \"date\":\r\n            unified.type = \"date\";\r\n            const dateData = await extractDateQuestionGoogleForms(questionElement);\r\n            unified.format = {\r\n                responseType: \"date\",\r\n                description: \"Podaj odpowiedź w formacie YYYY-MM-DD.\",\r\n                format: dateData.format\r\n            };\r\n            //console.log(\"Zbudowano pytanie typu date\");\r\n            break;\r\n\r\n        case \"time\":\r\n            unified.type = \"time\";\r\n            const timeData = await extractTimeQuestionGoogleForms(questionElement);\r\n            unified.format = {\r\n                responseType: \"time\",\r\n                description: \"Podaj odpowiedź w formacie HH:MM.\",\r\n                format: timeData.format\r\n            };\r\n            //console.log(\"Zbudowano pytanie typu time\");\r\n            break;\r\n\r\n        case \"shortText\":\r\n            unified.type = \"shortanswer\";\r\n            const shortData = await extractOpenTextQuestionGoogleForms(questionElement);\r\n            unified.options = [];\r\n            unified.placeholder = shortData.placeholder;\r\n            unified.format = {\r\n                responseType: \"text\",\r\n                description: \"Podaj krótką, zwięzłą odpowiedź tekstową (max. kilka słów).\"\r\n            };\r\n            break;\r\n\r\n        case \"longText\":\r\n            unified.type = \"longanswer\";\r\n            const longData = await extractOpenTextQuestionGoogleForms(questionElement);\r\n            unified.options = [];\r\n            unified.placeholder = longData.placeholder;\r\n            unified.format = {\r\n                responseType: \"text\",\r\n                description: \"Podaj wyczerpującą, szczegółową odpowiedź tekstową.\"\r\n            };\r\n            break;\r\n\r\n        case \"openText\":\r\n            unified.type = \"shortanswer\";\r\n            const openData = await extractOpenTextQuestionGoogleForms(questionElement);\r\n            unified.options = [];\r\n            unified.placeholder = openData.placeholder;\r\n\r\n            // Determine if this is a short or long answer\r\n            const textareaElement = questionElement.querySelector('textarea');\r\n            unified.answerLength = textareaElement ? \"long\" : \"short\";\r\n\r\n            // Set format based on answer length\r\n            if (unified.answerLength === \"long\") {\r\n                unified.format = {\r\n                    responseType: \"text\",\r\n                    description: \"Podaj wyczerpującą, szczegółową odpowiedź tekstową.\"\r\n                };\r\n            } else {\r\n                unified.format = {\r\n                    responseType: \"text\",\r\n                    description: \"Podaj krótką, zwięzłą odpowiedź tekstową (max. kilka słów).\"\r\n                };\r\n            }\r\n            break;\r\n\r\n        default:\r\n            //console.log(`Nieobsługiwany typ pytania: ${detectedType}`);\r\n            return null;\r\n    }\r\n\r\n    //console.log(\"Zbudowana struktura pytania:\", unified);\r\n    return unified;\r\n}\r\n\r\nfunction getCorrectAnswerText() {\r\n    // Pobierz język przeglądarki\r\n    const browserLang = navigator.language || navigator.userLanguage;\r\n    const lang = browserLang.split('-')[0]; // Pobierz kod głównego języka (np. \"pl\" z \"pl-PL\")\r\n\r\n    // Tłumaczenia dla \"Poprawna odpowiedź\" w różnych językach\r\n    const translations = {\r\n        'pl': 'Poprawna odpowiedź:',\r\n        'en': 'Correct answer:',\r\n        'de': 'Richtige Antwort:',\r\n        'es': 'Respuesta correcta:',\r\n        'fr': 'Réponse correcte:',\r\n        'it': 'Risposta corretta:',\r\n        'ru': 'Правильный ответ:',\r\n        'cs': 'Správná odpověď:',\r\n        'sk': 'Správna odpoveď:',\r\n        'uk': 'Правильна відповідь:'\r\n    };\r\n\r\n    // Zwróć tłumaczenie dla wykrytego języka lub domyślnie angielski\r\n    return translations[lang] || translations['en'];\r\n}\r\n\r\n\r\n/*************************************************\r\n * 6. MARK CORRECT ANSWERS\r\n *************************************************/\r\nfunction markCorrectAnswer(questionElement, correctAnswerObj, unifiedQuestion, mode) {\r\n    //console.log(`Zaznaczanie poprawnej odpowiedzi w trybie: ${mode}`, { correctAnswer: correctAnswerObj });\r\n\r\n    mode = mode.toLowerCase();\r\n    const qType = unifiedQuestion.type;\r\n\r\n    // Handle personal info questions - skip these\r\n    if (qType === \"personal\") {\r\n        //console.log(\"Pomijam zaznaczanie odpowiedzi dla pytania o dane osobowe\");\r\n        return;\r\n    }\r\n\r\n    if (qType === \"singlechoice\") {\r\n        // Różne formularze mogą mieć różne struktury, spróbuj kilku selektorów\r\n        let answerElements = questionElement.querySelectorAll('.nWQGrd.zwllIb');\r\n        if (answerElements.length === 0) {\r\n            answerElements = questionElement.querySelectorAll('.lLfZXe[role=\"radiogroup\"] .docssharedWizToggleLabeledContainer');\r\n        }\r\n\r\n        //console.log(`Znaleziono ${answerElements.length} elementów odpowiedzi pojedynczego wyboru`);\r\n\r\n        // Determine which option is correct\r\n        let correctIndex = -1;\r\n        if (typeof correctAnswerObj === \"string\") {\r\n            const correctLetter = correctAnswerObj.trim().toUpperCase();\r\n            const optionIds = unifiedQuestion.options.map(opt => opt.id.toUpperCase());\r\n            correctIndex = optionIds.indexOf(correctLetter);\r\n            //console.log(`Poprawna odpowiedź to \"${correctLetter}\" (indeks: ${correctIndex})`);\r\n        }\r\n\r\n        if (correctIndex >= 0 && correctIndex < answerElements.length) {\r\n            const correctElement = answerElements[correctIndex];\r\n            //console.log(`Znaleziono poprawny element:`, correctElement);\r\n\r\n            if (mode === \"default\") {\r\n                // Just highlight the correct answer visually\r\n                const textElement = correctElement.querySelector('.Hvn9fb, .RWzxl, .aDTYNe');\r\n                if (textElement) {\r\n                    textElement.style.color = \"green\";\r\n                    textElement.style.fontWeight = \"700\";\r\n                    //console.log(\"Zastosowano wyróżnienie do elementu tekstowego\");\r\n                } else {\r\n                    //console.log(\"Nie znaleziono elementu tekstowego do wyróżnienia\");\r\n                }\r\n\r\n                // Handle any images in the answer\r\n                const imgEl = correctElement.querySelector('img');\r\n                if (imgEl) {\r\n                    const container = imgEl.parentElement;\r\n                    container.style.boxShadow = \"0 0 10px rgba(0, 128, 0, 0.7)\";\r\n                    container.style.border = \"2px solid rgba(0, 128, 0, 0.7)\";\r\n                    //console.log(\"Zastosowano wyróżnienie do kontenera obrazka\");\r\n                }\r\n            }\r\n            else if (mode === \"immediate\") {\r\n                // Simulate clicking the correct option - try multiple selectors\r\n                const radioElement = correctElement.querySelector('.zJKIV, .Od2TWd[role=\"radio\"], .d7L4fc .Od2TWd');\r\n                if (radioElement) {\r\n                    //console.log(\"Klikanie elementu radio:\", radioElement);\r\n                    radioElement.click();\r\n                } else {\r\n                    // If we can't find the radio element directly, try clicking the label which should trigger the radio\r\n                    //console.log(\"Nie znaleziono bezpośrednio elementu radio, próba kliknięcia etykiety\");\r\n                    correctElement.click();\r\n                }\r\n            }\r\n            else if (mode === \"savemode\") {\r\n                // Subtle indication of correct answer - bold only first letter\r\n                const textEl = correctElement.querySelector('.Hvn9fb, .RWzxl, .aDTYNe');\r\n                if (textEl) {\r\n                    const text = textEl.textContent || textEl.value || \"\";\r\n                    //console.log(\"Zastosowanie savemode do elementu tekstowego jednokrotnego wyboru\");\r\n\r\n                    if (text.length > 0) {\r\n                        // Zachowaj oryginalny tekst\r\n                        if (!textEl.dataset.originalText) {\r\n                            textEl.dataset.originalText = text;\r\n                        }\r\n\r\n                        // Jeśli to pole input\r\n                        if (textEl.value !== undefined) {\r\n                            textEl.dataset.originalValue = textEl.value;\r\n                            // Dodaj zdarzenie focus dla pól input\r\n                            textEl.addEventListener('focus', function () {\r\n                                if (this.dataset.originalValue) {\r\n                                    this.value = this.dataset.originalValue;\r\n                                }\r\n                            });\r\n                        }\r\n                        // Jeśli to element tekstowy (nie input)\r\n                        else {\r\n                            // Podziel tekst: pierwsza litera i reszta\r\n                            const firstChar = text.charAt(0);\r\n                            const restOfText = text.substring(1);\r\n\r\n                            // Usuń obecną zawartość\r\n                            textEl.textContent = '';\r\n\r\n                            // Utwórz element dla pierwszej litery\r\n                            const boldSpan = document.createElement('span');\r\n                            boldSpan.style.fontWeight = \"600\";\r\n                            boldSpan.textContent = firstChar;\r\n\r\n                            // Dodaj pierwszą literę i resztę tekstu\r\n                            textEl.appendChild(boldSpan);\r\n                            textEl.appendChild(document.createTextNode(restOfText));\r\n\r\n                            //console.log(`Pogrubiono pierwszą literę \"${firstChar}\" odpowiedzi`);\r\n                        }\r\n                    }\r\n                } else {\r\n                    //console.log(\"Nie znaleziono elementu tekstowego dla trybu savemode\");\r\n                }\r\n            }\r\n        } else {\r\n            //console.log(`Poprawny indeks ${correctIndex} jest poza zakresem (liczba elementów: ${answerElements.length})`);\r\n        }\r\n    }\r\n    else if (qType === \"multiple\") {\r\n        const answerElements = questionElement.querySelectorAll('.eBFwI[role=\"listitem\"]');\r\n        //console.log(`Znaleziono ${answerElements.length} elementów odpowiedzi wielokrotnego wyboru`);\r\n\r\n        // Parse the correct answers\r\n        let correctIndices = [];\r\n        if (Array.isArray(correctAnswerObj)) {\r\n            // If the backend returns an array of letters\r\n            const correctLetters = correctAnswerObj.map(letter => letter.toUpperCase());\r\n            const optionIds = unifiedQuestion.options.map(opt => opt.id.toUpperCase());\r\n\r\n            correctLetters.forEach(letter => {\r\n                const index = optionIds.indexOf(letter);\r\n                if (index >= 0) {\r\n                    correctIndices.push(index);\r\n                }\r\n            });\r\n            //console.log(`Poprawne odpowiedzi to ${correctLetters.join(', ')}`, { correctIndices });\r\n        } else if (typeof correctAnswerObj === \"string\") {\r\n            // If the backend returns a string like \"A,C\"\r\n            const parts = correctAnswerObj.split(',');\r\n            for (const part of parts) {\r\n                const letter = part.trim().toUpperCase();\r\n                const index = unifiedQuestion.options.findIndex(opt => opt.id.toUpperCase() === letter);\r\n                if (index >= 0) {\r\n                    correctIndices.push(index);\r\n                }\r\n            }\r\n            //console.log(`Poprawne odpowiedzi to ${parts.join(', ')}`, { correctIndices });\r\n        }\r\n\r\n        // Mark each correct answer\r\n        correctIndices.forEach(index => {\r\n            if (index >= 0 && index < answerElements.length) {\r\n                const correctElement = answerElements[index];\r\n                //console.log(`Znaleziono poprawny element wielokrotnego wyboru o indeksie ${index}`);\r\n\r\n                if (mode === \"default\") {\r\n                    // Highlight the correct answer visually\r\n                    const textElement = correctElement.querySelector('.Hvn9fb, .RWzxl, .aDTYNe');\r\n                    if (textElement) {\r\n                        textElement.style.color = \"green\";\r\n                        textElement.style.fontWeight = \"700\";\r\n                        //console.log(\"Zastosowano wyróżnienie do elementu tekstowego wielokrotnego wyboru\");\r\n                    } else {\r\n                        //console.log(\"Nie znaleziono elementu tekstowego do wyróżnienia w wielokrotnym wyborze\");\r\n                    }\r\n\r\n                    // Handle any images in the answer\r\n                    const imgEl = correctElement.querySelector('img');\r\n                    if (imgEl) {\r\n                        const container = imgEl.parentElement;\r\n                        container.style.boxShadow = \"0 0 10px rgba(0, 128, 0, 0.7)\";\r\n                        container.style.border = \"2px solid rgba(0, 128, 0, 0.7)\";\r\n                        //console.log(\"Zastosowano wyróżnienie do kontenera obrazka wielokrotnego wyboru\");\r\n                    }\r\n                }\r\n                else if (mode === \"immediate\") {\r\n                    // Simulate clicking the correct option\r\n                    const checkboxElement = correctElement.querySelector('.uVccjd[role=\"checkbox\"]');\r\n                    if (checkboxElement) {\r\n                        //console.log(\"Klikanie elementu checkbox:\", checkboxElement);\r\n                        checkboxElement.click();\r\n                    } else {\r\n                        // Try clicking the parent label which should trigger the checkbox\r\n                        //console.log(\"Nie znaleziono bezpośrednio elementu checkbox, próba kliknięcia etykiety\");\r\n                        const label = correctElement.querySelector('label');\r\n                        if (label) {\r\n                            label.click();\r\n                        } else {\r\n                            correctElement.click();\r\n                        }\r\n                    }\r\n                }\r\n                else if (mode === \"savemode\") {\r\n                    // Subtle indication of correct answer - bold only first letter\r\n                    const textEl = correctElement.querySelector('.Hvn9fb, .RWzxl, .aDTYNe');\r\n                    if (textEl) {\r\n                        const text = textEl.textContent || textEl.value || \"\";\r\n                        //console.log(\"Zastosowanie savemode do elementu tekstowego wielokrotnego wyboru\");\r\n\r\n                        if (text.length > 0) {\r\n                            // Zachowaj oryginalny tekst\r\n                            if (!textEl.dataset.originalText) {\r\n                                textEl.dataset.originalText = text;\r\n                            }\r\n\r\n                            // Jeśli to pole input\r\n                            if (textEl.value !== undefined) {\r\n                                textEl.dataset.originalValue = textEl.value;\r\n                                // Dodaj zdarzenie focus dla pól input\r\n                                textEl.addEventListener('focus', function () {\r\n                                    if (this.dataset.originalValue) {\r\n                                        this.value = this.dataset.originalValue;\r\n                                    }\r\n                                });\r\n                            }\r\n                            // Jeśli to element tekstowy (nie input)\r\n                            else {\r\n                                // Podziel tekst: pierwsza litera i reszta\r\n                                const firstChar = text.charAt(0);\r\n                                const restOfText = text.substring(1);\r\n\r\n                                // Usuń obecną zawartość\r\n                                textEl.textContent = '';\r\n\r\n                                // Utwórz element dla pierwszej litery\r\n                                const boldSpan = document.createElement('span');\r\n                                boldSpan.style.fontWeight = \"600\";\r\n                                boldSpan.textContent = firstChar;\r\n\r\n                                // Dodaj pierwszą literę i resztę tekstu\r\n                                textEl.appendChild(boldSpan);\r\n                                textEl.appendChild(document.createTextNode(restOfText));\r\n\r\n                                //console.log(`Pogrubiono pierwszą literę \"${firstChar}\" odpowiedzi w wielokrotnym wyborze`);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        //console.log(\"Nie znaleziono elementu tekstowego dla trybu savemode w wielokrotnym wyborze\");\r\n                    }\r\n                }\r\n            } else {\r\n                //console.log(`Poprawny indeks ${index} jest poza zakresem dla wielokrotnego wyboru (liczba elementów: ${answerElements.length})`);\r\n            }\r\n        });\r\n    }\r\n    else if (qType === \"shortanswer\" || qType === \"longanswer\") {\r\n        const inputElement = questionElement.querySelector('input[type=\"text\"]:not([role=\"combobox\"]), textarea');\r\n        //console.log(\"Znaleziono element input pytania otwartego:\", inputElement);\r\n\r\n        if (!inputElement) {\r\n            //console.log(\"Nie znaleziono elementu input dla pytania otwartego\");\r\n            return;\r\n        }\r\n\r\n        // Sprawdzamy, czy mamy do czynienia z długą czy krótką odpowiedzią\r\n        const isLongAnswer = inputElement.tagName.toLowerCase() === 'textarea' || qType === \"longanswer\";\r\n\r\n        // For short answers, make sure the text is actually short\r\n        let answerText = String(correctAnswerObj || \"\");\r\n        if (qType === \"shortanswer\" && answerText.length > 50) {\r\n            // Truncate to a short answer if it's too long\r\n            answerText = answerText.split(/[.,;]|\\s+/)[0].trim();\r\n            if (answerText.length > 50) answerText = answerText.substring(0, 50);\r\n            //console.log(`Skrócono długą odpowiedź do \"${answerText}\"`);\r\n        }\r\n\r\n        if (mode === \"default\") {\r\n            // Pobierz tekst \"Poprawna odpowiedź\" w języku przeglądarki\r\n            const correctAnswerText = getCorrectAnswerText();\r\n\r\n            // Usuń istniejący element informacyjny jeśli istnieje\r\n            const existingInfo = questionElement.querySelector('.correct-answer-info');\r\n            if (existingInfo) {\r\n                existingInfo.remove();\r\n            }\r\n\r\n            // Create an info element to display the correct answer\r\n            const mainContainer = questionElement.querySelector('.AgroKb');\r\n            //console.log(`Tryb default: wyświetlanie poprawnej odpowiedzi \"${answerText}\"`);\r\n\r\n            // Utwórz nowy element informacyjny\r\n            const info = document.createElement(\"div\");\r\n            info.classList.add(\"correct-answer-info\");\r\n\r\n            // Zastosuj wspólne style dla obu typów odpowiedzi\r\n            info.style.display = \"block\";\r\n            info.style.marginTop = \"10px\";\r\n            info.style.marginBottom = \"5px\";\r\n            info.style.color = \"green\";\r\n            info.style.fontWeight = \"500\";\r\n            info.style.whiteSpace = \"normal\";\r\n            info.style.overflow = \"auto\";\r\n            info.style.width = \"100%\";\r\n            info.style.boxSizing = \"border-box\";\r\n            info.style.position = \"relative\";\r\n            info.style.zIndex = \"10\";\r\n            info.style.padding = \"8px\";\r\n            info.style.border = \"1px solid #e0e0e0\";\r\n            info.style.borderRadius = \"4px\";\r\n            info.style.backgroundColor = \"#f0f8f0\";\r\n            info.style.fontSize = \"14px\";\r\n            info.style.lineHeight = \"1.5\";\r\n            info.style.wordWrap = \"break-word\";\r\n\r\n            // Tylko dla długich odpowiedzi ustawiamy maksymalną wysokość\r\n            if (isLongAnswer) {\r\n                info.style.maxHeight = \"200px\";\r\n            }\r\n\r\n            // Dla obu typów używamy tej samej struktury z nagłówkiem i treścią\r\n            const headerElement = document.createElement(\"div\");\r\n            headerElement.style.fontWeight = \"bold\";\r\n            headerElement.style.marginBottom = \"4px\";\r\n            headerElement.textContent = correctAnswerText;\r\n\r\n            const contentElement = document.createElement(\"div\");\r\n            contentElement.style.fontFamily = \"inherit\";\r\n            contentElement.style.whiteSpace = \"pre-wrap\";\r\n            contentElement.textContent = answerText;\r\n\r\n            info.appendChild(headerElement);\r\n            info.appendChild(contentElement);\r\n\r\n            // Dodajemy element w odpowiednim miejscu, korzystając z Twojej logiki\r\n            if (mainContainer) {\r\n                mainContainer.insertAdjacentElement(\"afterend\", info);\r\n            } else {\r\n                // Jeśli nie znaleziono kontenera AgroKb, spróbujmy znaleźć kontener SL4Sz\r\n                const alertContainer = questionElement.querySelector('.SL4Sz');\r\n                if (alertContainer) {\r\n                    alertContainer.insertAdjacentElement(\"beforebegin\", info);\r\n                } else {\r\n                    // Ostateczne rozwiązanie - dodaj do rodzica inputa\r\n                    const formContainer = inputElement.closest('.AgroKb, .geS5n');\r\n                    if (formContainer) {\r\n                        formContainer.insertAdjacentElement(\"afterend\", info);\r\n                    } else {\r\n                        // Awaryjne rozwiązanie, gdyby wszystko inne zawiodło\r\n                        const parentDiv = inputElement.closest('div');\r\n                        if (parentDiv) {\r\n                            parentDiv.parentElement.appendChild(info);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            //console.log(\"Utworzono element informacyjny z poprawną odpowiedzią\");\r\n        }\r\n        else if (mode === \"immediate\") {\r\n            // Set the value directly\r\n            //console.log(`Tryb immediate: ustawianie wartości input na \"${answerText}\"`);\r\n            inputElement.value = answerText;\r\n            inputElement.dispatchEvent(new Event('input', { bubbles: true }));\r\n            inputElement.dispatchEvent(new Event('change', { bubbles: true }));\r\n        }\r\n        else if (mode === \"savemode\") {\r\n            //console.log(\"Tryb savemode: agresywna metoda obsługi placeholdera (z ukrywaniem dodatkowego elementu)\");\r\n\r\n            // Znajdź input lub textarea – dopasowaj selektor do rzeczywistej struktury (np. wykorzystując klasę)\r\n            const inputElement = questionElement.querySelector('input, textarea');\r\n            if (!inputElement) {\r\n                console.warn(\"Savemode: Nie znaleziono pola odpowiedzi w pytaniu\");\r\n                return;\r\n            }\r\n\r\n            // Zapisz oryginalny placeholder zapisany w atrybucie input (jeśli istnieje)\r\n            const originalPlaceholder = inputElement.getAttribute('placeholder') || '';\r\n            inputElement.dataset.originalPlaceholder = originalPlaceholder;\r\n\r\n            // Pobierz domyślny element placeholder generowany przez stronę (np. Google)\r\n            const googlePlaceholder = questionElement.querySelector('div[jsname=\"LwH6nd\"]');\r\n\r\n            // Funkcja focus – ustawienie Twojego placeholdera oraz ukrycie dodatkowego elementu\r\n            const focusHandler = function () {\r\n                if (this.value === '') {\r\n                    this.placeholder = (isLongAnswer && answerText.length > 50)\r\n                        ? answerText.substring(0, 50) + \"...\"\r\n                        : answerText;\r\n                }\r\n                // Ukryj dodatkowy element (jeśli występuje)\r\n                if (googlePlaceholder) {\r\n                    googlePlaceholder.style.display = \"none\";\r\n                }\r\n            };\r\n\r\n            // Funkcja blur – przywrócenie oryginalnego placeholdera i pokazanie dodatkowego elementu\r\n            const blurHandler = function () {\r\n                const original = this.dataset.originalPlaceholder || '';\r\n                this.placeholder = original;\r\n                // Przywracamy domyślną widoczność dodatkowego placeholdera\r\n                if (googlePlaceholder) {\r\n                    googlePlaceholder.style.display = \"\";\r\n                }\r\n            };\r\n\r\n            // Funkcja input – w trakcie wpisywania tekstu modyfikujemy placeholder\r\n            const inputHandler = function () {\r\n                if (this.value !== '') {\r\n                    this.placeholder = '';\r\n                } else if (document.activeElement === this) {\r\n                    this.placeholder = (isLongAnswer && answerText.length > 50)\r\n                        ? answerText.substring(0, 50) + \"...\"\r\n                        : answerText;\r\n                }\r\n            };\r\n\r\n            // Usuń stare event listenery, jeśli są przypisane\r\n            if (inputElement.saveFocusHandler) {\r\n                inputElement.removeEventListener('focus', inputElement.saveFocusHandler);\r\n            }\r\n            if (inputElement.saveBlurHandler) {\r\n                inputElement.removeEventListener('blur', inputElement.saveBlurHandler);\r\n            }\r\n            if (inputElement.saveInputHandler) {\r\n                inputElement.removeEventListener('input', inputElement.saveInputHandler);\r\n            }\r\n\r\n            // Zapisz referencje do nowych handlerów\r\n            inputElement.saveFocusHandler = focusHandler;\r\n            inputElement.saveBlurHandler = blurHandler;\r\n            inputElement.saveInputHandler = inputHandler;\r\n\r\n            // Dodaj event listenery\r\n            inputElement.addEventListener('focus', focusHandler);\r\n            inputElement.addEventListener('blur', blurHandler);\r\n            inputElement.addEventListener('input', inputHandler);\r\n\r\n            // Jeśli input już ma focus, wywołaj focusHandler, w przeciwnym razie – blurHandler\r\n            if (document.activeElement === inputElement) {\r\n                focusHandler.call(inputElement);\r\n            } else {\r\n                blurHandler.call(inputElement);\r\n            }\r\n\r\n            //console.log(\"Savemode: ustawiono placeholder oraz ukryto dodatkowy element z placeholderem\");\r\n        }\r\n\r\n\r\n    }\r\n    else if (qType === \"dropdown\") {\r\n        //console.log(\"Zaznaczanie odpowiedzi dla pytania typu dropdown\");\r\n\r\n        const dropdownElement = questionElement.querySelector('.jgvuAb[role=\"listbox\"]');\r\n        if (!dropdownElement) {\r\n            //console.log(\"Nie znaleziono elementu dropdown\");\r\n            return;\r\n        }\r\n\r\n        // Determine which option is correct\r\n        let correctLetter = \"\";\r\n        if (typeof correctAnswerObj === \"string\") {\r\n            correctLetter = correctAnswerObj.trim().toUpperCase();\r\n            //console.log(`Poprawna odpowiedź to \"${correctLetter}\"`);\r\n        }\r\n\r\n        // Find the corresponding option text based on the letter\r\n        let correctOptionText = \"\";\r\n        if (correctLetter && unifiedQuestion.options) {\r\n            const correctOption = unifiedQuestion.options.find(\r\n                opt => opt.id.toUpperCase() === correctLetter\r\n            );\r\n            if (correctOption) {\r\n                correctOptionText = correctOption.label;\r\n                //console.log(`Znaleziono tekst opcji: \"${correctOptionText}\"`);\r\n            }\r\n        }\r\n\r\n        if (correctOptionText) {\r\n            if (mode === \"default\") {\r\n                // Otwórz dropdown, zmień kolor poprawnej odpowiedzi na zielony, a następnie zamknij dropdown\r\n                dropdownElement.click();\r\n\r\n                setTimeout(() => {\r\n                    const optionElements = document.querySelectorAll('.MocG8c[role=\"option\"]');\r\n                    let foundCorrect = false;\r\n\r\n                    for (const option of optionElements) {\r\n                        if (option.textContent.trim() === correctOptionText) {\r\n                            // Zmień kolor tekstu poprawnej odpowiedzi na zielony\r\n                            const optionText = option.querySelector('.vRMGwf');\r\n                            if (optionText) {\r\n                                optionText.style.color = \"green\";\r\n                                optionText.style.fontWeight = \"bold\";\r\n                            }\r\n                            foundCorrect = true;\r\n                            //console.log(`Zmieniono kolor tekstu opcji \"${correctOptionText}\" na zielony`);\r\n                        }\r\n                    }\r\n\r\n                    // Zamknij dropdown po dokonaniu zmian\r\n                    if (foundCorrect) {\r\n                        document.body.click();\r\n                    }\r\n                }, 300);\r\n            }\r\n            else if (mode === \"immediate\") {\r\n                // Natychmiast zaznacz poprawną odpowiedź\r\n                dropdownElement.click();\r\n\r\n                // Poczekaj na otwarcie dropdown i kliknij poprawną opcję\r\n                setTimeout(() => {\r\n                    const optionElements = document.querySelectorAll('.MocG8c[role=\"option\"]');\r\n                    for (const option of optionElements) {\r\n                        if (option.textContent.trim() === correctOptionText) {\r\n                            option.click();\r\n                            //console.log(`Kliknięto opcję \"${correctOptionText}\"`);\r\n                            break;\r\n                        }\r\n                    }\r\n                }, 300);\r\n            }\r\n            else if (mode === \"savemode\") {\r\n                // W trybie savemode otwórz dropdown i zmień kolor tekstu poprawnej odpowiedzi na szary\r\n                dropdownElement.click();\r\n\r\n                setTimeout(() => {\r\n                    const optionElements = document.querySelectorAll('.MocG8c[role=\"option\"]');\r\n                    let foundCorrect = false;\r\n\r\n                    for (const option of optionElements) {\r\n                        if (option.textContent.trim() === correctOptionText) {\r\n                            // Zmień kolor tekstu poprawnej odpowiedzi na szary\r\n                            const optionText = option.querySelector('.vRMGwf');\r\n                            if (optionText) {\r\n                                optionText.style.color = \"#505050\"; // Ciemnoszary\r\n                                optionText.style.fontWeight = \"600\"; // Lekkie pogrubienie\r\n                            }\r\n                            foundCorrect = true;\r\n                            //console.log(`Zmieniono kolor tekstu opcji \"${correctOptionText}\" na szary`);\r\n                        }\r\n                    }\r\n\r\n                    // Zamknij dropdown po dokonaniu zmian\r\n                    if (foundCorrect) {\r\n                        document.body.click();\r\n                    }\r\n                }, 300);\r\n            }\r\n        }\r\n    }\r\n    else if (qType === \"scale\") {\r\n        //console.log(\"Zaznaczanie odpowiedzi dla pytania typu skala\");\r\n\r\n        let scaleValue;\r\n        if (typeof correctAnswerObj === \"string\") {\r\n            scaleValue = correctAnswerObj.trim();\r\n        } else if (typeof correctAnswerObj === \"number\") {\r\n            scaleValue = String(correctAnswerObj);\r\n        }\r\n\r\n        if (!scaleValue) {\r\n            //console.log(\"Brak wartości dla skali\");\r\n            return;\r\n        }\r\n\r\n        //console.log(`Wartość skali: ${scaleValue}`);\r\n\r\n        // Find all scale options\r\n        const scaleOptions = questionElement.querySelectorAll('.T5pZmf');\r\n        let targetOption = null;\r\n\r\n        // Find the option with matching value\r\n        for (const option of scaleOptions) {\r\n            const optionValue = option.querySelector('.Zki2Ve')?.textContent.trim();\r\n            if (optionValue === scaleValue) {\r\n                targetOption = option;\r\n                //console.log(`Znaleziono opcję skali: ${optionValue}`);\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (targetOption) {\r\n            if (mode === \"default\") {\r\n                // Visual highlight\r\n                const valueElement = targetOption.querySelector('.Zki2Ve');\r\n                if (valueElement) {\r\n                    valueElement.style.color = \"green\";\r\n                    valueElement.style.fontWeight = \"bold\";\r\n                    //console.log(\"Zastosowano wyróżnienie dla wartości skali\");\r\n                }\r\n            }\r\n            else if (mode === \"immediate\") {\r\n                // Click the radio button\r\n                const radioButton = targetOption.querySelector('.Od2TWd[role=\"radio\"]');\r\n                if (radioButton) {\r\n                    radioButton.click();\r\n                    //console.log(\"Kliknięto przycisk radio dla skali\");\r\n                } else {\r\n                    // Try clicking the whole option\r\n                    targetOption.click();\r\n                    //console.log(\"Kliknięto całą opcję skali\");\r\n                }\r\n            }\r\n            else if (mode === \"savemode\") {\r\n                // Subtle indication - just add a slight border\r\n                const radioCircle = targetOption.querySelector('.AB7Lab.Id5V1');\r\n                if (radioCircle) {\r\n                    radioCircle.style.border = \"2px solid #8f949c\";\r\n                    //console.log(\"Dodano delikatne obramowanie dla opcji skali\");\r\n                }\r\n            }\r\n        } else {\r\n            //console.log(`Nie znaleziono opcji skali o wartości ${scaleValue}`);\r\n        }\r\n    }\r\n    else if (qType === \"date\") {\r\n        //console.log(\"Zaznaczanie odpowiedzi dla pytania typu data\");\r\n\r\n        let dateValue = \"\";\r\n        if (typeof correctAnswerObj === \"string\") {\r\n            // Try to format the date properly (YYYY-MM-DD)\r\n            const dateMatch = correctAnswerObj.match(/(\\d{4})[-.\\/]?(\\d{1,2})[-.\\/]?(\\d{1,2})/);\r\n            if (dateMatch) {\r\n                const year = dateMatch[1];\r\n                const month = dateMatch[2].padStart(2, '0');\r\n                const day = dateMatch[3].padStart(2, '0');\r\n                dateValue = `${year}-${month}-${day}`;\r\n            } else {\r\n                // Try to parse as date string\r\n                try {\r\n                    const date = new Date(correctAnswerObj);\r\n                    if (!isNaN(date.getTime())) {\r\n                        const year = date.getFullYear();\r\n                        const month = (date.getMonth() + 1).toString().padStart(2, '0');\r\n                        const day = date.getDate().toString().padStart(2, '0');\r\n                        dateValue = `${year}-${month}-${day}`;\r\n                    }\r\n                } catch (e) {\r\n                    //console.log(\"Nie można sparsować daty:\", e);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!dateValue) {\r\n            //console.log(\"Brak poprawnej wartości daty\");\r\n            return;\r\n        }\r\n\r\n        //console.log(`Poprawna data: ${dateValue}`);\r\n\r\n        // Find the date input element\r\n        const dateInput = questionElement.querySelector('input[type=\"date\"]');\r\n\r\n        if (dateInput) {\r\n            if (mode === \"default\") {\r\n                // Formatowanie daty do wyświetlenia (DD.MM.YYYY)\r\n                const [year, month, day] = dateValue.split('-');\r\n                const formattedDate = `${day}.${month}.${year}`;\r\n\r\n                // Pobierz tekst \"Poprawna odpowiedź\" w języku przeglądarki\r\n                const correctAnswerText = getCorrectAnswerText();\r\n\r\n                // Znajdź główny kontener pytania (najwyższy element)\r\n                const mainContainer = questionElement.closest('.geS5n') || questionElement;\r\n\r\n                // Usuń istniejące elementy informacyjne, jeśli istnieją\r\n                const existingInfo = mainContainer.querySelector('.correct-answer-info');\r\n                if (existingInfo) {\r\n                    existingInfo.remove();\r\n                }\r\n\r\n                // Utwórz nowy element z odpowiedzią z odpowiednimi stylami (podobnymi do longAnswer)\r\n                const infoElement = document.createElement(\"div\");\r\n                infoElement.classList.add(\"correct-answer-info\");\r\n\r\n                // Style dla kontenera odpowiedzi\r\n                infoElement.style.background = \"#f0fff0\";\r\n                infoElement.style.border = \"1px solid #ddeedd\";\r\n                infoElement.style.borderRadius = \"4px\";\r\n                infoElement.style.marginTop = \"10px\";\r\n                infoElement.style.marginBottom = \"10px\";\r\n                infoElement.style.padding = \"8px 12px\";\r\n                infoElement.style.width = \"100%\";\r\n                infoElement.style.boxSizing = \"border-box\";\r\n                infoElement.style.fontSize = \"14px\";\r\n                infoElement.style.color = \"green\";\r\n\r\n                // Struktura: nagłówek + treść\r\n                infoElement.innerHTML = `\r\n                    <div style=\"font-weight: bold; margin-bottom: 4px;\">${correctAnswerText}</div>\r\n                    <div>${formattedDate}</div>\r\n                `;\r\n\r\n                // Znajdź dobry punkt wstawienia (po całym pytaniu)\r\n                // Szukamy elementu .SL4Sz lub dodajemy po całym kontenerze pytania\r\n                const alertElement = mainContainer.querySelector('.SL4Sz');\r\n                if (alertElement) {\r\n                    // Wstaw przed alertem\r\n                    alertElement.parentNode.insertBefore(infoElement, alertElement);\r\n                } else {\r\n                    // Dodaj na końcu głównego kontenera\r\n                    mainContainer.appendChild(infoElement);\r\n                }\r\n\r\n                //console.log(\"Dodano informację o poprawnej dacie\");\r\n            }\r\n            else if (mode === \"immediate\") {\r\n                // Set the date value\r\n                dateInput.value = dateValue;\r\n                dateInput.dispatchEvent(new Event('input', { bubbles: true }));\r\n                dateInput.dispatchEvent(new Event('change', { bubbles: true }));\r\n                //console.log(`Ustawiono datę na ${dateValue}`);\r\n            }\r\n            else if (mode === \"savemode\") {\r\n                // Add subtle visual cue\r\n                const originalBorder = dateInput.style.border;\r\n                dateInput.dataset.originalBorder = originalBorder;\r\n\r\n                // Add focus event to show correct date as placeholder\r\n                dateInput.addEventListener('focus', function () {\r\n                    this.setAttribute('placeholder', dateValue);\r\n                });\r\n\r\n                dateInput.addEventListener('blur', function () {\r\n                    this.removeAttribute('placeholder');\r\n                });\r\n\r\n                //console.log(\"Dodano podpowiedź dla daty w trybie savemode\");\r\n            }\r\n        } else {\r\n            //console.log(\"Nie znaleziono pola input date\");\r\n        }\r\n    }\r\n    else if (qType === \"time\") {\r\n        //console.log(\"Zaznaczanie odpowiedzi dla pytania typu czas\");\r\n\r\n        let hours = \"\", minutes = \"\";\r\n        if (typeof correctAnswerObj === \"string\") {\r\n            // Parse time format (HH:MM or H:MM)\r\n            const timeMatch = correctAnswerObj.match(/(\\d{1,2}):(\\d{2})/);\r\n            if (timeMatch) {\r\n                hours = timeMatch[1].padStart(2, '0');\r\n                minutes = timeMatch[2];\r\n                //console.log(`Poprawny czas: ${hours}:${minutes}`);\r\n            }\r\n        }\r\n\r\n        if (!hours || !minutes) {\r\n            //console.log(\"Brak poprawnej wartości czasu\");\r\n            return;\r\n        }\r\n\r\n        // Find hour and minute inputs\r\n        const hourInput = questionElement.querySelector('[jsname=\"MKaSrf\"] input');\r\n        const minuteInput = questionElement.querySelector('[jsname=\"QbtXXe\"] input');\r\n\r\n        if (hourInput && minuteInput) {\r\n            if (mode === \"default\") {\r\n                // Pobierz tekst \"Poprawna odpowiedź\" w języku przeglądarki\r\n                const correctAnswerText = getCorrectAnswerText();\r\n\r\n                // Znajdź główny kontener pytania (najwyższy element)\r\n                const mainContainer = questionElement.closest('.geS5n') || questionElement;\r\n\r\n                // Usuń istniejące elementy informacyjne, jeśli istnieją\r\n                const existingInfo = mainContainer.querySelector('.correct-answer-info');\r\n                if (existingInfo) {\r\n                    existingInfo.remove();\r\n                }\r\n\r\n                // Utwórz nowy element z odpowiedzią z odpowiednimi stylami (podobnymi do longAnswer)\r\n                const infoElement = document.createElement(\"div\");\r\n                infoElement.classList.add(\"correct-answer-info\");\r\n\r\n                // Style dla kontenera odpowiedzi\r\n                infoElement.style.background = \"#f0fff0\";\r\n                infoElement.style.border = \"1px solid #ddeedd\";\r\n                infoElement.style.borderRadius = \"4px\";\r\n                infoElement.style.marginTop = \"10px\";\r\n                infoElement.style.marginBottom = \"10px\";\r\n                infoElement.style.padding = \"8px 12px\";\r\n                infoElement.style.width = \"100%\";\r\n                infoElement.style.boxSizing = \"border-box\";\r\n                infoElement.style.fontSize = \"14px\";\r\n                infoElement.style.color = \"green\";\r\n\r\n                // Struktura: nagłówek + treść\r\n                infoElement.innerHTML = `\r\n                    <div style=\"font-weight: bold; margin-bottom: 4px;\">${correctAnswerText}</div>\r\n                    <div>${hours}:${minutes}</div>\r\n                `;\r\n\r\n                // Znajdź dobry punkt wstawienia (po całym pytaniu)\r\n                // Szukamy elementu .SL4Sz lub dodajemy po całym kontenerze pytania\r\n                const alertElement = mainContainer.querySelector('.SL4Sz');\r\n                if (alertElement) {\r\n                    // Wstaw przed alertem\r\n                    alertElement.parentNode.insertBefore(infoElement, alertElement);\r\n                } else {\r\n                    // Dodaj na końcu głównego kontenera\r\n                    mainContainer.appendChild(infoElement);\r\n                }\r\n\r\n                //console.log(\"Dodano informację o poprawnym czasie\");\r\n            }\r\n            else if (mode === \"immediate\") {\r\n                // Set the time values\r\n                hourInput.value = hours;\r\n                hourInput.dispatchEvent(new Event('input', { bubbles: true }));\r\n                hourInput.dispatchEvent(new Event('change', { bubbles: true }));\r\n\r\n                minuteInput.value = minutes;\r\n                minuteInput.dispatchEvent(new Event('input', { bubbles: true }));\r\n                minuteInput.dispatchEvent(new Event('change', { bubbles: true }));\r\n\r\n                //console.log(`Ustawiono czas na ${hours}:${minutes}`);\r\n            }\r\n            else if (mode === \"savemode\") {\r\n                // Add subtle visual cues\r\n                const originalHourBorder = hourInput.style.border;\r\n                const originalMinuteBorder = minuteInput.style.border;\r\n\r\n                hourInput.dataset.originalBorder = originalHourBorder;\r\n                minuteInput.dataset.originalBorder = originalMinuteBorder;\r\n\r\n                // Add focus events\r\n                hourInput.addEventListener('focus', function () {\r\n                    this.setAttribute('placeholder', hours);\r\n                });\r\n\r\n                hourInput.addEventListener('blur', function () {\r\n                    this.removeAttribute('placeholder');\r\n                });\r\n\r\n                minuteInput.addEventListener('focus', function () {\r\n                    this.setAttribute('placeholder', minutes);\r\n                });\r\n\r\n                minuteInput.addEventListener('blur', function () {\r\n                    this.removeAttribute('placeholder');\r\n                });\r\n\r\n                //console.log(\"Dodano podpowiedź dla czasu w trybie savemode\");\r\n            }\r\n        } else {\r\n            //console.log(\"Nie znaleziono pól input dla godziny i minuty\");\r\n        }\r\n    }\r\n    else if (qType === \"checkboxGrid\") {\r\n        //console.log(\"Zaznaczanie odpowiedzi dla pytania typu checkboxGrid\");\r\n\r\n        try {\r\n            // Process the answer format\r\n            let answerMapping = {};\r\n\r\n            if (typeof correctAnswerObj === 'object' && !Array.isArray(correctAnswerObj) && correctAnswerObj !== null) {\r\n                // Format: {A: [\"1\", \"3\"], B: [\"2\"]} or nested object\r\n                if (correctAnswerObj.value && typeof correctAnswerObj.value === \"object\") {\r\n                    answerMapping = correctAnswerObj.value;\r\n                } else {\r\n                    answerMapping = correctAnswerObj;\r\n                }\r\n                //console.log(\"Przetworzono odpowiedź w formacie obiektowym:\", answerMapping);\r\n            }\r\n            else if (typeof correctAnswerObj === 'string') {\r\n                // Try to parse JSON\r\n                try {\r\n                    const parsed = JSON.parse(correctAnswerObj);\r\n                    if (typeof parsed === 'object' && parsed !== null) {\r\n                        answerMapping = parsed;\r\n                        //console.log(\"Przetworzono odpowiedź z parsowania JSON:\", answerMapping);\r\n                    }\r\n                } catch (e) {\r\n                    //console.log(\"Nie udało się sparsować odpowiedzi jako JSON:\", e);\r\n                }\r\n            }\r\n\r\n            // Get all rows in the grid\r\n            const rows = questionElement.querySelectorAll('.mxSrOe');\r\n            //console.log(`Znaleziono ${rows.length} wierszy w grid`);\r\n\r\n            // Process each row\r\n            unifiedQuestion.statements.forEach((statement, rowIndex) => {\r\n                if (rowIndex >= rows.length) {\r\n                    //console.log(`Brak elementu wiersza dla ${statement.id}`);\r\n                    return;\r\n                }\r\n\r\n                const row = rows[rowIndex];\r\n                const selectedColumns = answerMapping[statement.id];\r\n\r\n                if (!selectedColumns || !Array.isArray(selectedColumns)) {\r\n                    //console.log(`Brak lub niepoprawna wartość dla wiersza ${statement.id}`);\r\n                    return;\r\n                }\r\n\r\n                //console.log(`Wiersz ${statement.id}: wybrano kolumny ${selectedColumns.join(', ')}`);\r\n\r\n                // Get checkboxes in this row\r\n                const checkboxes = row.querySelectorAll('.uVccjd[role=\"checkbox\"]');\r\n\r\n                // Mark each selected checkbox in this row\r\n                selectedColumns.forEach(columnValue => {\r\n                    // Convert to numeric index (0-based)\r\n                    let columnIndex;\r\n\r\n                    // Try to parse as numeric\r\n                    if (!isNaN(parseInt(columnValue))) {\r\n                        columnIndex = parseInt(columnValue) - 1; // Convert 1-based to 0-based\r\n                    } else {\r\n                        // Try to find by label/id\r\n                        columnIndex = unifiedQuestion.commonOptions.findIndex(\r\n                            opt => opt.id.toUpperCase() === columnValue.toUpperCase()\r\n                        );\r\n                    }\r\n\r\n                    if (columnIndex >= 0 && columnIndex < checkboxes.length) {\r\n                        const checkbox = checkboxes[columnIndex];\r\n\r\n                        if (mode === \"default\") {\r\n                            // Visual highlight\r\n                            checkbox.style.outline = \"2px solid green\";\r\n                            //console.log(`Wiersz ${rowIndex + 1}: wyróżniono checkbox ${columnIndex + 1}`);\r\n                        }\r\n                        else if (mode === \"immediate\") {\r\n                            // Click the checkbox\r\n                            checkbox.click();\r\n                            //console.log(`Wiersz ${rowIndex + 1}: kliknięto checkbox ${columnIndex + 1}`);\r\n                        }\r\n                        else if (mode === \"savemode\") {\r\n                            // Subtle indication\r\n                            checkbox.style.outline = \"1px solid #d7d9db\";\r\n                            //console.log(`Wiersz ${rowIndex + 1}: delikatnie wyróżniono checkbox ${columnIndex + 1}`);\r\n                        }\r\n                    } else {\r\n                        //console.log(`Wiersz ${rowIndex + 1}: indeks kolumny ${columnIndex} poza zakresem`);\r\n                    }\r\n                });\r\n            });\r\n\r\n        } catch (error) {\r\n            //console.log(\"Błąd podczas zaznaczania odpowiedzi checkboxGrid:\", error);\r\n        }\r\n    }\r\n    else if (qType === \"likert\") {\r\n        //console.log(\"Zaznaczanie odpowiedzi dla pytania typu grid/likert\");\r\n\r\n        try {\r\n            // Przetwarzanie odpowiedzi z backendu\r\n            let answerMapping = {};\r\n\r\n            // Obsługa różnych formatów odpowiedzi\r\n            if (correctAnswerObj && correctAnswerObj.value && typeof correctAnswerObj.value === \"string\") {\r\n                // Format: {value: \"1,2,3,4,\", answerRepresentation: \"numeric\"}\r\n                const numericValues = correctAnswerObj.value.split(',').filter(v => v.trim() !== \"\");\r\n                //console.log(\"Wartości numeryczne:\", numericValues);\r\n\r\n                // Utwórz mapowanie z numeru kolumny na ID\r\n                let mapping = {};\r\n                if (unifiedQuestion.commonOptions && unifiedQuestion.commonOptions.length > 0) {\r\n                    unifiedQuestion.commonOptions.forEach((opt, idx) => {\r\n                        mapping[idx + 1] = opt.id;\r\n                    });\r\n                }\r\n\r\n                // Przypisz wartości numeryczne do poszczególnych wierszy\r\n                unifiedQuestion.statements.forEach((stmt, idx) => {\r\n                    if (idx < numericValues.length) {\r\n                        answerMapping[stmt.id] = numericValues[idx];\r\n                    }\r\n                });\r\n\r\n                //console.log(\"Zmapowane odpowiedzi:\", answerMapping);\r\n            }\r\n            else if (typeof correctAnswerObj === 'object' && !Array.isArray(correctAnswerObj) && correctAnswerObj !== null) {\r\n                // Format: obiekt {A: \"1\", B: \"2\", ...} lub obiekt w obiekcie {value: {A: \"1\", B: \"2\"}}\r\n                if (correctAnswerObj.value && typeof correctAnswerObj.value === \"object\") {\r\n                    answerMapping = correctAnswerObj.value;\r\n                } else {\r\n                    answerMapping = correctAnswerObj;\r\n                }\r\n                //console.log(\"Przetworzono odpowiedź w formacie obiektowym:\", answerMapping);\r\n            }\r\n            else if (typeof correctAnswerObj === 'string') {\r\n                // Próba parsowania JSON\r\n                try {\r\n                    const parsed = JSON.parse(correctAnswerObj);\r\n                    if (typeof parsed === 'object' && parsed !== null) {\r\n                        answerMapping = parsed;\r\n                        //console.log(\"Przetworzono odpowiedź z parsowania JSON:\", answerMapping);\r\n                    }\r\n                } catch (e) {\r\n                    //console.log(\"Nie udało się sparsować odpowiedzi jako JSON:\", e);\r\n                }\r\n            }\r\n\r\n            // Znajdź wszystkie wiersze (radiogroup) w siatce\r\n            const rowElements = questionElement.querySelectorAll('.lLfZXe[role=\"radiogroup\"]');\r\n            //console.log(`Znaleziono ${rowElements.length} wierszy radiogroup`);\r\n\r\n            // Dla każdego zdefiniowanego wiersza\r\n            unifiedQuestion.statements.forEach((statement, rowIndex) => {\r\n                if (rowIndex >= rowElements.length) {\r\n                    //console.log(`Brak elementu wiersza dla ${statement.id}`);\r\n                    return;\r\n                }\r\n\r\n                const rowElement = rowElements[rowIndex];\r\n                const correctColumnValue = answerMapping[statement.id];\r\n\r\n                if (!correctColumnValue) {\r\n                    //console.log(`Brak wartości dla wiersza ${statement.id}`);\r\n                    return;\r\n                }\r\n\r\n                // Konwersja na indeks kolumny (jeśli to liczba)\r\n                let columnIndex = parseInt(correctColumnValue) - 1;\r\n\r\n                // Jeśli to nie liczba (np. \"A\", \"B\"), spróbuj znaleźć po etykiecie\r\n                if (isNaN(columnIndex)) {\r\n                    const optionIndex = unifiedQuestion.commonOptions.findIndex(\r\n                        opt => opt.id.toUpperCase() === correctColumnValue.toUpperCase()\r\n                    );\r\n                    if (optionIndex >= 0) {\r\n                        columnIndex = optionIndex;\r\n                    }\r\n                }\r\n\r\n                //console.log(`Wiersz ${statement.id}: wybrano kolumnę ${columnIndex + 1}`);\r\n\r\n                // Znajdź odpowiedni przycisk radiowy w tym wierszu\r\n                const radioButtons = rowElement.querySelectorAll('.Od2TWd[role=\"radio\"]');\r\n\r\n                if (columnIndex >= 0 && columnIndex < radioButtons.length) {\r\n                    const correctRadio = radioButtons[columnIndex];\r\n\r\n                    if (mode === \"default\") {\r\n                        // Znajdź element kółka w przycisku radiowym\r\n                        const radioCircle = correctRadio.querySelector('.AB7Lab.Id5V1');\r\n                        if (radioCircle) {\r\n                            // Stylowanie obramowania elementu kółka na zielono\r\n                            radioCircle.style.border = \"3px solid green\";\r\n                            //console.log(`Wiersz ${rowIndex + 1}: wyróżniono kółko odpowiedzi ${columnIndex + 1} na zielono`);\r\n                        } else {\r\n                            // Jeśli nie znaleziono elementu kółka, zastosuj styl do całego przycisku radio\r\n                            correctRadio.style.border = \"3px solid green\";\r\n                            //console.log(`Wiersz ${rowIndex + 1}: wyróżniono odpowiedź ${columnIndex + 1} zieloną ramką`);\r\n                        }\r\n                    }\r\n                    else if (mode === \"immediate\") {\r\n                        correctRadio.click();\r\n                        //console.log(`Wiersz ${rowIndex + 1}: kliknięto odpowiedź ${columnIndex + 1}`);\r\n                    }\r\n                    else if (mode === \"savemode\") {\r\n                        const radioCircle = correctRadio.querySelector('.AB7Lab.Id5V1');\r\n                        if (radioCircle) {\r\n                            radioCircle.style.border = \"2px solid #8f949c\";\r\n                            //console.log(`Wiersz ${rowIndex + 1}: wyróżniono kółko odpowiedzi ${columnIndex + 1} na jasnoszaro`);\r\n                        } else {\r\n                            correctRadio.style.border = \"2px solid #8f949c\";\r\n                            //console.log(`Wiersz ${rowIndex + 1}: wyróżniono odpowiedź ${columnIndex + 1} jasnoszarą ramką`);\r\n                        }\r\n                    }\r\n\r\n                } else {\r\n                    //console.log(`Wiersz ${rowIndex + 1}: indeks kolumny ${columnIndex} poza zakresem (liczba przycisków: ${radioButtons.length})`);\r\n                }\r\n            });\r\n\r\n        } catch (error) {\r\n            //console.log(\"Błąd podczas zaznaczania odpowiedzi grid:\", error);\r\n        }\r\n    }\r\n}\r\n\r\n/*************************************************\r\n * 7. PROCESS INDIVIDUAL QUESTION\r\n *************************************************/\r\nasync function handleQuestionGoogleForms(questionElement, mode) {\r\n    // === POCZĄTEK SUGEROWANEJ ZMIANY ===\r\n\r\n    // Sprawdź, czy pytanie nie zostało już przetworzone, aby uniknąć duplikatów zapytań API.\r\n    if (questionElement.dataset.alreadyHandled === 'true') {\r\n        return null;\r\n    }\r\n    // Ustaw flagę natychmiast, aby zablokować kolejne wywołania dla tego samego pytania.\r\n    questionElement.dataset.alreadyHandled = 'true';\r\n\r\n    // === KONIEC SUGEROWANEJ ZMIANY ===\r\n\r\n    const unifiedQuestion = await buildUnifiedQuestion(questionElement);\r\n    if (!unifiedQuestion) {\r\n        // Pytanie jest nieprawidłowe (np. pole na imię) lub nie udało się go przetworzyć.\r\n        // Flaga pozostaje, aby nie próbować go przetwarzać ponownie.\r\n        return null;\r\n    }\r\n\r\n    const isMultipleCorrect = unifiedQuestion.type === \"multiple\";\r\n\r\n    try {\r\n        const response = await sendQuestionToChatGPTGoogleForms(unifiedQuestion, isMultipleCorrect);\r\n\r\n        if (response && response.correctAnswer) {\r\n            markCorrectAnswer(questionElement, response.correctAnswer, unifiedQuestion, mode);\r\n            return unifiedQuestion;\r\n        } else {\r\n            // Jeśli nie ma odpowiedzi, ale zapytanie się powiodło, nie usuwamy flagi.\r\n            return null;\r\n        }\r\n    } catch (error) {\r\n        // W przypadku błędu (np. problem z siecią), usuwamy flagę,\r\n        // aby umożliwić ponowną próbę przetworzenia pytania w przyszłości.\r\n        delete questionElement.dataset.alreadyHandled;\r\n        console.error(\"Błąd wysyłania pytania do backendu:\", error);\r\n        return null;\r\n    }\r\n}\r\n\r\n/*************************************************\r\n * 8. MAIN PROCESSING FUNCTION\r\n *************************************************/\r\nexport async function processGoogleForms() {\r\n    try {\r\n        const { markingMode } = await new Promise((resolve) => {\r\n            chrome.storage.local.get(['markingMode'], (result) => {\r\n                resolve({ markingMode: result.markingMode || 'default' });\r\n            });\r\n        });\r\n\r\n        let questions = document.querySelectorAll('.Qr7Oae[role=\"listitem\"]');\r\n        if (questions.length === 0) {\r\n            const altSelectors = [\r\n                '.freebirdFormviewerViewItemsItemItem',\r\n                '.freebirdFormviewerViewNumberedItemContainer',\r\n                '[role=\"listitem\"]'\r\n            ];\r\n            for (const selector of altSelectors) {\r\n                const altQuestions = document.querySelectorAll(selector);\r\n                if (altQuestions.length > 0) {\r\n                    questions = altQuestions;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (questions.length === 0) {\r\n            // console.log(\"Nie znaleziono żadnych pytań na stronie Google Forms.\");\r\n            return [];\r\n        }\r\n\r\n        // === POCZĄTEK SUGEROWANEJ ZMIANY ===\r\n\r\n        // Przetwarzaj wszystkie pytania równolegle, aby znacznie przyspieszyć działanie.\r\n        const processingPromises = Array.from(questions).map(questionElement =>\r\n            handleQuestionGoogleForms(questionElement, markingMode)\r\n        );\r\n\r\n        // Poczekaj na zakończenie przetwarzania wszystkich pytań.\r\n        const results = await Promise.all(processingPromises);\r\n\r\n        // Przefiltruj wyniki, aby policzyć tylko te pomyślnie przetworzone.\r\n        const successfulResults = results.filter(r => r !== null);\r\n\r\n        document.body.style.cursor = 'default';\r\n        // console.log(`Przetworzono ${successfulResults.length} z ${questions.length} pytań pomyślnie`);\r\n\r\n        return successfulResults;\r\n\r\n        // === KONIEC SUGEROWANEJ ZMIANY (usuń starą pętlę for) ===\r\n\r\n    } catch (error) {\r\n        document.body.style.cursor = 'default';\r\n        console.error(`Krytyczny błąd w processGoogleForms: ${error.message}`);\r\n        return [];\r\n    }\r\n}\r\n\r\n ","import { sendQuestionToBackendNaurok } from '../core/api.js';\r\n\r\n/*************************************************\r\n * STAN GLOBALNY\r\n *************************************************/\r\n// Flaga do śledzenia czy przetwarzanie jest aktywne\r\nlet isNaurokProcessingActive = false;\r\n// Śledzenie ostatniego pytania\r\nlet lastQuestionContent = '';\r\n\r\n/*************************************************\r\n * HELPER FUNCTIONS\r\n *************************************************/\r\n\r\n// Funkcja do czyszczenia stylów zastosowanych we wcześniejszych pytaniach\r\nfunction resetStyles(container) {\r\n    // Resetujemy style dla elementów odpowiedzi\r\n    const optionElements = container.querySelectorAll('.question-option-inner');\r\n    optionElements.forEach(element => {\r\n        element.style.border = '';\r\n        element.style.backgroundColor = '';\r\n        element.style.outline = '';\r\n    });\r\n\r\n    // Resetujemy style dla obrazków\r\n    const imageElements = container.querySelectorAll('.question-option-image');\r\n    imageElements.forEach(element => {\r\n        element.style.border = '';\r\n        element.style.boxShadow = '';\r\n        element.style.outline = '';\r\n    });\r\n}\r\n\r\n// Function to extract background-image URL from style attribute\r\nfunction extractBackgroundImageUrl(element) {\r\n    if (!element) return null;\r\n\r\n    const style = element.getAttribute('style');\r\n    if (!style) return null;\r\n\r\n    const match = style.match(/background-image\\s*:\\s*url\\s*\\(\\s*[\"']?([^\"')]+)[\"']?\\s*\\)/i);\r\n    return match ? match[1] : null;\r\n}\r\n\r\n/*************************************************\r\n * 1. QUESTION TYPE DETECTION\r\n *************************************************/\r\nfunction detectQuestionTypeNaurok(questionContainer) {\r\n    const questionType = questionContainer.querySelector('.question-option-inner[ng-if=\"test.question.type == \\'quiz\\'\"]')\r\n        ? 'singleChoice'\r\n        : questionContainer.querySelector('.question-option-inner[ng-if=\"test.question.type == \\'multiquiz\\'\"]')\r\n            ? 'multipleChoice'\r\n            : 'unknown';\r\n    return questionType;\r\n}\r\n\r\n/*************************************************\r\n * 2. QUESTION TEXT EXTRACTION\r\n *************************************************/\r\nasync function extractQuestionTextNaurok(questionContainer) {\r\n    const contentElement = questionContainer.querySelector('.test-content-text-inner');\r\n    let questionText = \"\";\r\n\r\n    if (contentElement) {\r\n        questionText = contentElement.innerText.trim();\r\n    }\r\n\r\n    const imageContainer = questionContainer.querySelector('.test-content-image');\r\n    let images = [];\r\n\r\n    if (imageContainer && !imageContainer.classList.contains('ng-hide')) {\r\n        const img = imageContainer.querySelector('img');\r\n        if (img && !img.classList.contains('ng-hide') && img.src) {\r\n            images.push({\r\n                url: img.src,\r\n                alt: img.alt || \"\"\r\n            });\r\n        }\r\n    }\r\n    return { text: questionText, images };\r\n}\r\n\r\n/*************************************************\r\n * 3. EXTRACT ANSWERS FOR CHOICE QUESTIONS\r\n *************************************************/\r\nasync function extractChoiceAnswersNaurok(questionContainer) {\r\n    const optionElements = questionContainer.querySelectorAll('.test-option');\r\n    const options = [];\r\n    const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n\r\n    for (let i = 0; i < optionElements.length; i++) {\r\n        const optionElement = optionElements[i];\r\n        let answerText = \"\";\r\n        let images = [];\r\n\r\n        const contentElement = optionElement.querySelector('.question-option-inner-content');\r\n        if (contentElement) {\r\n            answerText = contentElement.innerText.trim();\r\n        }\r\n\r\n        const imageElement = optionElement.querySelector('.question-option-image');\r\n        if (imageElement) {\r\n            const imageUrl = extractBackgroundImageUrl(imageElement);\r\n            if (imageUrl) {\r\n                images.push({\r\n                    url: imageUrl,\r\n                    alt: `Option ${letters[i]} image`\r\n                });\r\n            }\r\n        }\r\n\r\n        const id = letters[i] || String(i + 1);\r\n        options.push({\r\n            id,\r\n            label: answerText || `Option ${id}`,\r\n            images\r\n        });\r\n    }\r\n    return options;\r\n}\r\n\r\n/*************************************************\r\n * 4. BUILD UNIFIED QUESTION\r\n *************************************************/\r\nasync function buildUnifiedQuestionNaurok(questionContainer) {\r\n    const detectedType = detectQuestionTypeNaurok(questionContainer);\r\n    const { text, images } = await extractQuestionTextNaurok(questionContainer);\r\n\r\n    if (!text && images.length === 0) { // Zmodyfikowano warunek - puste pytanie tekstowe jest OK jeśli jest obrazek\r\n        console.log(\"Brak tekstu pytania i obrazków, pomijam budowanie.\");\r\n        return null;\r\n    }\r\n\r\n    let unified = {\r\n        id: Date.now().toString(),\r\n        text,\r\n        images,\r\n        metadata: { difficulty: \"unknown\" }\r\n    };\r\n\r\n    switch (detectedType) {\r\n        case \"singleChoice\":\r\n            unified.type = \"singlechoice\";\r\n            unified.options = await extractChoiceAnswersNaurok(questionContainer);\r\n            unified.format = {\r\n                responseType: \"optionId\",\r\n                description: \"Odpowiedz jako pojedyncza litera odpowiadająca właściwej opcji.\"\r\n            };\r\n            break;\r\n        case \"multipleChoice\":\r\n            unified.type = \"multiple\";\r\n            unified.options = await extractChoiceAnswersNaurok(questionContainer);\r\n            unified.format = {\r\n                responseType: \"optionIds\",\r\n                description: \"Odpowiedz jako tablica liter odpowiadających właściwym opcjom (np. [\\\"A\\\", \\\"C\\\"]).\"\r\n            };\r\n            break;\r\n        default:\r\n            console.log(\"Nieznany typ pytania:\", detectedType);\r\n            return null;\r\n    }\r\n    return unified;\r\n}\r\n\r\n/*************************************************\r\n * 5. MARK CORRECT ANSWER\r\n *************************************************/\r\nfunction markCorrectAnswerNaurok(questionContainer, correctAnswerObj, unifiedQuestion, mode) {\r\n    const qType = unifiedQuestion.type;\r\n    mode = mode.toLowerCase();\r\n\r\n    if (qType === \"singlechoice\") {\r\n        let correctIndex = -1;\r\n        if (typeof correctAnswerObj === \"string\") {\r\n            const correctLetter = correctAnswerObj.trim().toUpperCase();\r\n            const optionIds = unifiedQuestion.options.map(opt => opt.id.toUpperCase());\r\n            correctIndex = optionIds.indexOf(correctLetter);\r\n        }\r\n\r\n        const optionElements = questionContainer.querySelectorAll('.test-option');\r\n        if (correctIndex >= 0 && correctIndex < optionElements.length) {\r\n            const correctElement = optionElements[correctIndex];\r\n            const innerElement = correctElement.querySelector('.question-option-inner');\r\n\r\n            if (innerElement) {\r\n                if (mode === \"default\") {\r\n                    innerElement.style.border = \"3px solid green\";\r\n                    innerElement.style.backgroundColor = \"rgba(0, 128, 0, 0.1)\";\r\n                    const imageElement = innerElement.querySelector('.question-option-image');\r\n                    if (imageElement) {\r\n                        imageElement.style.boxShadow = \"0 0 8px 2px rgba(0, 128, 0, 0.5)\";\r\n                    }\r\n                } else if (mode === \"immediate\") {\r\n                    innerElement.click();\r\n                } else if (mode === \"savemode\") {\r\n                    innerElement.style.border = \"1px solid rgba(0, 128, 0, 0.3)\";\r\n                    const imageElement = innerElement.querySelector('.question-option-image');\r\n                    if (imageElement) {\r\n                        imageElement.style.border = \"1px solid rgba(0, 128, 0, 0.2)\";\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else if (qType === \"multiple\") {\r\n        let correctIndices = [];\r\n        if (Array.isArray(correctAnswerObj)) {\r\n            const correctLetters = correctAnswerObj.map(letter => letter.toUpperCase());\r\n            const optionIds = unifiedQuestion.options.map(opt => opt.id.toUpperCase());\r\n            correctLetters.forEach(letter => {\r\n                const index = optionIds.indexOf(letter);\r\n                if (index >= 0) {\r\n                    correctIndices.push(index);\r\n                }\r\n            });\r\n        } else if (typeof correctAnswerObj === \"string\") {\r\n            const parts = correctAnswerObj.split(',');\r\n            for (const part of parts) {\r\n                const letter = part.trim().toUpperCase();\r\n                const index = unifiedQuestion.options.findIndex(opt => opt.id.toUpperCase() === letter);\r\n                if (index >= 0) {\r\n                    correctIndices.push(index);\r\n                }\r\n            }\r\n        }\r\n\r\n        const optionElements = questionContainer.querySelectorAll('.test-option');\r\n        correctIndices.forEach(index => {\r\n            if (index >= 0 && index < optionElements.length) {\r\n                const correctElement = optionElements[index];\r\n                const innerElement = correctElement.querySelector('.question-option-inner');\r\n                if (innerElement) {\r\n                    if (mode === \"default\") {\r\n                        innerElement.style.border = \"3px solid green\";\r\n                        innerElement.style.backgroundColor = \"rgba(0, 128, 0, 0.1)\";\r\n                        const imageElement = innerElement.querySelector('.question-option-image');\r\n                        if (imageElement) {\r\n                            imageElement.style.boxShadow = \"0 0 8px 2px rgba(0, 128, 0, 0.5)\";\r\n                        }\r\n                    } else if (mode === \"immediate\") {\r\n                        innerElement.click();\r\n                    } else if (mode === \"savemode\") {\r\n                        innerElement.style.border = \"1px solid rgba(0, 128, 0, 0.3)\";\r\n                        const imageElement = innerElement.querySelector('.question-option-image');\r\n                        if (imageElement) {\r\n                            imageElement.style.border = \"1px solid rgba(0, 128, 0, 0.2)\";\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n/*************************************************\r\n * 6. PROCESS INDIVIDUAL QUESTION\r\n *************************************************/\r\nasync function handleQuestionNaurok(questionContainer, mode) {\r\n    // resetStyles jest teraz wywoływane wcześniej w processNaurok\r\n    // ale jeśli handleQuestionNaurok byłoby kiedyś wywołane bezpośrednio,\r\n    // można by tu zostawić resetStyles(questionContainer); jako zabezpieczenie.\r\n    // Na razie, dla spójności z optymalizacją, zakładamy, że reset jest już zrobiony.\r\n\r\n    const unifiedQuestion = await buildUnifiedQuestionNaurok(questionContainer);\r\n    if (!unifiedQuestion) {\r\n        return null;\r\n    }\r\n\r\n    const isMultipleCorrect = unifiedQuestion.type === \"multiple\";\r\n\r\n    try {\r\n        const response = await sendQuestionToBackendNaurok(unifiedQuestion, isMultipleCorrect);\r\n        if (response && response.correctAnswer) {\r\n            markCorrectAnswerNaurok(questionContainer, response.correctAnswer, unifiedQuestion, mode);\r\n            return unifiedQuestion;\r\n        } else {\r\n            console.log(\"Brak poprawnej odpowiedzi z backendu lub odpowiedź niekompletna.\");\r\n            return null;\r\n        }\r\n    } catch (error) {\r\n        console.error(\"Błąd wysyłania pytania do backendu:\", error);\r\n        return null;\r\n    }\r\n}\r\n\r\n/*************************************************\r\n * 7. MAIN PROCESSING FUNCTION\r\n *************************************************/\r\nexport async function processNaurok() {\r\n    if (isNaurokProcessingActive) {\r\n        console.log(\"Przetwarzanie Naurok już aktywne, pomijam.\");\r\n        return [];\r\n    }\r\n    isNaurokProcessingActive = true;\r\n\r\n    try {\r\n        const { markingMode } = await new Promise((resolve) => {\r\n            chrome.storage.local.get(['markingMode'], (result) => {\r\n                resolve({ markingMode: result.markingMode || 'default' });\r\n            });\r\n        });\r\n\r\n        const questionContainer = document.querySelector('.test-container-inner[ng-show=\"test.scene == 1\"]');\r\n        if (!questionContainer) {\r\n            console.log(\"Nie znaleziono kontenera pytania Naurok.\");\r\n            // Flaga isNaurokProcessingActive zostanie zresetowana w bloku finally\r\n            return [];\r\n        }\r\n\r\n        // OPTYMALIZACJA 1: Natychmiastowe resetowanie stylów\r\n        // Wywołaj resetStyles zaraz po znalezieniu nowego kontenera pytania,\r\n        // aby usunąć podświetlenie ze starego pytania tak szybko, jak to możliwe.\r\n        resetStyles(questionContainer);\r\n\r\n        // OPTYMALIZACJA 2: Znaczące zredukowanie lub usunięcie stałego opóźnienia\r\n        // To opóźnienie było głównym wąskim gardłem po stronie frontendu.\r\n        // Zmniejszono z 1000ms do 100ms. Testuj, czy mniejsza wartość (lub 0ms)\r\n        // nadal pozwala na poprawne załadowanie i ekstrakcję danych pytania.\r\n        // Jeśli pytania ładują się bardzo szybko, to opóźnienie może nie być potrzebne.\r\n        const formLoadDelay = 100; // ms\r\n        if (formLoadDelay > 0) {\r\n             console.log(`Czekam ${formLoadDelay}ms na załadowanie formularza (można testować mniejsze wartości).`);\r\n             await new Promise(resolve => setTimeout(resolve, formLoadDelay));\r\n        }\r\n\r\n\r\n        try {\r\n            const qData = await handleQuestionNaurok(questionContainer, markingMode);\r\n            document.body.style.cursor = 'default';\r\n            return qData ? [qData] : [];\r\n        } catch (err) {\r\n            console.error(`Błąd przetwarzania pytania: ${err.message}`);\r\n            document.body.style.cursor = 'default';\r\n            return [];\r\n        }\r\n    } catch (error) {\r\n        document.body.style.cursor = 'default';\r\n        console.error(`Krytyczny błąd w processNaurok: ${error.message}`);\r\n        return [];\r\n    } finally {\r\n        // Opóźnij resetowanie flagi, aby zapobiec natychmiastowemu ponownemu wywołaniu\r\n        // i dać czas na ustabilizowanie się DOM po przetworzeniu.\r\n        setTimeout(() => {\r\n            isNaurokProcessingActive = false;\r\n        }, 300); // Zmniejszono z 500ms, można dalej testować\r\n    }\r\n}\r\n\r\nfunction debounce(func, wait) {\r\n    let timeout;\r\n    return function (...args) {\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(() => func.apply(this, args), wait);\r\n    };\r\n}\r\n\r\nexport function setupNaurokObserver() {\r\n    function getCurrentQuestionSignature() {\r\n        const questionElement = document.querySelector('.test-content-text-inner');\r\n        const optionsElements = document.querySelectorAll('.test-option');\r\n        let signature = questionElement ? questionElement.textContent.trim() : '';\r\n\r\n        if (optionsElements.length > 0) {\r\n            signature += '|OPTIONS|';\r\n            optionsElements.forEach(option => {\r\n                const content = option.querySelector('.question-option-inner-content');\r\n                if (content) {\r\n                    signature += content.textContent.trim() + ';';\r\n                }\r\n            });\r\n        }\r\n        return signature;\r\n    }\r\n\r\n    let isProcessing = false;\r\n\r\n    const debouncedProcess = debounce(async () => {\r\n        // Sprawdzamy obie flagi: isProcessing (lokalna dla observera)\r\n        // oraz isNaurokProcessingActive (globalna dla głównej logiki przetwarzania)\r\n        if (isProcessing || isNaurokProcessingActive) {\r\n            // console.log(\"DebouncedProcess: Pomijam, przetwarzanie już aktywne.\");\r\n            return;\r\n        }\r\n\r\n        const currentSignature = getCurrentQuestionSignature();\r\n\r\n        if (currentSignature && currentSignature !== lastQuestionContent) {\r\n            // console.log(\"DebouncedProcess: Nowa sygnatura pytania, rozpoczynam przetwarzanie.\");\r\n            isProcessing = true;\r\n            lastQuestionContent = currentSignature;\r\n\r\n            try {\r\n                await processNaurok();\r\n            } finally {\r\n                // Resetowanie flagi isProcessing z opóźnieniem, aby uniknąć\r\n                // natychmiastowego ponownego przetworzenia przy szybkich zmianach DOM.\r\n                setTimeout(() => {\r\n                    isProcessing = false;\r\n                    // console.log(\"DebouncedProcess: Flaga isProcessing zresetowana.\");\r\n                }, 300); // Zmniejszono z 500ms, można dalej testować\r\n            }\r\n        } else if (!currentSignature) {\r\n            // console.log(\"DebouncedProcess: Brak sygnatury pytania.\");\r\n        } else {\r\n            // console.log(\"DebouncedProcess: Sygnatura pytania bez zmian.\");\r\n        }\r\n    }, 250); // Zmniejszono debounce z 300ms, dostosuj w zależności od szybkości zmian na stronie\r\n\r\n    const observer = new MutationObserver(() => {\r\n        // console.log(\"MutationObserver: Wykryto mutację.\");\r\n        debouncedProcess();\r\n    });\r\n\r\n    const container = document.querySelector('.test-screen');\r\n    if (container) {\r\n        observer.observe(container, {\r\n            childList: true,\r\n            subtree: true,\r\n            attributeFilter: ['class', 'style'], // Obserwuj tylko zmiany klas i stylów\r\n            characterData: false // Nie obserwuj bezpośrednich zmian tekstu\r\n        });\r\n        // console.log(\"Obserwator Naurok został pomyślnie skonfigurowany.\");\r\n    } else {\r\n        console.error(\"Nie znaleziono kontenera .test-screen do obserwacji.\");\r\n    }\r\n\r\n    return observer;\r\n}","\r\n\r\n\r\nimport { sendQuestionToBackendVseosvita } from '../core/api';\r\n// Also listen for URL changes to handle SPA navigation\r\nlet lastUrl = location.href;\r\nnew MutationObserver(() => {\r\n    if (location.href !== lastUrl) {\r\n        lastUrl = location.href;\r\n        ////(`URL zmienił się na ${location.href}, ponowne przetwarzanie formularza...`);\r\n\r\n        setTimeout(() => {\r\n            ////(\"Rozpoczęcie ponownego przetwarzania po zmianie URL...\");\r\n            processGoogleForms().then(results => {\r\n                ////(`Po zmianie URL przetworzono ${results.length} pytań`);\r\n            }).catch(err => {\r\n                ////(`Błąd przetwarzania po zmianie URL: ${err.message}`);\r\n            });\r\n        }, 2000);\r\n    }\r\n}).observe(document, { subtree: true, childList: true });\r\n\r\n/*************************************************\r\n * HELPER FUNCTIONS\r\n *************************************************/\r\n\r\n// Function to wait for an image to load\r\nasync function waitForImageLoad(img, timeout = 5000) {\r\n    return new Promise(resolve => {\r\n        if (img.complete && img.naturalWidth !== 0) {\r\n            return resolve();\r\n        }\r\n        const timer = setTimeout(resolve, timeout);\r\n        img.addEventListener(\"load\", () => {\r\n            clearTimeout(timer);\r\n            resolve();\r\n        });\r\n        img.addEventListener(\"error\", () => {\r\n            clearTimeout(timer);\r\n            resolve();\r\n        });\r\n    });\r\n}\r\n\r\n// Extract images from an element\r\nasync function extractImages(element) {\r\n    const imageElements = element.querySelectorAll('img');\r\n    const images = [];\r\n    for (const img of imageElements) {\r\n        await waitForImageLoad(img);\r\n        images.push({\r\n            url: img.src,\r\n            alt: img.alt || \"\"\r\n        });\r\n    }\r\n    return images;\r\n}\r\n\r\n// Extract mathematical content if present\r\nfunction extractMathContent(element, timeout = 300) {\r\n    const pollInterval = 10;\r\n    const startTime = Date.now();\r\n    return new Promise((resolve) => {\r\n        function poll() {\r\n            // Look for math elements in Google Forms\r\n            const mathElements = element.querySelectorAll('.mathml, .katex, [data-math]');\r\n            if (mathElements.length > 0 || (Date.now() - startTime) >= timeout) {\r\n                let mathContent = \"\";\r\n                mathElements.forEach(mathEl => {\r\n                    if (mathEl.hasAttribute('data-math')) {\r\n                        mathContent += \" \" + mathEl.getAttribute('data-math').trim();\r\n                    } else if (mathEl.innerText && mathEl.innerText.trim().length > 0) {\r\n                        mathContent += \" \" + mathEl.innerText.trim();\r\n                    }\r\n                });\r\n\r\n                // Look for LaTeX in HTML\r\n                const rawHTML = element.innerHTML;\r\n                const latexRegex = /\\$(.*?)\\$/g;\r\n                let match;\r\n                while ((match = latexRegex.exec(rawHTML)) !== null) {\r\n                    if (match[1] && match[1].trim().length > 0) {\r\n                        mathContent += \" \" + match[1].trim();\r\n                    }\r\n                }\r\n                resolve(mathContent.trim());\r\n            } else {\r\n                setTimeout(poll, pollInterval);\r\n            }\r\n        }\r\n        poll();\r\n    });\r\n}\r\n\r\n/*************************************************\r\n * 1. QUESTION TYPE DETECTION\r\n *************************************************/\r\nfunction detectQuestionTypeGoogleForms(questionElement) {\r\n    ////(\"Wykrywanie typu pytania...\");\r\n\r\n    // Check if this is a name/email input that should be skipped\r\n    // Look for common patterns in name/email fields across different languages\r\n    // const questionText = questionElement.querySelector('.v-test-questions-title p')?.innerText?.toLowerCase() || '';\r\n    // if (questionText.includes('email') ||\r\n    //     questionText.includes('e-mail') ||\r\n    //     questionText.includes('imię') ||\r\n    //     questionText.includes('imie') ||\r\n    //     questionText.includes('nazwisko') ||\r\n    //     questionText.includes('name') ||\r\n    //     questionText.match(/^\\s*name\\s*$/i)) {\r\n    //     ////(\"Wykryto pole osobowe (email/imię/nazwisko) - pomijamy\");\r\n    //     return \"personal\";\r\n    // }\r\n\r\n\r\n    // Check for grid/matrix questions with radio buttons\r\n    // if (\r\n    //     questionElement.querySelectorAll('.flex-row-test').children.length > 1) {\r\n    //     ////(\"Wykryto pytanie typu: grid/matrix z radio buttons\");\r\n    //     return \"grid\";\r\n    // }\r\n\r\n    // // Check for checkbox grid questions\r\n    // if (questionElement.querySelector('.mxSrOe') &&\r\n    //     questionElement.querySelectorAll('.q9ZqCb').length > 0) {\r\n    //     ////(\"Wykryto pytanie typu: grid/matrix z checkboxami\");\r\n    //     return \"checkboxGrid\";\r\n    // }\r\n\r\n    // // Check for scale questions (linear scale)\r\n    // if (questionElement.querySelector('.N9Qcwe') &&\r\n    //     questionElement.querySelector('.lLfZXe.fnxRtf.BpKDyb[role=\"radiogroup\"]')) {\r\n    //     ////(\"Wykryto pytanie typu: skala liniowa\");\r\n    //     return \"scale\";\r\n    // }\r\n\r\n    // Check for radio buttons (single choice)\r\n    if (questionElement.querySelector('input[type=\"radio\"]')) {\r\n        ////(\"Wykryto pytanie typu: singleChoice (radio)\");\r\n        return \"singleChoice\";\r\n    }\r\n\r\n    // Check for checkboxes (multiple choice)\r\n    if (questionElement.querySelector('input[type=\"checkbox\"]')) {\r\n        ////(\"Wykryto pytanie typu: multipleChoice (checkbox)\");\r\n        return \"multipleChoice\";\r\n    }\r\n\r\n    // // Check for dropdown lists - improved detection\r\n    // if (questionElement.querySelector('.jgvuAb[role=\"listbox\"]') ||\r\n    //     questionElement.querySelector('.MocG8c[role=\"option\"]')) {\r\n    //     ////(\"Wykryto pytanie typu: dropdown\");\r\n    //     return \"dropdown\";\r\n    // }\r\n\r\n    // // Check for date pickers\r\n    // if (questionElement.querySelector('input[type=\"date\"]') ||\r\n    //     questionElement.querySelector('[data-includesyear=\"true\"]')) {\r\n    //     ////(\"Wykryto pytanie typu: date\");\r\n    //     return \"date\";\r\n    // }\r\n\r\n    // // Check for time pickers\r\n    // if (questionElement.querySelector('.ocBCTb[role=\"group\"]') ||\r\n    //     questionElement.querySelector('[jscontroller=\"OZjhxc\"]')) {\r\n    //     ////(\"Wykryto pytanie typu: time\");\r\n    //     return \"time\";\r\n    // }\r\n\r\n    // Look for text inputs (short answer)\r\n    if (questionElement.querySelector('input[type=\"text\"]:not([role=\"combobox\"]), textarea')) {\r\n        // Check if it's a long answer (textarea) or short answer (input)\r\n\r\n        ////(\"Wykryto pytanie typu: shortText (input)\");\r\n        return \"longText\";\r\n\r\n\r\n    }\r\n\r\n    // ////(\"Nie udało się wykryć typu pytania. Sprawdzam alternatywne selektory.\");\r\n\r\n    // Alternatywne selektory w przypadku nieznalezienia podstawowych\r\n    if (questionElement.querySelector('.a-test-lab-inp input')) {\r\n        ////(\"Wykryto pytanie typu alternatywnie: openText (via .rFrNMe)\");\r\n        return \"openText\";\r\n    }\r\n\r\n    // if (questionElement.querySelector('.lLfZXe[role=\"radiogroup\"]')) {\r\n    //     ////(\"Wykryto pytanie typu alternatywnie: singleChoice (via radiogroup)\");\r\n    //     return \"singleChoice\";\r\n    // }\r\n\r\n    ////(\"Nie udało się wykryć typu pytania - zwracam unknown\");\r\n    return \"unknown\";\r\n}\r\n\r\n\r\n/*************************************************\r\n * EXTRACT SCALE QUESTION\r\n *************************************************/\r\n// async function extractScaleQuestionGoogleForms(questionElement) {\r\n//     ////(\"Wyciąganie danych pytania typu skala...\");\r\n\r\n//     // Extract scale options (the numbers or values in the scale)\r\n//     const scaleOptions = [];\r\n//     const scaleItems = questionElement.querySelectorAll('.T5pZmf');\r\n\r\n//     scaleItems.forEach((item, index) => {\r\n//         const optionValue = item.querySelector('.Zki2Ve')?.innerText.trim();\r\n//         if (optionValue) {\r\n//             scaleOptions.push({\r\n//                 id: String(index + 1),\r\n//                 label: optionValue\r\n//             });\r\n//             ////(`Wyciągnięto opcję skali ${index + 1}: ${optionValue}`);\r\n//         }\r\n//     });\r\n\r\n//     // Extract scale labels (like \"Strongly disagree\" to \"Strongly agree\")\r\n//     const lowLabel = questionElement.querySelector('.g4s2gf')?.innerText.trim() || \"\";\r\n//     const highLabel = questionElement.querySelector('[jsname=\"jq1lEb\"]')?.innerText.trim() || \"\";\r\n\r\n//     ////(`Etykiety skali: \"${lowLabel}\" do \"${highLabel}\"`);\r\n\r\n//     return {\r\n//         options: scaleOptions,\r\n//         lowLabel,\r\n//         highLabel\r\n//     };\r\n// }\r\n\r\n/*************************************************\r\n * EXTRACT DROPDOWN QUESTION\r\n *************************************************/\r\n// async function extractDropdownQuestionGoogleForms(questionElement) {\r\n//     ////(\"Wyciąganie opcji z listy rozwijanej...\");\r\n\r\n//     const options = [];\r\n//     const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n\r\n//     // Find all dropdown options\r\n//     const dropdownOptions = questionElement.querySelectorAll('.MocG8c[role=\"option\"]');\r\n\r\n//     // Skip the first option if it's a placeholder (like \"Choose\")\r\n//     const startIdx = dropdownOptions.length > 0 &&\r\n//         dropdownOptions[0].classList.contains('LMgvRb') ? 1 : 0;\r\n\r\n//     for (let i = startIdx; i < dropdownOptions.length; i++) {\r\n//         const option = dropdownOptions[i];\r\n//         const optionText = option.querySelector('.vRMGwf')?.innerText.trim() || \"\";\r\n\r\n//         if (optionText) {\r\n//             const id = letters[i - startIdx] || String(i - startIdx + 1);\r\n//             options.push({\r\n//                 id,\r\n//                 label: optionText\r\n//             });\r\n//             ////(`Wyciągnięto opcję dropdown ${id}: ${optionText}`);\r\n//         }\r\n//     }\r\n\r\n//     return options;\r\n// }\r\n\r\n/*************************************************\r\n * EXTRACT CHECKBOX GRID QUESTION\r\n *************************************************/\r\n// async function extractCheckboxGridGoogleForms(questionElement) {\r\n//     ////(\"Wyciąganie danych pytania typu grid z checkboxami...\");\r\n\r\n//     // Try multiple selectors for row headers (statements/terms)\r\n//     const rowSelectors = [\r\n//         '.V4d7Ke.wzWPxe.OIC90c',  // Main selector\r\n//         '.V4d7Ke.wzWPxe',         // Alternative selector\r\n//         '.mxSrOe .V4d7Ke.wzWPxe.OIC90c'  // Another alternative\r\n//     ];\r\n\r\n//     const statements = [];\r\n//     const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n//     let rowElements = [];\r\n\r\n//     // Try each selector until we find row elements\r\n//     for (const selector of rowSelectors) {\r\n//         rowElements = questionElement.querySelectorAll(selector);\r\n//         if (rowElements.length > 0) {\r\n//             ////(`Znaleziono ${rowElements.length} wierszy używając selektora: ${selector}`);\r\n//             break;\r\n//         }\r\n//     }\r\n\r\n//     // Special case - if we still don't have rows but grid is detected, try looking at element text content\r\n//     if (rowElements.length === 0) {\r\n//         // Try to find rows directly in the grid by looking at row text\r\n//         const allGridTexts = questionElement.querySelectorAll('.mxSrOe');\r\n\r\n//         // Collect row texts that are likely to be row labels\r\n//         const possibleRows = [];\r\n//         allGridTexts.forEach((element, index) => {\r\n//             const rowText = element.querySelector('.wzWPxe')?.textContent.trim();\r\n//             if (rowText && rowText.length > 3) {\r\n//                 possibleRows.push({ element, text: rowText });\r\n//             }\r\n//         });\r\n\r\n//         ////(`Alternatywnie znaleziono ${possibleRows.length} możliwych etykiet wierszy`);\r\n\r\n//         // Generate statements from these possible rows\r\n//         possibleRows.forEach((row, index) => {\r\n//             const id = letters[index] || String(index + 1);\r\n//             statements.push({\r\n//                 id,\r\n//                 text: row.text\r\n//             });\r\n//             ////(`Wyciągnięto wiersz (alternatywnie) ${id}: ${row.text}`);\r\n//         });\r\n//     } else {\r\n//         // Process found rows normally\r\n//         for (let i = 0; i < rowElements.length; i++) {\r\n//             const rowText = rowElements[i].textContent.trim();\r\n//             if (rowText) {\r\n//                 const id = letters[i] || String(i + 1);\r\n//                 statements.push({\r\n//                     id,\r\n//                     text: rowText\r\n//                 });\r\n//                 ////(`Wyciągnięto wiersz ${id}: ${rowText}`);\r\n//             }\r\n//         }\r\n//     }\r\n\r\n//     // Try multiple selectors for column headers (options)\r\n//     const columnSelectors = [\r\n//         '.ssX1Bd.KZt9Tc .V4d7Ke.OIC90c',  // Main selector\r\n//         '.ssX1Bd.KZt9Tc > .V4d7Ke',       // Alternative selector\r\n//         '.V4d7Ke.OIC90c'                  // More general selector\r\n//     ];\r\n\r\n//     const commonOptions = [];\r\n//     let columnHeaderElements = [];\r\n\r\n//     // Try each selector until we find column elements\r\n//     for (const selector of columnSelectors) {\r\n//         columnHeaderElements = questionElement.querySelectorAll(selector);\r\n//         // Skip the first element if it's empty (usually the grid corner)\r\n//         const startIndex = columnHeaderElements.length > 0 &&\r\n//             !columnHeaderElements[0].textContent.trim() ? 1 : 0;\r\n\r\n//         if (columnHeaderElements.length > startIndex) {\r\n//             ////(`Znaleziono ${columnHeaderElements.length - startIndex} kolumn używając selektora: ${selector}`);\r\n\r\n//             // Process the column headers\r\n//             for (let i = startIndex; i < columnHeaderElements.length; i++) {\r\n//                 const columnText = columnHeaderElements[i].textContent.trim();\r\n//                 if (columnText) {\r\n//                     const id = String(i - startIndex + 1);\r\n//                     commonOptions.push({\r\n//                         id,\r\n//                         label: columnText\r\n//                     });\r\n//                     ////(`Wyciągnięto kolumnę ${id}: ${columnText}`);\r\n//                 }\r\n//             }\r\n//             break;\r\n//         }\r\n//     }\r\n\r\n//     // If we still don't have columns but have rows, create default columns\r\n//     if (commonOptions.length === 0 && statements.length > 0) {\r\n//         ////(\"Nie znaleziono kolumn. Tworzenie domyślnych opcji.\");\r\n\r\n//         // Look for checkbox elements to count columns\r\n//         const firstRow = questionElement.querySelector('.mxSrOe');\r\n//         const checkboxesInFirstRow = firstRow ? firstRow.querySelectorAll('.uVccjd[role=\"checkbox\"]') : [];\r\n\r\n//         const columnCount = checkboxesInFirstRow.length > 0 ?\r\n//             checkboxesInFirstRow.length : 3; // Default to 3 if can't determine\r\n\r\n//         // Create default column options\r\n//         for (let i = 0; i < columnCount; i++) {\r\n//             const id = String(i + 1);\r\n//             const defaultLabel = `Opcja ${id}`;\r\n//             commonOptions.push({\r\n//                 id,\r\n//                 label: defaultLabel\r\n//             });\r\n//             ////(`Utworzono domyślną kolumnę ${id}: ${defaultLabel}`);\r\n//         }\r\n//     }\r\n\r\n//     return { statements, commonOptions };\r\n// }\r\n\r\n/*************************************************\r\n * EXTRACT DATE AND TIME QUESTION\r\n *************************************************/\r\n// async function extractDateQuestionGoogleForms(questionElement) {\r\n//     ////(\"Wyciąganie danych pytania typu data...\");\r\n\r\n//     const dateInput = questionElement.querySelector('input[type=\"date\"]');\r\n//     const dateFormat = dateInput?.placeholder || \"YYYY-MM-DD\";\r\n\r\n//     ////(`Format daty: ${dateFormat}`);\r\n\r\n//     return { format: dateFormat };\r\n// }\r\n\r\n// async function extractTimeQuestionGoogleForms(questionElement) {\r\n//     ////(\"Wyciąganie danych pytania typu czas...\");\r\n\r\n//     const hourInput = questionElement.querySelector('[jsname=\"MKaSrf\"] input');\r\n//     const minuteInput = questionElement.querySelector('[jsname=\"QbtXXe\"] input');\r\n\r\n//     const format = hourInput && minuteInput ? \"HH:MM\" : \"unknown\";\r\n//     ////(`Format czasu: ${format}`);\r\n\r\n//     return { format };\r\n// }\r\n\r\n/*************************************************\r\n * 2. QUESTION TEXT EXTRACTION\r\n *************************************************/\r\nasync function extractQuestionTextGoogleForms(questionElement) {\r\n    ////(\"Wyciąganie tekstu pytania...\");\r\n\r\n    // Find the question title element\r\n    const titleElement = questionElement.querySelector('.v-test-questions-title p');\r\n    let questionText = \"\";\r\n\r\n    if (titleElement) {\r\n        questionText = titleElement.innerText.trim();\r\n        ////(\"Wyciągnięty tekst pytania:\", questionText);\r\n\r\n        // Extract math content if present\r\n        const mathContent = await extractMathContent(titleElement);\r\n        if (mathContent) {\r\n            questionText += \"\\n\" + mathContent;\r\n        }\r\n    } else {\r\n        ////(\"Nie znaleziono elementu tytułu pytania (.M7eMe)\");\r\n    }\r\n\r\n    // Extract any description text\r\n    const descriptionElement = questionElement.querySelector('.v-test-questions-title p img');\r\n    if (descriptionElement && descriptionElement.innerText.trim()) {\r\n        const descText = descriptionElement.innerText.trim();\r\n        questionText += \"\\n\" + descText;\r\n        ////(\"Wyciągnięty opis pytania:\", descText);\r\n    }\r\n\r\n    // Extract images\r\n    const images = await extractImages(questionElement);\r\n    if (images.length > 0) {\r\n        ////(`Znaleziono ${images.length} obrazków w pytaniu`);\r\n    }\r\n\r\n    return { text: questionText, images };\r\n}\r\n\r\n/*************************************************\r\n * 3. EXTRACT ANSWERS FOR CHOICE QUESTIONS\r\n *************************************************/\r\nasync function extractChoiceAnswersGoogleForms(questionElement) {\r\n    //(\"Wyciąganie opcji odpowiedzi...\");\r\n\r\n    // Different question types have different structures\r\n    let answerElements = [];\r\n\r\n    // For multiple choice questions (checkboxes)\r\n    if (questionElement.querySelector('input[type=\"checkbox\"]')) {\r\n        answerElements = questionElement.querySelectorAll('.v-test-questions-checkbox-block');\r\n        //(`Znaleziono ${answerElements.length} opcji wielokrotnego wyboru (checkbox)`);\r\n    }\r\n    // For single choice questions (radio buttons)\r\n    else if (questionElement.querySelector('input[type=\"radio\"]')) {\r\n        answerElements = questionElement.querySelectorAll('.v-test-questions-radio-block');\r\n        //(`Znaleziono ${answerElements.length} opcji pojedynczego wyboru (radio)`);\r\n    }\r\n\r\n    const options = [];\r\n    const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n\r\n    for (let i = 0; i < answerElements.length; i++) {\r\n        const answerElement = answerElements[i];\r\n\r\n        // Skip \"other\" option if present\r\n        if (answerElement.classList.contains('vm96I')) {\r\n            continue;\r\n        }\r\n\r\n        // Extract the option text based on question type\r\n        let answerText = \"\";\r\n\r\n        // Uproszczone selektory - szukamy paragrafu bezpośrednio\r\n        const labelElement = answerElement.querySelector('p');\r\n\r\n        if (labelElement) {\r\n            answerText = labelElement.textContent;\r\n        } else {\r\n            // Fallback: try to get any visible text\r\n            answerText = answerElement.textContent;\r\n        }\r\n\r\n        // Extract math content if present\r\n        const mathContent = await extractMathContent(answerElement);\r\n        if (mathContent) {\r\n            answerText += \"\\n\" + mathContent;\r\n        }\r\n\r\n        // Extract images\r\n        const images = await extractImages(answerElement);\r\n\r\n        const id = letters[i] || String(i + 1);\r\n        options.push({\r\n            id,\r\n            label: answerText.trim(),\r\n            images\r\n        });\r\n\r\n        //(`Wyciągnięto opcję ${id}: ${answerText.trim()}`);\r\n    }\r\n\r\n    return options;\r\n}\r\n\r\n/*************************************************\r\n * 4. EXTRACT OPEN TEXT QUESTIONS\r\n *************************************************/\r\nasync function extractOpenTextQuestionGoogleForms(questionElement) {\r\n    ////(\"Wyciąganie danych pytania otwartego...\");\r\n\r\n    const inputElement = questionElement.querySelector('input[type=\"text\"]:not([role=\"combobox\"]), textarea');\r\n\r\n    // if (inputElement) {\r\n    //     ////(`Znaleziono element input z placeholder: \"${inputElement.placeholder || 'Wprowadź odpowiedź'}\"`);\r\n    // } else {\r\n    //     ////(\"Nie znaleziono elementu input dla pytania otwartego\");\r\n    // }\r\n\r\n    const images = await extractImages(questionElement);\r\n\r\n    return {\r\n        placeholder: inputElement ? inputElement.placeholder || \"Wprowadź odpowiedź\" : \"Wprowadź odpowiedź\",\r\n        images\r\n    }\r\n}\r\n/*************************************************\r\n * EXTRACT GRID/MATRIX QUESTIONS DATA\r\n *************************************************/\r\n\r\n// async function extractGridQuestionGoogleForms(questionElement) {\r\n//     ////(\"Wyciąganie danych pytania typu grid/matrix...\");\r\n\r\n//     // 1. Extract the row headers (statements/terms) - używamy lepszego selektora\r\n//     const rowSelectors = [\r\n//         '.lLfZXe[role=\"radiogroup\"] .V4d7Ke.wzWPxe.OIC90c', // Główny selektor\r\n//         '.V4d7Ke.wzWPxe.OIC90c'                             // Alternatywny selektor\r\n//     ];\r\n\r\n//     let rowElements = [];\r\n//     // Próbujemy różnych selektorów, aż znajdziemy pasujące elementy\r\n//     for (const selector of rowSelectors) {\r\n//         rowElements = questionElement.querySelectorAll(selector);\r\n//         if (rowElements.length > 0) {\r\n//             ////(`Znaleziono ${rowElements.length} wierszy (terminów) używając selektora: ${selector}`);\r\n//             break;\r\n//         }\r\n//     }\r\n\r\n//     // Utworzenie tablicy na unikalne statements\r\n//     const statements = [];\r\n//     const seenTexts = new Set(); // Do śledzenia unikalnych tekstów\r\n//     const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\n\r\n//     for (let i = 0; i < rowElements.length; i++) {\r\n//         const rowElement = rowElements[i];\r\n//         const rowText = rowElement.textContent.trim();\r\n\r\n//         // Sprawdzamy, czy ten tekst już został dodany\r\n//         if (rowText && !seenTexts.has(rowText)) {\r\n//             seenTexts.add(rowText); // Oznaczamy jako widziany\r\n//             const id = letters[statements.length] || String(statements.length + 1);\r\n//             statements.push({\r\n//                 id,\r\n//                 text: rowText\r\n//             });\r\n//             ////(`Wyciągnięto wiersz ${id}: ${rowText}`);\r\n//         }\r\n//     }\r\n\r\n//     ////(`Znaleziono ${statements.length} unikalnych wierszy`);\r\n\r\n//     // 2. Extract the column headers (options/definitions)\r\n//     // Najpierw szukamy nagłówków kolumn (pierwszy wiersz z definicjami)\r\n//     const columnHeaderRow = questionElement.querySelector('.ssX1Bd.KZt9Tc');\r\n//     const columnElements = columnHeaderRow ? columnHeaderRow.querySelectorAll('.V4d7Ke.OIC90c') : [];\r\n\r\n//     const commonOptions = [];\r\n\r\n//     for (let i = 0; i < columnElements.length; i++) {\r\n//         const columnElement = columnElements[i];\r\n//         const columnText = columnElement.textContent.trim();\r\n//         if (columnText) {\r\n//             const id = String(i + 1);\r\n//             commonOptions.push({\r\n//                 id,\r\n//                 label: columnText\r\n//             });\r\n//             ////(`Wyciągnięto kolumnę ${id}: ${columnText}`);\r\n//         }\r\n//     }\r\n\r\n//     // Jeśli nie znaleziono opcji, spróbuj alternatywnej metody\r\n//     if (commonOptions.length === 0) {\r\n//         // Znajdź pierwsze pytanie i wydobądź opcje z data-value\r\n//         const firstRow = questionElement.querySelector('.lLfZXe[role=\"radiogroup\"]');\r\n//         if (firstRow) {\r\n//             const optionElements = firstRow.querySelectorAll('.Od2TWd[role=\"radio\"]');\r\n//             optionElements.forEach((option, index) => {\r\n//                 const optionValue = option.getAttribute('data-value');\r\n//                 if (optionValue) {\r\n//                     commonOptions.push({\r\n//                         id: String(index + 1),\r\n//                         label: optionValue\r\n//                     });\r\n//                     ////(`Wyciągnięto opcję (alternatywnie) ${index + 1}: ${optionValue}`);\r\n//                 }\r\n//             });\r\n//         }\r\n//     }\r\n\r\n//     return { statements, commonOptions };\r\n// }\r\n\r\n/*************************************************\r\n * UPDATE BUILD UNIFIED QUESTION FOR GRID TYPES\r\n *************************************************/\r\nasync function buildUnifiedQuestion(questionElement) {\r\n    ////(\"Budowanie ujednoliconej struktury pytania...\");\r\n\r\n    const detectedType = detectQuestionTypeGoogleForms(questionElement);\r\n\r\n    // Skip personal info questions\r\n    if (detectedType === \"personal\") {\r\n        ////(\"Pomijam pytanie o dane osobowe\");\r\n        return null;\r\n    }\r\n\r\n    const { text, images } = await extractQuestionTextGoogleForms(questionElement);\r\n\r\n    // For grid/matrix questions, don't require text to be present (some forms have empty heading)\r\n    if (!text && (detectedType !== \"grid\" && detectedType !== \"checkboxGrid\")) {\r\n        ////(\"Nie udało się wyciągnąć tekstu pytania\");\r\n        return null;\r\n    }\r\n\r\n    let unified = {\r\n        id: questionElement.id || `q-${Date.now()}`,\r\n        text,\r\n        images,\r\n        metadata: { difficulty: \"unknown\" }\r\n    };\r\n\r\n    // Map Google Forms question types to the unified format\r\n    switch (detectedType) {\r\n        // case \"grid\":\r\n        //     ////(\"Budowanie ujednoliconego pytania typu grid\");\r\n        //     unified.type = \"likert\";\r\n\r\n        //     // Wyciągnij dane pytania typu grid\r\n        //     const gridData = await extractGridQuestionGoogleForms(questionElement);\r\n        //     unified.statements = gridData.statements;\r\n        //     unified.commonOptions = gridData.commonOptions;\r\n\r\n        //     unified.format = {\r\n        //         responseType: \"matrix\",\r\n        //         description: \"Podaj odpowiedź dla każdego wiersza, wybierając poprawną opcję z kolumny.\"\r\n        //     };\r\n\r\n        //     ////(\"Zbudowano pytanie typu grid z\", unified.statements.length, \"wierszami i\", unified.commonOptions.length, \"opcjami\");\r\n        //     break;\r\n\r\n        // case \"checkboxGrid\":\r\n        //     ////(\"Budowanie ujednoliconego pytania typu checkbox grid\");\r\n        //     unified.type = \"checkboxGrid\";\r\n\r\n        //     // Wyciągnij dane pytania typu checkbox grid\r\n        //     const checkboxGridData = await extractCheckboxGridGoogleForms(questionElement);\r\n        //     unified.statements = checkboxGridData.statements;\r\n        //     unified.commonOptions = checkboxGridData.commonOptions;\r\n\r\n        //     unified.format = {\r\n        //         responseType: \"checkboxMatrix\",\r\n        //         description: \"Zaznacz odpowiednie opcje dla każdego wiersza, odpowiedź jako obiekt {wiersz: [kolumny]}.\"\r\n        //     };\r\n\r\n        //     ////(\"Zbudowano pytanie typu checkbox grid z\", unified.statements.length, \"wierszami i\", unified.commonOptions.length, \"opcjami\");\r\n        //     break;\r\n\r\n        // case \"scale\":\r\n        //     ////(\"Budowanie ujednoliconego pytania typu skala\");\r\n        //     unified.type = \"scale\";\r\n\r\n        //     // Wyciągnij dane pytania typu skala\r\n        //     const scaleData = await extractScaleQuestionGoogleForms(questionElement);\r\n        //     unified.options = scaleData.options;\r\n        //     unified.lowLabel = scaleData.lowLabel;\r\n        //     unified.highLabel = scaleData.highLabel;\r\n\r\n        //     unified.format = {\r\n        //         responseType: \"optionId\",\r\n        //         description: \"Odpowiedz jako numer odpowiadający wartości na skali.\"\r\n        //     };\r\n\r\n        //     ////(\"Zbudowano pytanie typu skala z\", unified.options.length, \"opcjami\");\r\n        //     break;\r\n\r\n        case \"singleChoice\":\r\n            unified.type = \"singlechoice\";\r\n            unified.options = await extractChoiceAnswersGoogleForms(questionElement);\r\n            unified.format = {\r\n                responseType: \"optionId\",\r\n                description: \"Odpowiedz jako pojedyncza litera odpowiadająca właściwej opcji.\"\r\n            };\r\n            break;\r\n\r\n        case \"multipleChoice\":\r\n            unified.type = \"multiple\";\r\n            unified.options = await extractChoiceAnswersGoogleForms(questionElement);\r\n            unified.format = {\r\n                responseType: \"optionIds\",\r\n                description: \"Odpowiedz jako tablica liter odpowiadających właściwym opcjom (np. [\\\"A\\\", \\\"C\\\"]).\"\r\n            };\r\n            break;\r\n\r\n        // case \"dropdown\":\r\n        //     unified.type = \"dropdown\";\r\n        //     unified.options = await extractDropdownQuestionGoogleForms(questionElement);\r\n        //     unified.format = {\r\n        //         responseType: \"optionId\",\r\n        //         description: \"Odpowiedz jako pojedyncza litera odpowiadająca właściwej opcji z listy rozwijanej.\"\r\n        //     };\r\n        //     ////(\"Zbudowano pytanie typu dropdown z\", unified.options.length, \"opcjami\");\r\n        //     break;\r\n\r\n        // case \"date\":\r\n        //     unified.type = \"date\";\r\n        //     const dateData = await extractDateQuestionGoogleForms(questionElement);\r\n        //     unified.format = {\r\n        //         responseType: \"date\",\r\n        //         description: \"Podaj odpowiedź w formacie YYYY-MM-DD.\",\r\n        //         format: dateData.format\r\n        //     };\r\n        //     ////(\"Zbudowano pytanie typu date\");\r\n        //     break;\r\n\r\n        // case \"time\":\r\n        //     unified.type = \"time\";\r\n        //     const timeData = await extractTimeQuestionGoogleForms(questionElement);\r\n        //     unified.format = {\r\n        //         responseType: \"time\",\r\n        //         description: \"Podaj odpowiedź w formacie HH:MM.\",\r\n        //         format: timeData.format\r\n        //     };\r\n        //     ////(\"Zbudowano pytanie typu time\");\r\n        //     break;\r\n\r\n        case \"shortText\":\r\n            unified.type = \"shortanswer\";\r\n            const shortData = await extractOpenTextQuestionGoogleForms(questionElement);\r\n            unified.options = [];\r\n            unified.placeholder = shortData.placeholder;\r\n            unified.format = {\r\n                responseType: \"text\",\r\n                description: \"Podaj krótką, zwięzłą odpowiedź tekstową (max. kilka słów).\"\r\n            };\r\n            break;\r\n\r\n        case \"longText\":\r\n            unified.type = \"longanswer\";\r\n            const longData = await extractOpenTextQuestionGoogleForms(questionElement);\r\n            unified.options = [];\r\n            unified.placeholder = longData.placeholder;\r\n            unified.format = {\r\n                responseType: \"text\",\r\n                description: \"Podaj wyczerpującą, szczegółową odpowiedź tekstową.\"\r\n            };\r\n            break;\r\n\r\n        case \"openText\":\r\n            unified.type = \"shortanswer\";\r\n            const openData = await extractOpenTextQuestionGoogleForms(questionElement);\r\n            unified.options = [];\r\n            unified.placeholder = openData.placeholder;\r\n\r\n            // Determine if this is a short or long answer\r\n            const textareaElement = questionElement.querySelector('textarea');\r\n            unified.answerLength = textareaElement ? \"long\" : \"short\";\r\n\r\n            // Set format based on answer length\r\n            if (unified.answerLength === \"long\") {\r\n                unified.format = {\r\n                    responseType: \"text\",\r\n                    description: \"Podaj wyczerpującą, szczegółową odpowiedź tekstową.\"\r\n                };\r\n            } else {\r\n                unified.format = {\r\n                    responseType: \"text\",\r\n                    description: \"Podaj krótką, zwięzłą odpowiedź tekstową (max. kilka słów).\"\r\n                };\r\n            }\r\n            break;\r\n\r\n        default:\r\n            ////(`Nieobsługiwany typ pytania: ${detectedType}`);\r\n            return null;\r\n    }\r\n\r\n    ////(\"Zbudowana struktura pytania:\", unified);\r\n    return unified;\r\n}\r\n\r\nfunction getCorrectAnswerText() {\r\n    // Pobierz język przeglądarki\r\n    const browserLang = navigator.language || navigator.userLanguage;\r\n    const lang = browserLang.split('-')[0]; // Pobierz kod głównego języka (np. \"pl\" z \"pl-PL\")\r\n\r\n    // Tłumaczenia dla \"Poprawna odpowiedź\" w różnych językach\r\n    const translations = {\r\n        'pl': 'Poprawna odpowiedź:',\r\n        'en': 'Correct answer:',\r\n        'de': 'Richtige Antwort:',\r\n        'es': 'Respuesta correcta:',\r\n        'fr': 'Réponse correcte:',\r\n        'it': 'Risposta corretta:',\r\n        'ru': 'Правильный ответ:',\r\n        'cs': 'Správná odpověď:',\r\n        'sk': 'Správna odpoveď:',\r\n        'uk': 'Правильна відповідь:'\r\n    };\r\n\r\n    // Zwróć tłumaczenie dla wykrytego języka lub domyślnie angielski\r\n    return translations[lang] || translations['en'];\r\n}\r\n\r\n\r\n/*************************************************\r\n * 6. MARK CORRECT ANSWERS\r\n *************************************************/\r\nfunction markCorrectAnswer(questionElement, correctAnswerObj, unifiedQuestion, mode) {\r\n    ////(`Zaznaczanie poprawnej odpowiedzi w trybie: ${mode}`, { correctAnswer: correctAnswerObj });\r\n\r\n    mode = mode.toLowerCase();\r\n    const qType = unifiedQuestion.type;\r\n    //(qType)\r\n    // Handle personal info questions - skip these\r\n    if (qType === \"personal\") {\r\n        ////(\"Pomijam zaznaczanie odpowiedzi dla pytania o dane osobowe\");\r\n        return;\r\n    }\r\n\r\n    if (qType === \"singlechoice\") {\r\n        //(\"Przetwarzanie pytania typu singlechoice\");\r\n\r\n        // Określenie indeksu poprawnej odpowiedzi - poprawione mapowanie\r\n        let correctIndex = -1;\r\n\r\n        if (typeof correctAnswerObj === \"string\") {\r\n            const correctAnswer = correctAnswerObj.trim();\r\n\r\n            // Bezpośrednie mapowanie liter na indeksy\r\n            if (/^[A-Za-z]$/i.test(correctAnswer)) {\r\n                // Poprawiony kod mapowania - bezpośrednia konwersja litery na indeks\r\n                // A=0, B=1, C=2 itd.\r\n                correctIndex = correctAnswer.toUpperCase().charCodeAt(0) - 65; // A to kod ASCII 65\r\n                //(`Przekonwertowano literę ${correctAnswer} na indeks ${correctIndex}`);\r\n            }\r\n            // Obsługa liczb jako stringów\r\n            else if (/^\\d+$/.test(correctAnswer)) {\r\n                correctIndex = parseInt(correctAnswer, 10);\r\n                //(`Przekonwertowano string liczbowy ${correctAnswer} na indeks ${correctIndex}`);\r\n            }\r\n        }\r\n        // Obsługa bezpośrednio liczb\r\n        else if (typeof correctAnswerObj === \"number\") {\r\n            correctIndex = correctAnswerObj;\r\n            //(`Użyto bezpośrednio liczbę ${correctAnswerObj} jako indeks`);\r\n        }\r\n\r\n        //(`Finalna wartość: Indeks poprawnej odpowiedzi: ${correctIndex} (z ${correctAnswerObj})`);\r\n\r\n        // Szukanie elementów odpowiedzi\r\n        const radioButtons = questionElement.querySelectorAll('.v-test-questions-radio-block input[type=\"radio\"]');\r\n        //(`Znaleziono ${radioButtons.length} radio buttonów`);\r\n\r\n        // Sprawdzenie czy indeks jest prawidłowy\r\n        if (correctIndex >= 0 && correctIndex < radioButtons.length) {\r\n            const correctRadioButton = radioButtons[correctIndex];\r\n            const parentBlock = correctRadioButton.closest('.v-test-questions-radio-block');\r\n\r\n            //(`Znaleziono poprawny element radio o indeksie ${correctIndex}`);\r\n\r\n            if (mode === \"default\") {\r\n                // Tryb default - zaznacz na zielono\r\n                const paragraphElement = parentBlock.querySelector('p');\r\n                if (paragraphElement) {\r\n                    paragraphElement.style.color = \"green\";\r\n                    paragraphElement.style.fontWeight = \"700\";\r\n                    //(`Odpowiedź o indeksie ${correctIndex} zaznaczona na zielono`);\r\n                }\r\n\r\n                // Zaznacz również ewentualne obrazki\r\n                const imgElement = parentBlock.querySelector('img');\r\n                if (imgElement) {\r\n                    const container = imgElement.parentElement;\r\n                    container.style.boxShadow = \"0 0 10px rgba(0, 128, 0, 0.7)\";\r\n                    container.style.border = \"2px solid rgba(0, 128, 0, 0.7)\";\r\n                }\r\n            }\r\n            else if (mode === \"immediate\") {\r\n                // Tryb immediate - zaznacz radio button\r\n                //(`Zaznaczanie radio buttona o indeksie ${correctIndex}`);\r\n\r\n                // Metoda 1: Bezpośrednie ustawienie właściwości checked\r\n                correctRadioButton.checked = true;\r\n\r\n                // Metoda 2: Symulacja kliknięcia w label\r\n                try {\r\n                    const label = parentBlock.querySelector('label');\r\n                    if (label) {\r\n                        label.click();\r\n                        //(\"Kliknięto w label\");\r\n                    }\r\n                } catch (e) {\r\n                    console.error(\"Błąd podczas kliknięcia label:\", e);\r\n                }\r\n\r\n                // Metoda 3: Wywołanie zdarzeń\r\n                try {\r\n                    correctRadioButton.dispatchEvent(new Event('change', { bubbles: true }));\r\n                    //(\"Wysłano zdarzenie change\");\r\n                } catch (e) {\r\n                    console.error(\"Błąd podczas wywoływania zdarzeń:\", e);\r\n                }\r\n            }\r\n            else if (mode === \"savemode\") {\r\n                // Tryb savemode - pogrub pierwszą literę\r\n                const paragraphElement = parentBlock.querySelector('p');\r\n                if (paragraphElement && paragraphElement.textContent) {\r\n                    const text = paragraphElement.textContent;\r\n\r\n                    if (text.length > 0) {\r\n                        // Zachowaj oryginalny tekst\r\n                        if (!paragraphElement.dataset.originalText) {\r\n                            paragraphElement.dataset.originalText = text;\r\n                        }\r\n\r\n                        // Wyodrębnij pierwszą literę i resztę tekstu\r\n                        const firstChar = text.charAt(0);\r\n                        const restOfText = text.substring(1);\r\n\r\n                        // Wyczyść zawartość paragrafu\r\n                        paragraphElement.textContent = '';\r\n\r\n                        // Stwórz element span dla pierwszej litery\r\n                        const boldSpan = document.createElement('span');\r\n                        boldSpan.style.fontWeight = \"600\";\r\n                        boldSpan.textContent = firstChar;\r\n\r\n                        // Dodaj wszystko z powrotem do paragrafu\r\n                        paragraphElement.appendChild(boldSpan);\r\n                        paragraphElement.appendChild(document.createTextNode(restOfText));\r\n\r\n                        //(`Pogrubiono pierwszą literę \"${firstChar}\" odpowiedzi o indeksie ${correctIndex}`);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            console.error(`Indeks ${correctIndex} jest poza zakresem (liczba elementów: ${radioButtons.length})`);\r\n        }\r\n    }\r\n    else if (qType === \"multiple\") {\r\n        const answerElements = questionElement.querySelectorAll('.v-test-questions-checkbox-block');\r\n        ////(`Znaleziono ${answerElements.length} elementów odpowiedzi wielokrotnego wyboru`);\r\n\r\n        // Parse the correct answers\r\n        let correctIndices = [];\r\n        if (Array.isArray(correctAnswerObj)) {\r\n            // If the backend returns an array of letters\r\n            const correctLetters = correctAnswerObj.map(letter => letter.toUpperCase());\r\n            const optionIds = unifiedQuestion.options.map(opt => opt.id.toUpperCase());\r\n\r\n            correctLetters.forEach(letter => {\r\n                const index = optionIds.indexOf(letter);\r\n                if (index >= 0) {\r\n                    correctIndices.push(index);\r\n                }\r\n            });\r\n            ////(`Poprawne odpowiedzi to ${correctLetters.join(', ')}`, { correctIndices });\r\n        } else if (typeof correctAnswerObj === \"string\") {\r\n            // If the backend returns a string like \"A,C\"\r\n            const parts = correctAnswerObj.split(',');\r\n            for (const part of parts) {\r\n                const letter = part.trim().toUpperCase();\r\n                const index = unifiedQuestion.options.findIndex(opt => opt.id.toUpperCase() === letter);\r\n                if (index >= 0) {\r\n                    correctIndices.push(index);\r\n                }\r\n            }\r\n            ////(`Poprawne odpowiedzi to ${parts.join(', ')}`, { correctIndices });\r\n        }\r\n\r\n        // Mark each correct answer\r\n        correctIndices.forEach(index => {\r\n            if (index >= 0 && index < answerElements.length) {\r\n                const correctElement = answerElements[index];\r\n                ////(`Znaleziono poprawny element wielokrotnego wyboru o indeksie ${index}`);\r\n\r\n                if (mode === \"default\") {\r\n                    // Highlight the correct answer visually\r\n                    const textElement = correctElement.querySelector('.v-test-questions-radio-block p,.v-test-questions-checkbox-block p');\r\n                    if (textElement) {\r\n                        textElement.style.color = \"green\";\r\n                        textElement.style.fontWeight = \"700\";\r\n                        ////(\"Zastosowano wyróżnienie do elementu tekstowego wielokrotnego wyboru\");\r\n                    } else {\r\n                        ////(\"Nie znaleziono elementu tekstowego do wyróżnienia w wielokrotnym wyborze\");\r\n                    }\r\n\r\n                    // Handle any images in the answer\r\n                    const imgEl = correctElement.querySelector('img');\r\n                    if (imgEl) {\r\n                        const container = imgEl.parentElement;\r\n                        container.style.boxShadow = \"0 0 10px rgba(0, 128, 0, 0.7)\";\r\n                        container.style.border = \"2px solid rgba(0, 128, 0, 0.7)\";\r\n                        ////(\"Zastosowano wyróżnienie do kontenera obrazka wielokrotnego wyboru\");\r\n                    }\r\n                }\r\n                else if (mode === \"immediate\") {\r\n                    // Simulate clicking the correct option\r\n                    const checkboxElement = correctElement.querySelector('input[type=\"checkbox\"]');\r\n                    if (checkboxElement) {\r\n                        ////(\"Klikanie elementu checkbox:\", checkboxElement);\r\n                        checkboxElement.click();\r\n                    } else {\r\n                        // Try clicking the parent label which should trigger the checkbox\r\n                        ////(\"Nie znaleziono bezpośrednio elementu checkbox, próba kliknięcia etykiety\");\r\n                        const label = correctElement.querySelector('label');\r\n                        if (label) {\r\n                            label.click();\r\n                        } else {\r\n                            correctElement.click();\r\n                        }\r\n                    }\r\n                }\r\n                else if (mode === \"savemode\") {\r\n                    // Subtle indication of correct answer - bold only first letter\r\n                    const textEl = correctElement.querySelector('.v-test-questions-radio-block p,.v-test-questions-checkbox-block p');\r\n                    if (textEl) {\r\n                        const text = textEl.textContent || textEl.value || \"\";\r\n                        ////(\"Zastosowanie savemode do elementu tekstowego wielokrotnego wyboru\");\r\n\r\n                        if (text.length > 0) {\r\n                            // Zachowaj oryginalny tekst\r\n                            if (!textEl.dataset.originalText) {\r\n                                textEl.dataset.originalText = text;\r\n                            }\r\n\r\n                            // Jeśli to pole input\r\n                            if (textEl.value !== undefined) {\r\n                                textEl.dataset.originalValue = textEl.value;\r\n                                // Dodaj zdarzenie focus dla pól input\r\n                                textEl.addEventListener('focus', function () {\r\n                                    if (this.dataset.originalValue) {\r\n                                        this.value = this.dataset.originalValue;\r\n                                    }\r\n                                });\r\n                            }\r\n                            // Jeśli to element tekstowy (nie input)\r\n                            else {\r\n                                // Podziel tekst: pierwsza litera i reszta\r\n                                const firstChar = text.charAt(0);\r\n                                const restOfText = text.substring(1);\r\n\r\n                                // Usuń obecną zawartość\r\n                                textEl.textContent = '';\r\n\r\n                                // Utwórz element dla pierwszej litery\r\n                                const boldSpan = document.createElement('span');\r\n                                boldSpan.style.fontWeight = \"600\";\r\n                                boldSpan.textContent = firstChar;\r\n\r\n                                // Dodaj pierwszą literę i resztę tekstu\r\n                                textEl.appendChild(boldSpan);\r\n                                textEl.appendChild(document.createTextNode(restOfText));\r\n\r\n                                ////(`Pogrubiono pierwszą literę \"${firstChar}\" odpowiedzi w wielokrotnym wyborze`);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        ////(\"Nie znaleziono elementu tekstowego dla trybu savemode w wielokrotnym wyborze\");\r\n                    }\r\n                }\r\n            } else {\r\n                ////(`Poprawny indeks ${index} jest poza zakresem dla wielokrotnego wyboru (liczba elementów: ${answerElements.length})`);\r\n            }\r\n        });\r\n    }\r\n    else if (qType === \"shortanswer\" || qType === \"longanswer\") {\r\n        const inputElement = questionElement.querySelector('input[type=\"text\"]:not([role=\"combobox\"]), textarea');\r\n        ////(\"Znaleziono element input pytania otwartego:\", inputElement);\r\n\r\n        if (!inputElement) {\r\n            ////(\"Nie znaleziono elementu input dla pytania otwartego\");\r\n            return;\r\n        }\r\n\r\n        // Sprawdzamy, czy mamy do czynienia z długą czy krótką odpowiedzią\r\n        const isLongAnswer = inputElement.tagName.toLowerCase() === 'textarea' || qType === \"longanswer\";\r\n\r\n        // For short answers, make sure the text is actually short\r\n        let answerText = String(correctAnswerObj || \"\");\r\n        if (qType === \"shortanswer\" && answerText.length > 50) {\r\n            // Truncate to a short answer if it's too long\r\n            answerText = answerText.split(/[.,;]|\\s+/)[0].trim();\r\n            if (answerText.length > 50) answerText = answerText.substring(0, 50);\r\n            ////(`Skrócono długą odpowiedź do \"${answerText}\"`);\r\n        }\r\n\r\n        if (mode === \"default\") {\r\n            // Pobierz tekst \"Poprawna odpowiedź\" w języku przeglądarki\r\n            const correctAnswerText = getCorrectAnswerText();\r\n\r\n\r\n            // Usuń istniejący element informacyjny jeśli istnieje\r\n            const existingInfo = questionElement.querySelector('.correct-answer-info');\r\n            if (existingInfo) {\r\n                existingInfo.remove();\r\n            }\r\n\r\n            // Create an info element to display the correct answer\r\n            const mainContainer = questionElement.querySelector('input[type=text]');\r\n            ////(`Tryb default: wyświetlanie poprawnej odpowiedzi \"${answerText}\"`);\r\n            // Utwórz nowy element informacyjny\r\n            const info = document.createElement(\"div\");\r\n            info.classList.add(\"correct-answer-info\");\r\n\r\n            // Zastosuj wspólne style dla obu typów odpowiedzi\r\n            info.style.display = \"block\";\r\n            info.style.marginTop = \"10px\";\r\n            info.style.marginBottom = \"5px\";\r\n            info.style.color = \"green\";\r\n            info.style.fontWeight = \"500\";\r\n            info.style.whiteSpace = \"normal\";\r\n            info.style.overflow = \"auto\";\r\n            info.style.width = \"100%\";\r\n            info.style.boxSizing = \"border-box\";\r\n            info.style.position = \"relative\";\r\n            info.style.zIndex = \"10\";\r\n            info.style.padding = \"8px\";\r\n            info.style.border = \"1px solid #e0e0e0\";\r\n            info.style.borderRadius = \"4px\";\r\n            info.style.backgroundColor = \"#f0f8f0\";\r\n            info.style.fontSize = \"14px\";\r\n            info.style.lineHeight = \"1.5\";\r\n            info.style.wordWrap = \"break-word\";\r\n            info.style.userSelect = 'text';\r\n            info.style.webkitUserSelect = 'text';\r\n            info.style.MozUserSelect = 'text';\r\n            info.style.msUserSelect = 'text';\r\n\r\n            info.style.setProperty('user-select', 'text', 'important');\r\n            info.style.setProperty('-webkit-user-select', 'text', 'important');\r\n            info.style.setProperty('-moz-user-select', 'text', 'important');\r\n            info.style.setProperty('-ms-user-select', 'text', 'important');\r\n\r\n\r\n            // Tylko dla długich odpowiedzi ustawiamy maksymalną wysokość\r\n            if (isLongAnswer) {\r\n                info.style.maxHeight = \"200px\";\r\n            }\r\n\r\n            // Dla obu typów używamy tej samej struktury z nagłówkiem i treścią\r\n            const headerElement = document.createElement(\"div\");\r\n            headerElement.style.fontWeight = \"bold\";\r\n            headerElement.style.marginBottom = \"4px\";\r\n            headerElement.textContent = correctAnswerText;\r\n\r\n            const contentElement = document.createElement(\"div\");\r\n            contentElement.style.fontFamily = \"inherit\";\r\n            contentElement.style.whiteSpace = \"pre-wrap\";\r\n            contentElement.textContent = answerText;\r\n\r\n            info.appendChild(headerElement);\r\n            info.appendChild(contentElement);\r\n\r\n            // Dodajemy element w odpowiednim miejscu, korzystając z Twojej logiki\r\n            if (mainContainer) {\r\n                mainContainer.insertAdjacentElement(\"afterend\", info);\r\n            } else {\r\n                // Jeśli nie znaleziono kontenera AgroKb, spróbujmy znaleźć kontener SL4Sz\r\n                const alertContainer = questionElement.querySelector('.SL4Sz');\r\n                if (alertContainer) {\r\n                    alertContainer.insertAdjacentElement(\"beforebegin\", info);\r\n                } else {\r\n                    // Ostateczne rozwiązanie - dodaj do rodzica inputa\r\n                    const formContainer = inputElement.closest('.input[type=text], .v-test-question');\r\n                    if (formContainer) {\r\n                        formContainer.insertAdjacentElement(\"afterend\", info);\r\n                    } else {\r\n                        // Awaryjne rozwiązanie, gdyby wszystko inne zawiodło\r\n                        const parentDiv = inputElement.closest('div');\r\n                        if (parentDiv) {\r\n                            parentDiv.parentElement.appendChild(info);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            ////(\"Utworzono element informacyjny z poprawną odpowiedzią\");\r\n        }\r\n        else if (mode === \"immediate\") {\r\n            // Set the value directly\r\n            ////(`Tryb immediate: ustawianie wartości input na \"${answerText}\"`);\r\n            inputElement.value = answerText;\r\n            inputElement.dispatchEvent(new Event('input', { bubbles: true }));\r\n            inputElement.dispatchEvent(new Event('change', { bubbles: true }));\r\n        }\r\n        else if (mode === \"savemode\") {\r\n            ////(\"Tryb savemode: agresywna metoda obsługi placeholdera (z ukrywaniem dodatkowego elementu)\");\r\n\r\n            // Znajdź input lub textarea – dopasowaj selektor do rzeczywistej struktury (np. wykorzystując klasę)\r\n            const inputElement = questionElement.querySelector('input, textarea');\r\n            if (!inputElement) {\r\n                console.warn(\"Savemode: Nie znaleziono pola odpowiedzi w pytaniu\");\r\n                return;\r\n            }\r\n\r\n            // Zapisz oryginalny placeholder zapisany w atrybucie input (jeśli istnieje)\r\n            const originalPlaceholder = inputElement.getAttribute('placeholder') || '';\r\n            inputElement.dataset.originalPlaceholder = originalPlaceholder;\r\n\r\n            // Pobierz domyślny element placeholder generowany przez stronę (np. Google)\r\n\r\n\r\n            // Funkcja focus – ustawienie Twojego placeholdera oraz ukrycie dodatkowego elementu\r\n            const focusHandler = function () {\r\n                if (this.value === '') {\r\n                    this.placeholder = (isLongAnswer && answerText.length > 50)\r\n                        ? answerText.substring(0, 50) + \"...\"\r\n                        : answerText;\r\n                }\r\n                // Ukryj dodatkowy element (jeśli występuje)\r\n\r\n            };\r\n\r\n            // Funkcja blur – przywrócenie oryginalnego placeholdera i pokazanie dodatkowego elementu\r\n            const blurHandler = function () {\r\n                const original = this.dataset.originalPlaceholder || '';\r\n                this.placeholder = original;\r\n                // Przywracamy domyślną widoczność dodatkowego placeholdera\r\n\r\n            };\r\n\r\n            // Funkcja input – w trakcie wpisywania tekstu modyfikujemy placeholder\r\n            const inputHandler = function () {\r\n                if (this.value !== '') {\r\n                    this.placeholder = '';\r\n                } else if (document.activeElement === this) {\r\n                    this.placeholder = (isLongAnswer && answerText.length > 50)\r\n                        ? answerText.substring(0, 50) + \"...\"\r\n                        : answerText;\r\n                }\r\n            };\r\n\r\n            // Usuń stare event listenery, jeśli są przypisane\r\n            if (inputElement.saveFocusHandler) {\r\n                inputElement.removeEventListener('focus', inputElement.saveFocusHandler);\r\n            }\r\n            if (inputElement.saveBlurHandler) {\r\n                inputElement.removeEventListener('blur', inputElement.saveBlurHandler);\r\n            }\r\n            if (inputElement.saveInputHandler) {\r\n                inputElement.removeEventListener('input', inputElement.saveInputHandler);\r\n            }\r\n\r\n            // Zapisz referencje do nowych handlerów\r\n            inputElement.saveFocusHandler = focusHandler;\r\n            inputElement.saveBlurHandler = blurHandler;\r\n            inputElement.saveInputHandler = inputHandler;\r\n\r\n            // Dodaj event listenery\r\n            inputElement.addEventListener('focus', focusHandler);\r\n            inputElement.addEventListener('blur', blurHandler);\r\n            inputElement.addEventListener('input', inputHandler);\r\n\r\n            // Jeśli input już ma focus, wywołaj focusHandler, w przeciwnym razie – blurHandler\r\n            if (document.activeElement === inputElement) {\r\n                focusHandler.call(inputElement);\r\n            } else {\r\n                blurHandler.call(inputElement);\r\n            }\r\n\r\n            ////(\"Savemode: ustawiono placeholder oraz ukryto dodatkowy element z placeholderem\");\r\n        }\r\n\r\n\r\n    }\r\n    // else if (qType === \"dropdown\") {\r\n    //     ////(\"Zaznaczanie odpowiedzi dla pytania typu dropdown\");\r\n\r\n    //     const dropdownElement = questionElement.querySelector('.jgvuAb[role=\"listbox\"]');\r\n    //     if (!dropdownElement) {\r\n    //         ////(\"Nie znaleziono elementu dropdown\");\r\n    //         return;\r\n    //     }\r\n\r\n    //     // Determine which option is correct\r\n    //     let correctLetter = \"\";\r\n    //     if (typeof correctAnswerObj === \"string\") {\r\n    //         correctLetter = correctAnswerObj.trim().toUpperCase();\r\n    //         ////(`Poprawna odpowiedź to \"${correctLetter}\"`);\r\n    //     }\r\n\r\n    //     // Find the corresponding option text based on the letter\r\n    //     let correctOptionText = \"\";\r\n    //     if (correctLetter && unifiedQuestion.options) {\r\n    //         const correctOption = unifiedQuestion.options.find(\r\n    //             opt => opt.id.toUpperCase() === correctLetter\r\n    //         );\r\n    //         if (correctOption) {\r\n    //             correctOptionText = correctOption.label;\r\n    //             ////(`Znaleziono tekst opcji: \"${correctOptionText}\"`);\r\n    //         }\r\n    //     }\r\n\r\n    //     if (correctOptionText) {\r\n    //         if (mode === \"default\") {\r\n    //             // Otwórz dropdown, zmień kolor poprawnej odpowiedzi na zielony, a następnie zamknij dropdown\r\n    //             dropdownElement.click();\r\n\r\n    //             setTimeout(() => {\r\n    //                 const optionElements = document.querySelectorAll('.MocG8c[role=\"option\"]');\r\n    //                 let foundCorrect = false;\r\n\r\n    //                 for (const option of optionElements) {\r\n    //                     if (option.textContent.trim() === correctOptionText) {\r\n    //                         // Zmień kolor tekstu poprawnej odpowiedzi na zielony\r\n    //                         const optionText = option.querySelector('.vRMGwf');\r\n    //                         if (optionText) {\r\n    //                             optionText.style.color = \"green\";\r\n    //                             optionText.style.fontWeight = \"bold\";\r\n    //                         }\r\n    //                         foundCorrect = true;\r\n    //                         ////(`Zmieniono kolor tekstu opcji \"${correctOptionText}\" na zielony`);\r\n    //                     }\r\n    //                 }\r\n\r\n    //                 // Zamknij dropdown po dokonaniu zmian\r\n    //                 if (foundCorrect) {\r\n    //                     document.body.click();\r\n    //                 }\r\n    //             }, 300);\r\n    //         }\r\n    //         else if (mode === \"immediate\") {\r\n    //             // Natychmiast zaznacz poprawną odpowiedź\r\n    //             dropdownElement.click();\r\n\r\n    //             // Poczekaj na otwarcie dropdown i kliknij poprawną opcję\r\n    //             setTimeout(() => {\r\n    //                 const optionElements = document.querySelectorAll('.MocG8c[role=\"option\"]');\r\n    //                 for (const option of optionElements) {\r\n    //                     if (option.textContent.trim() === correctOptionText) {\r\n    //                         option.click();\r\n    //                         ////(`Kliknięto opcję \"${correctOptionText}\"`);\r\n    //                         break;\r\n    //                     }\r\n    //                 }\r\n    //             }, 300);\r\n    //         }\r\n    //         else if (mode === \"savemode\") {\r\n    //             // W trybie savemode otwórz dropdown i zmień kolor tekstu poprawnej odpowiedzi na szary\r\n    //             dropdownElement.click();\r\n\r\n    //             setTimeout(() => {\r\n    //                 const optionElements = document.querySelectorAll('.MocG8c[role=\"option\"]');\r\n    //                 let foundCorrect = false;\r\n\r\n    //                 for (const option of optionElements) {\r\n    //                     if (option.textContent.trim() === correctOptionText) {\r\n    //                         // Zmień kolor tekstu poprawnej odpowiedzi na szary\r\n    //                         const optionText = option.querySelector('.vRMGwf');\r\n    //                         if (optionText) {\r\n    //                             optionText.style.color = \"#505050\"; // Ciemnoszary\r\n    //                             optionText.style.fontWeight = \"600\"; // Lekkie pogrubienie\r\n    //                         }\r\n    //                         foundCorrect = true;\r\n    //                         ////(`Zmieniono kolor tekstu opcji \"${correctOptionText}\" na szary`);\r\n    //                     }\r\n    //                 }\r\n\r\n    //                 // Zamknij dropdown po dokonaniu zmian\r\n    //                 if (foundCorrect) {\r\n    //                     document.body.click();\r\n    //                 }\r\n    //             }, 300);\r\n    //         }\r\n    //     }\r\n    // }\r\n    // else if (qType === \"scale\") {\r\n    //     ////(\"Zaznaczanie odpowiedzi dla pytania typu skala\");\r\n\r\n    //     let scaleValue;\r\n    //     if (typeof correctAnswerObj === \"string\") {\r\n    //         scaleValue = correctAnswerObj.trim();\r\n    //     } else if (typeof correctAnswerObj === \"number\") {\r\n    //         scaleValue = String(correctAnswerObj);\r\n    //     }\r\n\r\n    //     if (!scaleValue) {\r\n    //         ////(\"Brak wartości dla skali\");\r\n    //         return;\r\n    //     }\r\n\r\n    //     ////(`Wartość skali: ${scaleValue}`);\r\n\r\n    //     // Find all scale options\r\n    //     const scaleOptions = questionElement.querySelectorAll('.T5pZmf');\r\n    //     let targetOption = null;\r\n\r\n    //     // Find the option with matching value\r\n    //     for (const option of scaleOptions) {\r\n    //         const optionValue = option.querySelector('.Zki2Ve')?.textContent.trim();\r\n    //         if (optionValue === scaleValue) {\r\n    //             targetOption = option;\r\n    //             ////(`Znaleziono opcję skali: ${optionValue}`);\r\n    //             break;\r\n    //         }\r\n    //     }\r\n\r\n    //     if (targetOption) {\r\n    //         if (mode === \"default\") {\r\n    //             // Visual highlight\r\n    //             const valueElement = targetOption.querySelector('.Zki2Ve');\r\n    //             if (valueElement) {\r\n    //                 valueElement.style.color = \"green\";\r\n    //                 valueElement.style.fontWeight = \"bold\";\r\n    //                 ////(\"Zastosowano wyróżnienie dla wartości skali\");\r\n    //             }\r\n    //         }\r\n    //         else if (mode === \"immediate\") {\r\n    //             // Click the radio button\r\n    //             const radioButton = targetOption.querySelector('.Od2TWd[role=\"radio\"]');\r\n    //             if (radioButton) {\r\n    //                 radioButton.click();\r\n    //                 ////(\"Kliknięto przycisk radio dla skali\");\r\n    //             } else {\r\n    //                 // Try clicking the whole option\r\n    //                 targetOption.click();\r\n    //                 ////(\"Kliknięto całą opcję skali\");\r\n    //             }\r\n    //         }\r\n    //         else if (mode === \"savemode\") {\r\n    //             // Subtle indication - just add a slight border\r\n    //             const radioCircle = targetOption.querySelector('.AB7Lab.Id5V1');\r\n    //             if (radioCircle) {\r\n    //                 radioCircle.style.border = \"2px solid #8f949c\";\r\n    //                 ////(\"Dodano delikatne obramowanie dla opcji skali\");\r\n    //             }\r\n    //         }\r\n    //     } else {\r\n    //         ////(`Nie znaleziono opcji skali o wartości ${scaleValue}`);\r\n    //     }\r\n    // }\r\n    // else if (qType === \"date\") {\r\n    //     ////(\"Zaznaczanie odpowiedzi dla pytania typu data\");\r\n\r\n    //     let dateValue = \"\";\r\n    //     if (typeof correctAnswerObj === \"string\") {\r\n    //         // Try to format the date properly (YYYY-MM-DD)\r\n    //         const dateMatch = correctAnswerObj.match(/(\\d{4})[-.\\/]?(\\d{1,2})[-.\\/]?(\\d{1,2})/);\r\n    //         if (dateMatch) {\r\n    //             const year = dateMatch[1];\r\n    //             const month = dateMatch[2].padStart(2, '0');\r\n    //             const day = dateMatch[3].padStart(2, '0');\r\n    //             dateValue = `${year}-${month}-${day}`;\r\n    //         } else {\r\n    //             // Try to parse as date string\r\n    //             try {\r\n    //                 const date = new Date(correctAnswerObj);\r\n    //                 if (!isNaN(date.getTime())) {\r\n    //                     const year = date.getFullYear();\r\n    //                     const month = (date.getMonth() + 1).toString().padStart(2, '0');\r\n    //                     const day = date.getDate().toString().padStart(2, '0');\r\n    //                     dateValue = `${year}-${month}-${day}`;\r\n    //                 }\r\n    //             } catch (e) {\r\n    //                 ////(\"Nie można sparsować daty:\", e);\r\n    //             }\r\n    //         }\r\n    //     }\r\n\r\n    //     if (!dateValue) {\r\n    //         ////(\"Brak poprawnej wartości daty\");\r\n    //         return;\r\n    //     }\r\n\r\n    //     ////(`Poprawna data: ${dateValue}`);\r\n\r\n    //     // Find the date input element\r\n    //     const dateInput = questionElement.querySelector('input[type=\"date\"]');\r\n\r\n    //     if (dateInput) {\r\n    //         if (mode === \"default\") {\r\n    //             // Formatowanie daty do wyświetlenia (DD.MM.YYYY)\r\n    //             const [year, month, day] = dateValue.split('-');\r\n    //             const formattedDate = `${day}.${month}.${year}`;\r\n\r\n    //             // Pobierz tekst \"Poprawna odpowiedź\" w języku przeglądarki\r\n    //             const correctAnswerText = getCorrectAnswerText();\r\n\r\n    //             // Znajdź główny kontener pytania (najwyższy element)\r\n    //             const mainContainer = questionElement.closest('.geS5n') || questionElement;\r\n\r\n    //             // Usuń istniejące elementy informacyjne, jeśli istnieją\r\n    //             const existingInfo = mainContainer.querySelector('.correct-answer-info');\r\n    //             if (existingInfo) {\r\n    //                 existingInfo.remove();\r\n    //             }\r\n\r\n    //             // Utwórz nowy element z odpowiedzią z odpowiednimi stylami (podobnymi do longAnswer)\r\n    //             const infoElement = document.createElement(\"div\");\r\n    //             infoElement.classList.add(\"correct-answer-info\");\r\n\r\n    //             // Style dla kontenera odpowiedzi\r\n    //             infoElement.style.background = \"#f0fff0\";\r\n    //             infoElement.style.border = \"1px solid #ddeedd\";\r\n    //             infoElement.style.borderRadius = \"4px\";\r\n    //             infoElement.style.marginTop = \"10px\";\r\n    //             infoElement.style.marginBottom = \"10px\";\r\n    //             infoElement.style.padding = \"8px 12px\";\r\n    //             infoElement.style.width = \"100%\";\r\n    //             infoElement.style.boxSizing = \"border-box\";\r\n    //             infoElement.style.fontSize = \"14px\";\r\n    //             infoElement.style.color = \"green\";\r\n\r\n    //             // Struktura: nagłówek + treść\r\n    //             infoElement.innerHTML = `\r\n    //                 <div style=\"font-weight: bold; margin-bottom: 4px;\">${correctAnswerText}</div>\r\n    //                 <div>${formattedDate}</div>\r\n    //             `;\r\n\r\n    //             // Znajdź dobry punkt wstawienia (po całym pytaniu)\r\n    //             // Szukamy elementu .SL4Sz lub dodajemy po całym kontenerze pytania\r\n    //             const alertElement = mainContainer.querySelector('.SL4Sz');\r\n    //             if (alertElement) {\r\n    //                 // Wstaw przed alertem\r\n    //                 alertElement.parentNode.insertBefore(infoElement, alertElement);\r\n    //             } else {\r\n    //                 // Dodaj na końcu głównego kontenera\r\n    //                 mainContainer.appendChild(infoElement);\r\n    //             }\r\n\r\n    //             ////(\"Dodano informację o poprawnej dacie\");\r\n    //         }\r\n    //         else if (mode === \"immediate\") {\r\n    //             // Set the date value\r\n    //             dateInput.value = dateValue;\r\n    //             dateInput.dispatchEvent(new Event('input', { bubbles: true }));\r\n    //             dateInput.dispatchEvent(new Event('change', { bubbles: true }));\r\n    //             ////(`Ustawiono datę na ${dateValue}`);\r\n    //         }\r\n    //         else if (mode === \"savemode\") {\r\n    //             // Add subtle visual cue\r\n    //             const originalBorder = dateInput.style.border;\r\n    //             dateInput.dataset.originalBorder = originalBorder;\r\n\r\n    //             // Add focus event to show correct date as placeholder\r\n    //             dateInput.addEventListener('focus', function () {\r\n    //                 this.setAttribute('placeholder', dateValue);\r\n    //             });\r\n\r\n    //             dateInput.addEventListener('blur', function () {\r\n    //                 this.removeAttribute('placeholder');\r\n    //             });\r\n\r\n    //             ////(\"Dodano podpowiedź dla daty w trybie savemode\");\r\n    //         }\r\n    //     } else {\r\n    //         ////(\"Nie znaleziono pola input date\");\r\n    //     }\r\n    // }\r\n    // else if (qType === \"time\") {\r\n    //     ////(\"Zaznaczanie odpowiedzi dla pytania typu czas\");\r\n\r\n    //     let hours = \"\", minutes = \"\";\r\n    //     if (typeof correctAnswerObj === \"string\") {\r\n    //         // Parse time format (HH:MM or H:MM)\r\n    //         const timeMatch = correctAnswerObj.match(/(\\d{1,2}):(\\d{2})/);\r\n    //         if (timeMatch) {\r\n    //             hours = timeMatch[1].padStart(2, '0');\r\n    //             minutes = timeMatch[2];\r\n    //             ////(`Poprawny czas: ${hours}:${minutes}`);\r\n    //         }\r\n    //     }\r\n\r\n    //     if (!hours || !minutes) {\r\n    //         ////(\"Brak poprawnej wartości czasu\");\r\n    //         return;\r\n    //     }\r\n\r\n    //     // Find hour and minute inputs\r\n    //     const hourInput = questionElement.querySelector('[jsname=\"MKaSrf\"] input');\r\n    //     const minuteInput = questionElement.querySelector('[jsname=\"QbtXXe\"] input');\r\n\r\n    //     if (hourInput && minuteInput) {\r\n    //         if (mode === \"default\") {\r\n    //             // Pobierz tekst \"Poprawna odpowiedź\" w języku przeglądarki\r\n    //             const correctAnswerText = getCorrectAnswerText();\r\n\r\n    //             // Znajdź główny kontener pytania (najwyższy element)\r\n    //             const mainContainer = questionElement.closest('.geS5n') || questionElement;\r\n\r\n    //             // Usuń istniejące elementy informacyjne, jeśli istnieją\r\n    //             const existingInfo = mainContainer.querySelector('.correct-answer-info');\r\n    //             if (existingInfo) {\r\n    //                 existingInfo.remove();\r\n    //             }\r\n\r\n    //             // Utwórz nowy element z odpowiedzią z odpowiednimi stylami (podobnymi do longAnswer)\r\n    //             const infoElement = document.createElement(\"div\");\r\n    //             infoElement.classList.add(\"correct-answer-info\");\r\n\r\n    //             // Style dla kontenera odpowiedzi\r\n    //             infoElement.style.background = \"#f0fff0\";\r\n    //             infoElement.style.border = \"1px solid #ddeedd\";\r\n    //             infoElement.style.borderRadius = \"4px\";\r\n    //             infoElement.style.marginTop = \"10px\";\r\n    //             infoElement.style.marginBottom = \"10px\";\r\n    //             infoElement.style.padding = \"8px 12px\";\r\n    //             infoElement.style.width = \"100%\";\r\n    //             infoElement.style.boxSizing = \"border-box\";\r\n    //             infoElement.style.fontSize = \"14px\";\r\n    //             infoElement.style.color = \"green\";\r\n\r\n    //             // Struktura: nagłówek + treść\r\n    //             infoElement.innerHTML = `\r\n    //                 <div style=\"font-weight: bold; margin-bottom: 4px;\">${correctAnswerText}</div>\r\n    //                 <div>${hours}:${minutes}</div>\r\n    //             `;\r\n\r\n    //             // Znajdź dobry punkt wstawienia (po całym pytaniu)\r\n    //             // Szukamy elementu .SL4Sz lub dodajemy po całym kontenerze pytania\r\n    //             const alertElement = mainContainer.querySelector('.SL4Sz');\r\n    //             if (alertElement) {\r\n    //                 // Wstaw przed alertem\r\n    //                 alertElement.parentNode.insertBefore(infoElement, alertElement);\r\n    //             } else {\r\n    //                 // Dodaj na końcu głównego kontenera\r\n    //                 mainContainer.appendChild(infoElement);\r\n    //             }\r\n\r\n    //             ////(\"Dodano informację o poprawnym czasie\");\r\n    //         }\r\n    //         else if (mode === \"immediate\") {\r\n    //             // Set the time values\r\n    //             hourInput.value = hours;\r\n    //             hourInput.dispatchEvent(new Event('input', { bubbles: true }));\r\n    //             hourInput.dispatchEvent(new Event('change', { bubbles: true }));\r\n\r\n    //             minuteInput.value = minutes;\r\n    //             minuteInput.dispatchEvent(new Event('input', { bubbles: true }));\r\n    //             minuteInput.dispatchEvent(new Event('change', { bubbles: true }));\r\n\r\n    //             ////(`Ustawiono czas na ${hours}:${minutes}`);\r\n    //         }\r\n    //         else if (mode === \"savemode\") {\r\n    //             // Add subtle visual cues\r\n    //             const originalHourBorder = hourInput.style.border;\r\n    //             const originalMinuteBorder = minuteInput.style.border;\r\n\r\n    //             hourInput.dataset.originalBorder = originalHourBorder;\r\n    //             minuteInput.dataset.originalBorder = originalMinuteBorder;\r\n\r\n    //             // Add focus events\r\n    //             hourInput.addEventListener('focus', function () {\r\n    //                 this.setAttribute('placeholder', hours);\r\n    //             });\r\n\r\n    //             hourInput.addEventListener('blur', function () {\r\n    //                 this.removeAttribute('placeholder');\r\n    //             });\r\n\r\n    //             minuteInput.addEventListener('focus', function () {\r\n    //                 this.setAttribute('placeholder', minutes);\r\n    //             });\r\n\r\n    //             minuteInput.addEventListener('blur', function () {\r\n    //                 this.removeAttribute('placeholder');\r\n    //             });\r\n\r\n    //             ////(\"Dodano podpowiedź dla czasu w trybie savemode\");\r\n    //         }\r\n    //     } else {\r\n    //         ////(\"Nie znaleziono pól input dla godziny i minuty\");\r\n    //     }\r\n    // }\r\n    else if (qType === \"checkboxGrid\") {\r\n        ////(\"Zaznaczanie odpowiedzi dla pytania typu checkboxGrid\");\r\n\r\n        try {\r\n            // Process the answer format\r\n            let answerMapping = {};\r\n\r\n            if (typeof correctAnswerObj === 'object' && !Array.isArray(correctAnswerObj) && correctAnswerObj !== null) {\r\n                // Format: {A: [\"1\", \"3\"], B: [\"2\"]} or nested object\r\n                if (correctAnswerObj.value && typeof correctAnswerObj.value === \"object\") {\r\n                    answerMapping = correctAnswerObj.value;\r\n                } else {\r\n                    answerMapping = correctAnswerObj;\r\n                }\r\n                ////(\"Przetworzono odpowiedź w formacie obiektowym:\", answerMapping);\r\n            }\r\n            else if (typeof correctAnswerObj === 'string') {\r\n                // Try to parse JSON\r\n                try {\r\n                    const parsed = JSON.parse(correctAnswerObj);\r\n                    if (typeof parsed === 'object' && parsed !== null) {\r\n                        answerMapping = parsed;\r\n                        ////(\"Przetworzono odpowiedź z parsowania JSON:\", answerMapping);\r\n                    }\r\n                } catch (e) {\r\n                    ////(\"Nie udało się sparsować odpowiedzi jako JSON:\", e);\r\n                }\r\n            }\r\n\r\n            // Get all rows in the grid\r\n            const rows = questionElement.querySelectorAll('.mxSrOe');\r\n            ////(`Znaleziono ${rows.length} wierszy w grid`);\r\n\r\n            // Process each row\r\n            unifiedQuestion.statements.forEach((statement, rowIndex) => {\r\n                if (rowIndex >= rows.length) {\r\n                    ////(`Brak elementu wiersza dla ${statement.id}`);\r\n                    return;\r\n                }\r\n\r\n                const row = rows[rowIndex];\r\n                const selectedColumns = answerMapping[statement.id];\r\n\r\n                if (!selectedColumns || !Array.isArray(selectedColumns)) {\r\n                    ////(`Brak lub niepoprawna wartość dla wiersza ${statement.id}`);\r\n                    return;\r\n                }\r\n\r\n                ////(`Wiersz ${statement.id}: wybrano kolumny ${selectedColumns.join(', ')}`);\r\n\r\n                // Get checkboxes in this row\r\n                const checkboxes = row.querySelectorAll('.uVccjd[role=\"checkbox\"]');\r\n\r\n                // Mark each selected checkbox in this row\r\n                selectedColumns.forEach(columnValue => {\r\n                    // Convert to numeric index (0-based)\r\n                    let columnIndex;\r\n\r\n                    // Try to parse as numeric\r\n                    if (!isNaN(parseInt(columnValue))) {\r\n                        columnIndex = parseInt(columnValue) - 1; // Convert 1-based to 0-based\r\n                    } else {\r\n                        // Try to find by label/id\r\n                        columnIndex = unifiedQuestion.commonOptions.findIndex(\r\n                            opt => opt.id.toUpperCase() === columnValue.toUpperCase()\r\n                        );\r\n                    }\r\n\r\n                    if (columnIndex >= 0 && columnIndex < checkboxes.length) {\r\n                        const checkbox = checkboxes[columnIndex];\r\n\r\n                        if (mode === \"default\") {\r\n                            // Visual highlight\r\n                            checkbox.style.outline = \"2px solid green\";\r\n                            ////(`Wiersz ${rowIndex + 1}: wyróżniono checkbox ${columnIndex + 1}`);\r\n                        }\r\n                        else if (mode === \"immediate\") {\r\n                            // Click the checkbox\r\n                            checkbox.click();\r\n                            ////(`Wiersz ${rowIndex + 1}: kliknięto checkbox ${columnIndex + 1}`);\r\n                        }\r\n                        else if (mode === \"savemode\") {\r\n                            // Subtle indication\r\n                            checkbox.style.outline = \"1px solid #d7d9db\";\r\n                            ////(`Wiersz ${rowIndex + 1}: delikatnie wyróżniono checkbox ${columnIndex + 1}`);\r\n                        }\r\n                    } else {\r\n                        ////(`Wiersz ${rowIndex + 1}: indeks kolumny ${columnIndex} poza zakresem`);\r\n                    }\r\n                });\r\n            });\r\n\r\n        } catch (error) {\r\n            ////(\"Błąd podczas zaznaczania odpowiedzi checkboxGrid:\", error);\r\n        }\r\n    }\r\n    else if (qType === \"likert\") {\r\n        ////(\"Zaznaczanie odpowiedzi dla pytania typu grid/likert\");\r\n\r\n        try {\r\n            // Przetwarzanie odpowiedzi z backendu\r\n            let answerMapping = {};\r\n\r\n            // Obsługa różnych formatów odpowiedzi\r\n            if (correctAnswerObj && correctAnswerObj.value && typeof correctAnswerObj.value === \"string\") {\r\n                // Format: {value: \"1,2,3,4,\", answerRepresentation: \"numeric\"}\r\n                const numericValues = correctAnswerObj.value.split(',').filter(v => v.trim() !== \"\");\r\n                ////(\"Wartości numeryczne:\", numericValues);\r\n\r\n                // Utwórz mapowanie z numeru kolumny na ID\r\n                let mapping = {};\r\n                if (unifiedQuestion.commonOptions && unifiedQuestion.commonOptions.length > 0) {\r\n                    unifiedQuestion.commonOptions.forEach((opt, idx) => {\r\n                        mapping[idx + 1] = opt.id;\r\n                    });\r\n                }\r\n\r\n                // Przypisz wartości numeryczne do poszczególnych wierszy\r\n                unifiedQuestion.statements.forEach((stmt, idx) => {\r\n                    if (idx < numericValues.length) {\r\n                        answerMapping[stmt.id] = numericValues[idx];\r\n                    }\r\n                });\r\n\r\n                ////(\"Zmapowane odpowiedzi:\", answerMapping);\r\n            }\r\n            else if (typeof correctAnswerObj === 'object' && !Array.isArray(correctAnswerObj) && correctAnswerObj !== null) {\r\n                // Format: obiekt {A: \"1\", B: \"2\", ...} lub obiekt w obiekcie {value: {A: \"1\", B: \"2\"}}\r\n                if (correctAnswerObj.value && typeof correctAnswerObj.value === \"object\") {\r\n                    answerMapping = correctAnswerObj.value;\r\n                } else {\r\n                    answerMapping = correctAnswerObj;\r\n                }\r\n                ////(\"Przetworzono odpowiedź w formacie obiektowym:\", answerMapping);\r\n            }\r\n            else if (typeof correctAnswerObj === 'string') {\r\n                // Próba parsowania JSON\r\n                try {\r\n                    const parsed = JSON.parse(correctAnswerObj);\r\n                    if (typeof parsed === 'object' && parsed !== null) {\r\n                        answerMapping = parsed;\r\n                        ////(\"Przetworzono odpowiedź z parsowania JSON:\", answerMapping);\r\n                    }\r\n                } catch (e) {\r\n                    ////(\"Nie udało się sparsować odpowiedzi jako JSON:\", e);\r\n                }\r\n            }\r\n\r\n            // Znajdź wszystkie wiersze (radiogroup) w siatce\r\n            const rowElements = questionElement.querySelectorAll('.lLfZXe[role=\"radiogroup\"]');\r\n            ////(`Znaleziono ${rowElements.length} wierszy radiogroup`);\r\n\r\n            // Dla każdego zdefiniowanego wiersza\r\n            unifiedQuestion.statements.forEach((statement, rowIndex) => {\r\n                if (rowIndex >= rowElements.length) {\r\n                    ////(`Brak elementu wiersza dla ${statement.id}`);\r\n                    return;\r\n                }\r\n\r\n                const rowElement = rowElements[rowIndex];\r\n                const correctColumnValue = answerMapping[statement.id];\r\n\r\n                if (!correctColumnValue) {\r\n                    ////(`Brak wartości dla wiersza ${statement.id}`);\r\n                    return;\r\n                }\r\n\r\n                // Konwersja na indeks kolumny (jeśli to liczba)\r\n                let columnIndex = parseInt(correctColumnValue) - 1;\r\n\r\n                // Jeśli to nie liczba (np. \"A\", \"B\"), spróbuj znaleźć po etykiecie\r\n                if (isNaN(columnIndex)) {\r\n                    const optionIndex = unifiedQuestion.commonOptions.findIndex(\r\n                        opt => opt.id.toUpperCase() === correctColumnValue.toUpperCase()\r\n                    );\r\n                    if (optionIndex >= 0) {\r\n                        columnIndex = optionIndex;\r\n                    }\r\n                }\r\n\r\n                ////(`Wiersz ${statement.id}: wybrano kolumnę ${columnIndex + 1}`);\r\n\r\n                // Znajdź odpowiedni przycisk radiowy w tym wierszu\r\n                const radioButtons = rowElement.querySelectorAll('.Od2TWd[role=\"radio\"]');\r\n\r\n                if (columnIndex >= 0 && columnIndex < radioButtons.length) {\r\n                    const correctRadio = radioButtons[columnIndex];\r\n\r\n                    if (mode === \"default\") {\r\n                        // Znajdź element kółka w przycisku radiowym\r\n                        const radioCircle = correctRadio.querySelector('.AB7Lab.Id5V1');\r\n                        if (radioCircle) {\r\n                            // Stylowanie obramowania elementu kółka na zielono\r\n                            radioCircle.style.border = \"3px solid green\";\r\n                            ////(`Wiersz ${rowIndex + 1}: wyróżniono kółko odpowiedzi ${columnIndex + 1} na zielono`);\r\n                        } else {\r\n                            // Jeśli nie znaleziono elementu kółka, zastosuj styl do całego przycisku radio\r\n                            correctRadio.style.border = \"3px solid green\";\r\n                            ////(`Wiersz ${rowIndex + 1}: wyróżniono odpowiedź ${columnIndex + 1} zieloną ramką`);\r\n                        }\r\n                    }\r\n                    else if (mode === \"immediate\") {\r\n                        correctRadio.click();\r\n                        ////(`Wiersz ${rowIndex + 1}: kliknięto odpowiedź ${columnIndex + 1}`);\r\n                    }\r\n                    else if (mode === \"savemode\") {\r\n                        const radioCircle = correctRadio.querySelector('.AB7Lab.Id5V1');\r\n                        if (radioCircle) {\r\n                            radioCircle.style.border = \"2px solid #8f949c\";\r\n                            ////(`Wiersz ${rowIndex + 1}: wyróżniono kółko odpowiedzi ${columnIndex + 1} na jasnoszaro`);\r\n                        } else {\r\n                            correctRadio.style.border = \"2px solid #8f949c\";\r\n                            ////(`Wiersz ${rowIndex + 1}: wyróżniono odpowiedź ${columnIndex + 1} jasnoszarą ramką`);\r\n                        }\r\n                    }\r\n\r\n                } else {\r\n                    ////(`Wiersz ${rowIndex + 1}: indeks kolumny ${columnIndex} poza zakresem (liczba przycisków: ${radioButtons.length})`);\r\n                }\r\n            });\r\n\r\n        } catch (error) {\r\n            ////(\"Błąd podczas zaznaczania odpowiedzi grid:\", error);\r\n        }\r\n    }\r\n}\r\n\r\n/*************************************************\r\n * 7. PROCESS INDIVIDUAL QUESTION\r\n *************************************************/\r\nasync function handleQuestionGoogleForms(questionElement, mode) {\r\n    ////(\"Przetwarzanie elementu pytania...\");\r\n\r\n    const unifiedQuestion = await buildUnifiedQuestion(questionElement);\r\n    if (!unifiedQuestion) {\r\n        ////(\"Nie udało się zbudować ujednoliconej struktury pytania\");\r\n        return null;\r\n    }\r\n\r\n    // Determine if multiple correct answers are possible\r\n    const isMultipleCorrect = unifiedQuestion.type === \"multiple\";\r\n\r\n    // Send to backend and process response\r\n    try {\r\n        ////(\"Wysyłanie pytania do backendu:\", unifiedQuestion);\r\n        const response = await sendQuestionToBackendVseosvita(unifiedQuestion, isMultipleCorrect);\r\n        ////(\"Otrzymano odpowiedź z backendu:\", response);\r\n\r\n        if (response && response.correctAnswer) {\r\n            ////(`Zaznaczanie poprawnej odpowiedzi: ${JSON.stringify(response.correctAnswer)}`);\r\n            markCorrectAnswer(questionElement, response.correctAnswer, unifiedQuestion, mode);\r\n            return unifiedQuestion;\r\n        } else {\r\n            ////(\"Brak 'correctAnswer' w odpowiedzi z backendu:\", response);\r\n            return null;\r\n        }\r\n    } catch (error) {\r\n        ////(\"Błąd wysyłania pytania do backendu:\", error);\r\n        return null;\r\n    }\r\n}\r\n\r\n/*************************************************\r\n * 8. MAIN PROCESSING FUNCTION\r\n *************************************************/\r\nexport async function processVseosvita() {\r\n    try {\r\n        // Get marking mode from storage\r\n        const { markingMode } = await new Promise((resolve) => {\r\n            chrome.storage.local.get(['markingMode'], (result) => {\r\n                resolve({ markingMode: result.markingMode || 'default' });\r\n            });\r\n        });\r\n\r\n        //(`Rozpoczynanie przetwarzania Vseosvita w trybie: ${markingMode}`);\r\n\r\n        // Find all questions on the page - try primary selector first\r\n        let questions = document.querySelectorAll('.v-test-go-body');\r\n        //(`Znaleziono ${questions.length} pytań używając głównego selektora`);\r\n\r\n        if (questions.length === 0) {\r\n            //(\"Nie znaleziono pytań głównym selektorem. Testowanie alternatywnych selektorów...\");\r\n\r\n            // Try alternative selectors\r\n            const altSelectors = [\r\n                '.v-test-go-body',\r\n                '.Qr7Oae',\r\n\r\n            ];\r\n\r\n            for (const selector of altSelectors) {\r\n                const altQuestions = document.querySelectorAll(selector);\r\n                //(`Alternatywny selektor \"${selector}\" znalazł ${altQuestions.length} elementów`);\r\n\r\n                // If we found questions with this selector, use them\r\n                if (altQuestions.length > 0) {\r\n                    questions = altQuestions;\r\n                    //(`Używanie alternatywnego selektora: ${selector}`);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Wait a moment for the form to fully render\r\n        await new Promise(resolve => setTimeout(resolve, 1000));\r\n\r\n        const results = [];\r\n\r\n        //(`Przetwarzanie ${questions.length} pytań...`);\r\n\r\n        for (let i = 0; i < questions.length; i++) {\r\n            const questionElement = questions[i];\r\n\r\n            // Wait briefly for any dynamic content to load\r\n            await new Promise(resolve => setTimeout(resolve, 500));\r\n\r\n            //(`Przetwarzanie pytania ${i + 1} z ${questions.length}`);\r\n\r\n            try {\r\n                const qData = await handleQuestionGoogleForms(questionElement, markingMode);\r\n                if (qData) {\r\n                    results.push(qData);\r\n                    //(`Pomyślnie przetworzono pytanie  ${i + 1} `);\r\n                } else {\r\n                    //(`Nie udało się przetworzyć pytania ${i + 1}`);\r\n                }\r\n            } catch (err) {\r\n                //(`Błąd przetwarzania pytania ${i + 1}: ${err.message}`);\r\n            }\r\n        }\r\n\r\n        document.body.style.cursor = 'default';\r\n        //(`Przetworzono ${results.length} z ${questions.length} pytań pomyślnie`);\r\n\r\n        return results;\r\n    } catch (error) {\r\n        document.body.style.cursor = 'default';\r\n        //(`Krytyczny błąd w processVseosvita: ${error.message}`);\r\n        return [];\r\n    }\r\n}\r\n\r\n// Initialize when the page is fully loaded\r\nif (document.readyState === 'complete') {\r\n    //(\"Dokument już załadowany, inicjalizacja przetwarzania formularza...\");\r\n    setTimeout(processVseosvita, 2000);\r\n} else {\r\n    //(\"Oczekiwanie na załadowanie dokumentu...\");\r\n    document.addEventListener('DOMContentLoaded', function () {\r\n        //(\"Dokument załadowany, inicjalizacja przetwarzania formularza...\");\r\n        setTimeout(processVseosvita, 2000);\r\n    });\r\n}\r\n\r\n\r\n","// W content_script.js - Zaktualizuj tę funkcję dla Naurok\r\n\r\n// W content_script.js - Zaktualizuj tę funkcję dla Naurok\r\n\r\nfunction extractNaurokAnalytics() {\r\n    // console.log(\"Naurok Scraper: Starting extraction (v5 - Revised Label Processing)...\");\r\n    const analytics = {\r\n        platform: \"Naurok\",\r\n        scoreEarned: null,\r\n        scorePossible: null,\r\n        scorePercentage: null,\r\n        quizTitle: null,\r\n        homeworkTitle: null,\r\n        teacher: null,\r\n        student: null,\r\n        dateTime: null,\r\n        totalQuestions: null,\r\n        correctAnswersCount: null,\r\n        incorrectAnswersCount: null,\r\n        skippedAnswersCount: 0,\r\n        totalTime: null,\r\n        averageTimePerQuestion: null,\r\n        questionsScoreRatio: null,\r\n        questions: [],\r\n        _rawScoreData: null,\r\n        _rawPercentageResult: null,\r\n        _rawAccuracyPercentage: null,\r\n        error: null\r\n    };\r\n\r\n    const quizInfoContainer = document.querySelector('.homework-result-info');\r\n    // console.log(\"Naurok Scraper: quizInfoContainer found?\", !!quizInfoContainer);\r\n\r\n    if (!quizInfoContainer) {\r\n        analytics.error = \"Main content container '.homework-result-info' not found.\";\r\n        // console.log(\"Naurok Scraper:\", analytics.error);\r\n        return analytics;\r\n    }\r\n\r\n    try {\r\n        analytics.quizTitle = quizInfoContainer.querySelector('.homework-personal-stat-test')?.innerText.trim() || null;\r\n        const detailsDiv = quizInfoContainer.querySelector('div[style=\"font-size:14px; line-height:1.5;\"]');\r\n        if (detailsDiv) {\r\n            const detailElements = detailsDiv.querySelectorAll('div');\r\n            analytics.homeworkTitle = detailElements[0]?.innerText.replace('ДЗ: ', '').trim() || null;\r\n            analytics.teacher = detailElements[1]?.innerText.replace('Вчитель: ', '').trim() || null;\r\n            analytics.student = detailElements[2]?.innerText.replace('Виконав(ла): ', '').trim() || null;\r\n            analytics.dateTime = detailElements[3]?.innerText.trim() || null;\r\n        }\r\n\r\n        const totalQuestionsElement = quizInfoContainer.querySelector('.homework-personal-stat-number');\r\n        if (totalQuestionsElement && totalQuestionsElement.firstChild) {\r\n            const totalQuestionsText = totalQuestionsElement.firstChild.textContent.trim();\r\n            if (!isNaN(parseInt(totalQuestionsText))) {\r\n                analytics.totalQuestions = parseInt(totalQuestionsText);\r\n            }\r\n        }\r\n        // console.log(\"Naurok Scraper: Basic info - Title:\", analytics.quizTitle, \"TotalQ:\", analytics.totalQuestions);\r\n\r\n        // --- NOWA LOGIKA PRZETWARZANIA ETYKIET I WARTOŚCI ---\r\n        const allLabelElements = quizInfoContainer.querySelectorAll('.homework-personal-stat-label');\r\n        // console.log(\"Naurok Scraper: Found allLabelElements count:\", allLabelElements.length);\r\n\r\n        allLabelElements.forEach((labelElement, index) => {\r\n            const labelText = labelElement.innerText.trim();\r\n            const labelTextUpper = labelText.toUpperCase(); // Do porównań niezależnych od wielkości liter\r\n\r\n            let valueElement = null;\r\n            let spanValue = null;\r\n            let valueFullText = null; // Pełny tekst z elementu wartości\r\n\r\n            const labelColumn = labelElement.closest('div[class*=\"col-\"]');\r\n            if (labelColumn && labelColumn.nextElementSibling) {\r\n                const valueCell = labelColumn.nextElementSibling;\r\n                if (labelTextUpper === 'ТОЧНІСТЬ') {\r\n                    valueElement = valueCell.querySelector('.progress'); // Specjalny przypadek dla paska\r\n                } else {\r\n                    valueElement = valueCell.querySelector('.homework-personal-stat-value');\r\n                }\r\n\r\n                if (valueElement) {\r\n                    spanValue = valueElement.querySelector('span')?.innerText.trim(); // Może być null\r\n                    valueFullText = valueElement.innerText.trim();\r\n                }\r\n            }\r\n\r\n            // console.log(`Naurok Scraper: Processing Label Element ${index} - Text: \"${labelText}\", Upper: \"${labelTextUpper}\", ValueElement found: ${!!valueElement}, SpanValue: \"${spanValue}\", ValueFullText: \"${valueFullText}\"`);\r\n\r\n            if (labelTextUpper === 'ОЦІНКА' && valueElement && spanValue) {\r\n                const parts = spanValue.split('/').map(s => s.trim());\r\n                if (parts.length === 2 && !isNaN(parseInt(parts[0])) && !isNaN(parseInt(parts[1]))) {\r\n                    analytics._rawScoreData = { earned: parseInt(parts[0]), total: parseInt(parts[1]), unit: valueFullText.split(/\\s+/).pop() };\r\n                    // console.log(\"Naurok Scraper: Parsed 'ОЦІНКА':\", analytics._rawScoreData);\r\n                } else {\r\n                    console.warn(\"Naurok Scraper: Failed to parse 'ОЦІНКА' from spanValue:\", spanValue, \"Parts:\", parts);\r\n                }\r\n            } else if (labelTextUpper === 'РЕЗУЛЬТАТ' && valueElement && spanValue) {\r\n                if (!isNaN(parseFloat(spanValue))) {\r\n                    analytics._rawPercentageResult = parseFloat(spanValue);\r\n                    // console.log(\"Naurok Scraper: Parsed 'РЕЗУЛЬТАТ' (percentage):\", analytics._rawPercentageResult);\r\n                } else {\r\n                    console.warn(\"Naurok Scraper: Failed to parse 'РЕЗУЛЬТАТ' from spanValue:\", spanValue);\r\n                }\r\n            } else if (labelTextUpper === 'ТОЧНІСТЬ' && valueElement) { // valueElement to .progress\r\n                const progressBar = valueElement.querySelector('.progress-bar');\r\n                if (progressBar && progressBar.style.width) {\r\n                    const accuracyValText = progressBar.style.width.replace('%', '');\r\n                    if (!isNaN(parseFloat(accuracyValText))) {\r\n                        analytics._rawAccuracyPercentage = parseFloat(accuracyValText);\r\n                        // console.log(\"Naurok Scraper: Parsed 'ТОЧНІСТЬ' (accuracy %):\", analytics._rawAccuracyPercentage);\r\n                    } else {\r\n                        console.warn(\"Naurok Scraper: Could not parse float from Точність progress bar width:\", progressBar.style.width);\r\n                    }\r\n                } else {\r\n                    console.warn(\"Naurok Scraper: Progress bar or its width not found for 'ТОЧНІСТЬ'. ValueElement was:\", valueElement);\r\n                }\r\n            }\r\n            // Można dodać obsługę 'СУМА БАЛІВ' jeśli jest potrzebna do czegoś innego\r\n        });\r\n\r\n\r\n        // --- Przetwarzanie wierszy bez etykiet (liczniki poprawnych/niepoprawnych, czas) ---\r\n        // console.log(\"Naurok Scraper: Processing unlabeled rows...\");\r\n        const unlabeledStatRows = Array.from(quizInfoContainer.querySelectorAll('.homework-personal-stat-row'))\r\n            .filter(row => !row.querySelector('.homework-personal-stat-label'));\r\n        // console.log(\"Naurok Scraper: Found unlabeledStatRows count:\", unlabeledStatRows.length);\r\n\r\n        // Liczniki\r\n        const countsRow = unlabeledStatRows.find(row => {\r\n            const valuesText = Array.from(row.querySelectorAll('.homework-personal-stat-value')).map(el => el.innerText.trim()).join(' ');\r\n            return valuesText.includes('правильних') && valuesText.includes('неправильних');\r\n        });\r\n        // console.log(\"Naurok Scraper: countsRow found?\", !!countsRow);\r\n        if (countsRow) {\r\n            const valueDivs = countsRow.querySelectorAll('.homework-personal-stat-value');\r\n            const correctDiv = Array.from(valueDivs).find(d => d.innerText.includes('правильних'));\r\n            if (correctDiv) {\r\n                const spanText = correctDiv.querySelector('span')?.innerText.trim();\r\n                if (spanText && !isNaN(parseInt(spanText))) analytics.correctAnswersCount = parseInt(spanText);\r\n            }\r\n            const incorrectDiv = Array.from(valueDivs).find(d => d.innerText.includes('неправильних'));\r\n            if (incorrectDiv) {\r\n                const spanText = incorrectDiv.querySelector('span')?.innerText.trim();\r\n                if (spanText && !isNaN(parseInt(spanText))) analytics.incorrectAnswersCount = parseInt(spanText);\r\n            } else { analytics.incorrectAnswersCount = 0; }\r\n            const skippedDiv = Array.from(valueDivs).find(d => d.innerText.includes('пропущено'));\r\n            if (skippedDiv) {\r\n                const spanText = skippedDiv.querySelector('span')?.innerText.trim();\r\n                if (spanText && !isNaN(parseInt(spanText))) analytics.skippedAnswersCount = parseInt(spanText);\r\n            } else { analytics.skippedAnswersCount = 0; }\r\n        }\r\n        // console.log(`Naurok Scraper: Counts - Correct: ${analytics.correctAnswersCount}, Incorrect: ${analytics.incorrectAnswersCount}, Skipped: ${analytics.skippedAnswersCount}`);\r\n\r\n        // Czas\r\n        const timeRow = unlabeledStatRows.find(row => {\r\n            const valuesText = Array.from(row.querySelectorAll('.homework-personal-stat-value')).map(el => el.innerText.trim()).join(' ');\r\n            return valuesText.includes('Всього часу') && valuesText.includes('Ср. час / запитання');\r\n        });\r\n        // console.log(\"Naurok Scraper: timeRow found?\", !!timeRow);\r\n        if (timeRow) {\r\n            const totalTimeDiv = Array.from(timeRow.querySelectorAll('.homework-personal-stat-value')).find(d => d.innerText.includes('Всього часу'));\r\n            if (totalTimeDiv) analytics.totalTime = totalTimeDiv.querySelector('span')?.innerText.trim();\r\n            const avgTimeDiv = Array.from(timeRow.querySelectorAll('.homework-personal-stat-value')).find(d => d.innerText.includes('Ср. час / запитання'));\r\n            if (avgTimeDiv) analytics.averageTimePerQuestion = avgTimeDiv.querySelector('span')?.innerText.trim();\r\n        }\r\n        // console.log(`Naurok Scraper: Time - Total: ${analytics.totalTime}, Avg: ${analytics.averageTimePerQuestion}`);\r\n\r\n        if (typeof analytics.correctAnswersCount === 'number' && typeof analytics.totalQuestions === 'number' && analytics.totalQuestions > 0) {\r\n            analytics.questionsScoreRatio = `${analytics.correctAnswersCount}/${analytics.totalQuestions}`;\r\n        }\r\n        // console.log(\"Naurok Scraper: questionsScoreRatio:\", analytics.questionsScoreRatio);\r\n\r\n\r\n        // --- Mapowanie na ustandaryzowane pola ---\r\n        // console.log(\"Naurok Scraper: Attempting to map to standardized score fields. _rawScoreData:\", analytics._rawScoreData, \"_rawPercentageResult:\", analytics._rawPercentageResult, \"_rawAccuracyPercentage:\", analytics._rawAccuracyPercentage);\r\n        if (analytics._rawScoreData && typeof analytics._rawScoreData.earned === 'number' && typeof analytics._rawScoreData.total === 'number') {\r\n            analytics.scoreEarned = analytics._rawScoreData.earned;\r\n            analytics.scorePossible = analytics._rawScoreData.total;\r\n        }\r\n        if (typeof analytics._rawPercentageResult === 'number') {\r\n            analytics.scorePercentage = analytics._rawPercentageResult;\r\n        } else if (typeof analytics._rawAccuracyPercentage === 'number') { // Fallback na procent z \"Точність\"\r\n            analytics.scorePercentage = analytics._rawAccuracyPercentage;\r\n        }\r\n        if (analytics.scorePercentage === null && analytics.scoreEarned !== null && analytics.scorePossible !== null && analytics.scorePossible > 0) {\r\n            analytics.scorePercentage = parseFloat(((analytics.scoreEarned / analytics.scorePossible) * 100).toFixed(1));\r\n        }\r\n        // console.log(`Naurok Scraper: Standardized - scoreEarned: ${analytics.scoreEarned}, scorePossible: ${analytics.scorePossible}, scorePercentage: ${analytics.scorePercentage}`);\r\n\r\n\r\n        // --- Questions and Answers ---\r\n        analytics.questions = [];\r\n        const questionBlocks = document.querySelectorAll('.homework-stats .content-block');\r\n        questionBlocks.forEach((block, index) => {\r\n            const questionData = {};\r\n            const questionLineElement = block.querySelector('.homework-stat-question-line');\r\n            if (!questionLineElement) return;\r\n            const questionTextElement = questionLineElement.querySelector('p');\r\n            questionData.questionText = questionTextElement ? questionTextElement.innerText.trim() : `Pytanie ${index + 1} (brak tekstu)`;\r\n            const fullQuestionLineText = questionLineElement.innerText.trim();\r\n            const questionNumberMatch = fullQuestionLineText.match(/^(\\d+)\\./);\r\n            questionData.questionNumber = questionNumberMatch ? parseInt(questionNumberMatch[1]) : (index + 1);\r\n            questionData.options = [];\r\n            const optionLines = block.querySelectorAll('.homework-stat-option-line');\r\n            optionLines.forEach(optLine => {\r\n                const optionValueDiv = optLine.querySelector('.homework-stat-option-value');\r\n                if (optionValueDiv) {\r\n                    const optionTextP = optionValueDiv.querySelector('p');\r\n                    const optionText = optionTextP ? optionTextP.innerText.trim() : '';\r\n                    const isCorrect = optionValueDiv.classList.contains('correct');\r\n                    const isUserAnswer = !!optionValueDiv.querySelector('em');\r\n                    questionData.options.push({ text: optionText, isCorrect: isCorrect, isUserAnswer: isUserAnswer });\r\n                }\r\n            });\r\n            const pointsLabelElement = block.querySelector('.question-label');\r\n            questionData.pointsAwarded = pointsLabelElement ? pointsLabelElement.innerText.trim() : 'N/A';\r\n            questionData.isAnsweredCorrectly = block.classList.contains('success');\r\n            analytics.questions.push(questionData);\r\n        });\r\n\r\n    } catch (e) {\r\n        analytics.error = `Critical extraction error: ${e.message} at ${e.stack}`;\r\n        // console.log(\"Naurok Scraper:\", analytics.error);\r\n    }\r\n\r\n    delete analytics._rawScoreData;\r\n    delete analytics._rawPercentageResult;\r\n    delete analytics._rawAccuracyPercentage;\r\n\r\n    // console.log(\"Naurok Scraper: Final standardized data for Naurok to be sent:\", JSON.parse(JSON.stringify(analytics)));\r\n    return analytics;\r\n}\r\n\r\n// Execute the function and print the results in a pretty format\r\n\r\n\r\nfunction extractTestportalAnalytics() {\r\n    const analytics = {\r\n        platform: \"Testportal\",\r\n        testTitle: null,\r\n        resultPageUrl: window.location.href,\r\n        respondentIdentifier: null,\r\n        scorePercentage: null,\r\n        pointsEarned: null,\r\n        pointsPossible: null,\r\n        testStatus: null, // e.g., \"Test zdany\", \"Wynik ukryty\"\r\n        timeTaken: null,\r\n        timeMax: null,\r\n        startTime: null,\r\n        endTime: null,\r\n        date: null,\r\n        totalQuestionsCountFromHeader: null, // From \"(X)\" near \"Pytania\"\r\n        questions: [],\r\n        // Fields to be added by the main content script caller\r\n        // userEmail: null,\r\n        // scrapedAt: null,\r\n    };\r\n\r\n    try {\r\n        // --- Test Name ---\r\n        analytics.testTitle = document.querySelector('.test-name')?.innerText.trim() || null;\r\n\r\n        // --- Respondent Identifier ---\r\n        // Usually in a tile with title \"Rozwiązujący\"\r\n        const respondentTile = Array.from(document.querySelectorAll('.test-card')).find(card => card.querySelector('.test-page-title')?.innerText.trim() === 'Rozwiązujący');\r\n        analytics.respondentIdentifier = respondentTile?.querySelector('.mdc-typography--headline4')?.innerText.trim() || null;\r\n\r\n        // --- Overall Result ---\r\n        const resultTile = Array.from(document.querySelectorAll('.result-tile .test-card')).find(card => card.querySelector('.test-page-title')?.innerText.trim() === 'Wynik');\r\n        if (resultTile) {\r\n            const percentageEl = resultTile.querySelector('.donut-percents');\r\n            if (percentageEl) {\r\n                analytics.scorePercentage = parseFloat(percentageEl.innerText.trim().replace('%', '')) || null;\r\n            }\r\n\r\n            const pointsEl = resultTile.querySelector('.donut-sub-value');\r\n            if (pointsEl) {\r\n                const pointsMatch = pointsEl.innerText.trim().match(/(\\d+)\\s*\\/\\s*(\\d+)/);\r\n                if (pointsMatch && pointsMatch.length === 3) {\r\n                    analytics.pointsEarned = parseInt(pointsMatch[1]);\r\n                    analytics.pointsPossible = parseInt(pointsMatch[2]);\r\n                }\r\n            }\r\n            analytics.testStatus = resultTile.querySelector('.test-sheet-summary-header .mdc-typography--headline4')?.innerText.trim() || \"Status nieznany\";\r\n        } else {\r\n            // Handle cases where the entire result tile might be missing or different\r\n            const hiddenResultMessage = Array.from(document.querySelectorAll('.test-card-body p'))\r\n                .find(p => p.innerText.toLowerCase().includes('wynik testu jest ukryty') || p.innerText.toLowerCase().includes('wynik będzie dostępny później'));\r\n            if (hiddenResultMessage) {\r\n                analytics.testStatus = hiddenResultMessage.innerText.trim();\r\n            }\r\n        }\r\n\r\n\r\n        // --- Time Information ---\r\n        const timerTile = Array.from(document.querySelectorAll('.timer-tile .test-card')).find(card => card.querySelector('.test-page-title')?.innerText.trim() === 'Czas');\r\n        if (timerTile) {\r\n            analytics.timeTaken = timerTile.querySelector('.configuration-progress__text')?.firstChild?.textContent?.trim() || null;\r\n            analytics.timeMax = timerTile.querySelector('.configuration-progress__text-total-time')?.innerText.trim().replace('/', '').trim() || null;\r\n\r\n            const timeProperties = timerTile.querySelectorAll('.timer-tile-properties-container .mdc-property');\r\n            timeProperties.forEach(prop => {\r\n                const label = prop.querySelector('.mdc-property-label')?.innerText.trim();\r\n                const value = prop.querySelector('.mdc-property-value')?.innerText.trim();\r\n                if (label === 'Start') analytics.startTime = value;\r\n                if (label === 'Koniec') analytics.endTime = value;\r\n                if (label === 'Data') analytics.date = value;\r\n            });\r\n        }\r\n\r\n        // --- Total Questions Count (from header) ---\r\n        const questionsHeaderCounter = document.querySelector('.questions-list-top-bar .test-page-title__counter');\r\n        if (questionsHeaderCounter) {\r\n            const match = questionsHeaderCounter.innerText.trim().match(/\\((\\d+)\\)/);\r\n            if (match && match[1]) {\r\n                analytics.totalQuestionsCountFromHeader = parseInt(match[1]);\r\n            }\r\n        }\r\n\r\n        // --- Individual Questions ---\r\n        const questionContainers = document.querySelectorAll('.question-container');\r\n        questionContainers.forEach((qContainer, index) => {\r\n            const questionData = {\r\n                questionNumberText: null, // e.g. \"Pyt. 1\"\r\n                questionNumber: index + 1, // Fallback\r\n                questionTextHTML: null,\r\n                pointsEarnedForQuestion: null,\r\n                pointsPossibleForQuestion: null,\r\n                isAnsweredCorrectly: null, // boolean\r\n                options: [], // For multiple-choice\r\n                userAnswerText: null, // For short answer\r\n                possibleCorrectAnswersText: [], // For short answer\r\n                userSelectedOptionIds: [],\r\n            };\r\n\r\n            try {\r\n                questionData.questionNumberText = qContainer.querySelector('.question_header_content')?.innerText.trim() || `Pyt. ${index + 1}`;\r\n                const numMatch = questionData.questionNumberText.match(/Pyt\\.\\s*(\\d+)/i);\r\n                if (numMatch && numMatch[1]) questionData.questionNumber = parseInt(numMatch[1]);\r\n\r\n                questionData.questionTextHTML = qContainer.querySelector('.question_essence')?.innerHTML.trim() || \"\";\r\n\r\n                // Points for the question (e.g., \"0/1p\" or \"1/1p\")\r\n                const pointsMarkerEl = qContainer.querySelector('.question-score-marker span[class*=\"theme-color-\"]');\r\n                if (pointsMarkerEl) {\r\n                    const pointsText = pointsMarkerEl.innerText.trim();\r\n                    const pointsMatch = pointsText.match(/(\\d+)\\s*\\/\\s*(\\d+)/);\r\n                    if (pointsMatch && pointsMatch.length === 3) {\r\n                        questionData.pointsEarnedForQuestion = parseInt(pointsMatch[1]);\r\n                        questionData.pointsPossibleForQuestion = parseInt(pointsMatch[2]);\r\n                        questionData.isAnsweredCorrectly = (questionData.pointsEarnedForQuestion === questionData.pointsPossibleForQuestion && questionData.pointsPossibleForQuestion > 0);\r\n                    }\r\n                }\r\n                // Alternative check for correctness if points are not explicit but visual icon is there\r\n                if (questionData.isAnsweredCorrectly === null) {\r\n                    const correctIconInHeader = qContainer.querySelector('.question-header--right-panel .question-score-marker span.theme-color-green');\r\n                    const incorrectIconInHeader = qContainer.querySelector('.question-header--right-panel .question-score-marker span.theme-color-error');\r\n                    if (correctIconInHeader) questionData.isAnsweredCorrectly = true;\r\n                    else if (incorrectIconInHeader) questionData.isAnsweredCorrectly = false;\r\n                }\r\n\r\n\r\n                // User selected answer IDs (from question markers attribute)\r\n                const questionMarkersDiv = qContainer.querySelector('.question-markers');\r\n                const selectedAnswerIdsAttr = questionMarkersDiv?.getAttribute('selectedanswerids');\r\n                if (selectedAnswerIdsAttr) {\r\n                    try {\r\n                        // Testportal's selectedanswerids can be a JSON string array or a single ID\r\n                        // For safety, let's try to parse as JSON array, if fails, treat as single ID\r\n                        let ids = [];\r\n                        if (selectedAnswerIdsAttr.startsWith('[')) { // Check if it looks like a JSON array\r\n                            ids = JSON.parse(selectedAnswerIdsAttr);\r\n                        } else if (selectedAnswerIdsAttr) { // Treat as a single ID string if not an array\r\n                            ids = [selectedAnswerIdsAttr];\r\n                        }\r\n                        questionData.userSelectedOptionIds = Array.isArray(ids) ? ids : (ids ? [ids] : []);\r\n                    } catch (e) {\r\n                        console.warn(\"Testportal Scraper: Could not parse selectedanswerids JSON:\", selectedAnswerIdsAttr, e);\r\n                        // If JSON parsing fails but attribute exists, treat it as a single ID string\r\n                        if (selectedAnswerIdsAttr) questionData.userSelectedOptionIds = [selectedAnswerIdsAttr];\r\n                    }\r\n                }\r\n\r\n\r\n                // Handle different question types (multiple choice vs short answer)\r\n                const answerElements = qContainer.querySelectorAll('.answer-with-marker');\r\n                if (answerElements.length > 0) { // Likely multiple choice\r\n                    answerElements.forEach(ansEl => {\r\n                        const option = {\r\n                            text: ansEl.querySelector('.answer_body p, .answer_body img')?.outerHTML.trim() || ansEl.querySelector('.answer_body')?.innerText.trim() || \"\",\r\n                            isCorrect: ansEl.querySelector('.answer_container.correct-answer-container') !== null || ansEl.querySelector('i.answer-correctness-mark.correct-answer-color, i.answer-correctness-mark svg[stroke=\"#0BC279\"]') !== null,\r\n                            isUserSelected: false,\r\n                        };\r\n                        const inputElement = ansEl.querySelector('input[type=\"checkbox\"], input[type=\"radio\"]');\r\n                        if (inputElement) {\r\n                            const answerIdFromInput = inputElement.id?.split(':')[1]; // e.g., id=\"answer:ID_HERE:selected\"\r\n                            if (answerIdFromInput && questionData.userSelectedOptionIds.includes(answerIdFromInput)) {\r\n                                option.isUserSelected = true;\r\n                            }\r\n                        }\r\n                        questionData.options.push(option);\r\n                    });\r\n                } else { // Potentially short answer\r\n                    const providedAnswerEl = qContainer.querySelector('.provided-short-answer p');\r\n                    if (providedAnswerEl) {\r\n                        questionData.userAnswerText = providedAnswerEl.innerText.trim();\r\n                    }\r\n                    const possibleAnswerElements = qContainer.querySelectorAll('.possible-answer-option--text');\r\n                    if (possibleAnswerElements.length > 0) {\r\n                        possibleAnswerElements.forEach(paEl => {\r\n                            questionData.possibleCorrectAnswersText.push(paEl.innerText.trim());\r\n                        });\r\n                    }\r\n                    // Check correctness for short answer if not already set by points\r\n                    if (questionData.isAnsweredCorrectly === null && qContainer.querySelector('.short-provided-answer-review-container i.correct-answer-color')) {\r\n                        questionData.isAnsweredCorrectly = true;\r\n                    } else if (questionData.isAnsweredCorrectly === null && qContainer.querySelector('.short-provided-answer-review-container i.wrong-answer-color')) {\r\n                        questionData.isAnsweredCorrectly = false;\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                console.warn(`Testportal Scraper: Error processing question ${index + 1}:`, e, qContainer);\r\n            }\r\n            analytics.questions.push(questionData);\r\n        });\r\n\r\n    } catch (error) {\r\n        // console.log(\"Testportal Scraper: Critical error during data extraction:\", error);\r\n        // Optionally return partial data or a specific error object\r\n        analytics.error = `Extraction failed: ${error.message}`;\r\n    }\r\n\r\n    // If totalQuestionsCountFromHeader is available and questions array length differs, log warning\r\n    if (analytics.totalQuestionsCountFromHeader !== null && analytics.questions.length !== analytics.totalQuestionsCountFromHeader) {\r\n        console.warn(`Testportal Scraper: Mismatch in question count. Header: ${analytics.totalQuestionsCountFromHeader}, Found: ${analytics.questions.length}`);\r\n    }\r\n    // Use the actual number of questions found if header count is not reliable or missing\r\n    analytics.totalQuestionsFound = analytics.questions.length;\r\n\r\n\r\n    // Calculate correctAnswersCount if not directly available but per-question data is\r\n    if (analytics.pointsEarned === null && analytics.questions.length > 0) {\r\n        let calculatedCorrect = 0;\r\n        let calculatedPossiblePoints = 0;\r\n        let calculatedEarnedPoints = 0;\r\n        let allQuestionsHavePoints = true;\r\n\r\n        analytics.questions.forEach(q => {\r\n            if (q.isAnsweredCorrectly === true) {\r\n                calculatedCorrect++;\r\n            }\r\n            if (typeof q.pointsEarnedForQuestion === 'number' && typeof q.pointsPossibleForQuestion === 'number') {\r\n                calculatedEarnedPoints += q.pointsEarnedForQuestion;\r\n                calculatedPossiblePoints += q.pointsPossibleForQuestion;\r\n            } else {\r\n                allQuestionsHavePoints = false; // If any question doesn't have points, overall score from questions is unreliable\r\n            }\r\n        });\r\n        analytics.calculatedCorrectAnswersCount = calculatedCorrect;\r\n        if (allQuestionsHavePoints && calculatedPossiblePoints > 0) { // Only set if all questions had point data\r\n            analytics.pointsEarned = calculatedEarnedPoints;\r\n            analytics.pointsPossible = calculatedPossiblePoints;\r\n            if (calculatedPossiblePoints > 0) {\r\n                analytics.scorePercentage = parseFloat(((calculatedEarnedPoints / calculatedPossiblePoints) * 100).toFixed(1));\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return analytics;\r\n}\r\n\r\n\r\n// Do dodania w content_script.js\r\nfunction extractVseosvitaAnalytics() {\r\n    // console.log(\"Vseosvita Scraper: Starting extraction...\");\r\n    const analytics = {\r\n        platform: \"Vseosvita\",\r\n        userEmail: null, // Wypełniane przez główną logikę content_script\r\n        scrapedAt: null, // Wypełniane przez główną logikę content_script\r\n        pageUrl: window.location.href,\r\n\r\n        testTitle: null,\r\n        testAttemptId: null, // Specyficzne dla Vseosvita\r\n        respondentIdentifier: null, // Na razie brak wyraźnego identyfikatora użytkownika w podsumowaniu Vseosvita\r\n\r\n        dateTimeCompleted: null, // Spróbujemy sparsować do ISO, jeśli się da\r\n        durationInSeconds: null, // Czas trwania w sekundach\r\n\r\n        scoreEarned: null,          // np. 9 (z \"9 з 12 балів\") - główny wynik\r\n        scorePossible: null,        // np. 12 (z \"9 з 12 балів\") - główny wynik\r\n        scorePercentage: null,      // Obliczone z scoreEarned/scorePossible\r\n        resultStatus: null,         // np. \"Зараховано\"\r\n\r\n        totalQuestions: null,\r\n        correctAnswersCount: null,  // Liczba w pełni poprawnych odpowiedzi\r\n        incorrectAnswersCount: null,\r\n        partiallyCorrectAnswersCount: 0,\r\n        skippedAnswersCount: null,   // Obliczone, jeśli to możliwe\r\n\r\n        questions: [], // Pozostaje puste dla Vseosvita, bo nie ma szczegółów pytań\r\n\r\n        platformDetails: {\r\n            vseosvita_dateTimeFullString: null,\r\n            vseosvita_durationString: null,\r\n            vseosvita_finalScoreString: null, // Oryginalny string wyniku, np. \"9 з 12 балів (Зараховано)\"\r\n            vseosvita_rawPointsEarned: null,  // np. 15.1 (Сумарний бал за відповіді)\r\n            vseosvita_rawPointsPossible: null,// np. 20 (Максимальний бал за всі правильні відповіді)\r\n            vseosvita_pointsFromCorrect: null,// Punkty tylko z w pełni poprawnych odpowiedzi\r\n            vseosvita_partiallyCorrectDetails: [], // [{ count, pointsPerQuestion, earnedPoints, maxPointsPerQuestion }]\r\n            vseosvita_pointsFromPartiallyCorrect: 0,\r\n            vseosvita_gradingSystemDetails: null,\r\n            vseosvita_finalGradeCalculationString: null,\r\n        },\r\n        error: null\r\n    };\r\n\r\n    try {\r\n        const mainInfoContainer = document.querySelector('div.v-hello-container.type-container-vo[data-v-499098f8]');\r\n        // console.log(\"Vseosvita Scraper: mainInfoContainer (with data-v) found?\", !!mainInfoContainer);\r\n\r\n        if (!mainInfoContainer) {\r\n            // console.log(\"Vseosvita Scraper: Specific main info container (with data-v-499098f8) not found.\");\r\n            analytics.error = \"Specific main info container not found.\";\r\n            return analytics;\r\n        }\r\n\r\n        // --- Test Attempt ID, Date, Time, Duration ---\r\n        const infoParagraphs = mainInfoContainer.querySelectorAll('div.row_info-test.vertical-center p.text_info-test.silver');\r\n        infoParagraphs.forEach(p => {\r\n            const text = p.innerText.trim();\r\n            if (text.toLowerCase().includes(\"id-код проходження:\")) {\r\n                analytics.testAttemptId = text.replace(/id-код проходження:/i, \"\").trim();\r\n            } else if (text.match(/\\d{1,2}\\s+\\S+\\s+\\d{4}\\s+року о\\s+\\d{2}:\\d{2}/)) {\r\n                analytics.platformDetails.vseosvita_dateTimeFullString = text.split('\\n')[0].trim();\r\n                const durationOuterSpan = p.querySelector('span[title^=\"Час витрачений учнем\"]');\r\n                if (durationOuterSpan) {\r\n                    analytics.platformDetails.vseosvita_durationString = durationOuterSpan.querySelector('span')?.innerText.trim();\r\n                } else {\r\n                    const directDurationSpan = p.querySelector('span[data-v-499098f8] > span[data-v-499098f8]');\r\n                    if (directDurationSpan) analytics.platformDetails.vseosvita_durationString = directDurationSpan.innerText.trim();\r\n                }\r\n            }\r\n        });\r\n        // Próba parsowania daty i czasu trwania\r\n        if (analytics.platformDetails.vseosvita_dateTimeFullString) {\r\n            // Prosta próba parsowania (może wymagać bardziej zaawansowanej logiki dla ukraińskich miesięcy)\r\n            // \"27 травня 2025 року о 22:00\" - na razie nie parsujemy do ISO, bo miesiące\r\n            analytics.dateTimeCompleted = analytics.platformDetails.vseosvita_dateTimeFullString; // Store as string for now\r\n        }\r\n        if (analytics.platformDetails.vseosvita_durationString) {\r\n            // \"01 хв 31 с\"\r\n            const durationMatch = analytics.platformDetails.vseosvita_durationString.match(/(?:(\\d+)\\s*год)?\\s*(?:(\\d+)\\s*хв)?\\s*(?:(\\d+)\\s*с)?/);\r\n            if (durationMatch) {\r\n                const hours = parseInt(durationMatch[1] || 0);\r\n                const minutes = parseInt(durationMatch[2] || 0);\r\n                const seconds = parseInt(durationMatch[3] || 0);\r\n                analytics.durationInSeconds = (hours * 3600) + (minutes * 60) + seconds;\r\n            }\r\n        }\r\n\r\n\r\n        // --- Test Title ---\r\n        const titlePElement = mainInfoContainer.querySelector('p.text_info-test.center.vo-mb1');\r\n        if (titlePElement) {\r\n            analytics.testTitle = titlePElement.querySelector('b[data-v-499098f8]')?.innerText.trim() || null;\r\n        }\r\n\r\n        // --- Final Score String and derived values ---\r\n        const finalScorePElement = mainInfoContainer.querySelector('p.text_info-test.fs36.center.vo-mb2');\r\n        if (finalScorePElement) {\r\n            const finalScoreBElement = finalScorePElement.querySelector('b[data-v-499098f8]');\r\n            if (finalScoreBElement) {\r\n                analytics.platformDetails.vseosvita_finalScoreString = finalScoreBElement.innerText.trim();\r\n                const scoreMatch = analytics.platformDetails.vseosvita_finalScoreString.match(/(\\d+[\\.,]?\\d*)\\s+з\\s+(\\d+[\\.,]?\\d*)\\s+балів(?:\\s*\\((.+)\\))?/i);\r\n                if (scoreMatch) {\r\n                    analytics.scoreEarned = parseFloat(scoreMatch[1]?.replace(',', '.'));\r\n                    analytics.scorePossible = parseFloat(scoreMatch[2]?.replace(',', '.'));\r\n                    if (scoreMatch[3]) {\r\n                        analytics.resultStatus = scoreMatch[3].trim();\r\n                    }\r\n                    if (analytics.scorePossible > 0) {\r\n                        analytics.scorePercentage = parseFloat(((analytics.scoreEarned / analytics.scorePossible) * 100).toFixed(1));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // --- Table with detailed score breakdown ---\r\n        const scoreTableContainer = mainInfoContainer.querySelector('div.table_answers-test[data-v-4b882196]');\r\n        if (scoreTableContainer) {\r\n            const scoreTable = scoreTableContainer.querySelector('table[data-v-4b882196]');\r\n            if (scoreTable) {\r\n                const rows = scoreTable.querySelectorAll('tr[data-v-4b882196]');\r\n                rows.forEach(row => {\r\n                    const cells = row.querySelectorAll('td[data-v-4b882196]');\r\n                    if (cells.length < 2) return;\r\n                    const labelElement = cells[0].querySelector('p.text_info-test > b[data-v-4b882196]');\r\n                    const label = labelElement?.innerText.trim();\r\n                    const valuePCell = cells[1].querySelector('p.text_info-test');\r\n\r\n                    if (label && valuePCell) {\r\n                        const valueText = valuePCell.innerText.trim();\r\n                        if (label.startsWith(\"Всього:\")) {\r\n                            const match = valueText.match(/(\\d+)\\s+запитань/);\r\n                            if (match) analytics.totalQuestions = parseInt(match[1]);\r\n                        } else if (label.startsWith(\"Правильно:\")) {\r\n                            const match = valueText.match(/(\\d+)\\s+запитань\\s*x\\s*[\\d\\.,]+\\s*бал(?:а|ів)?\\s*=\\s*([\\d\\.,]+)\\s*бал/i);\r\n                            if (match) {\r\n                                analytics.correctAnswersCount = parseInt(match[1]);\r\n                                analytics.platformDetails.vseosvita_pointsFromCorrect = parseFloat(match[2].replace(',', '.'));\r\n                            }\r\n                        } else if (label.startsWith(\"Частково правильно:\")) {\r\n                            const partialEntries = cells[1].querySelectorAll('p.text_info-test');\r\n                            analytics.platformDetails.vseosvita_pointsFromPartiallyCorrect = 0; // Reset\r\n                            analytics.partiallyCorrectAnswersCount = 0; // Reset\r\n                            partialEntries.forEach(entryP => {\r\n                                const entryText = entryP.innerText.trim();\r\n                                const match = entryText.match(/(\\d+)\\s+запитан(?:ня|ь)\\s*x\\s*([\\d\\.,]+)\\s*бал(?:а|ів)?\\s*=\\s*([\\d\\.,]+)\\s*бал(?:а|ів)?\\s*\\(максимум\\s*([\\d\\.,]+)\\s*бал/i);\r\n                                if (match) {\r\n                                    const detail = {\r\n                                        count: parseInt(match[1]),\r\n                                        pointsPerQuestion: parseFloat(match[2].replace(',', '.')),\r\n                                        earnedPoints: parseFloat(match[3].replace(',', '.')),\r\n                                        maxPointsPerQuestion: parseFloat(match[4].replace(',', '.'))\r\n                                    };\r\n                                    analytics.platformDetails.vseosvita_partiallyCorrectDetails.push(detail);\r\n                                    analytics.platformDetails.vseosvita_pointsFromPartiallyCorrect += detail.earnedPoints;\r\n                                    analytics.partiallyCorrectAnswersCount += detail.count;\r\n                                }\r\n                            });\r\n                        } else if (label.startsWith(\"Неправильно:\")) {\r\n                            const match = valueText.match(/(\\d+)\\s+запитань/);\r\n                            if (match) analytics.incorrectAnswersCount = parseInt(match[1]);\r\n                        } else if (label.startsWith(\"Розрахунок балів за відповіді:\")) {\r\n                            const earnedB = valuePCell.querySelector('b[title=\"Сумарний бал за відповіді\"]');\r\n                            if (earnedB) {\r\n                                const match = earnedB.innerText.match(/([\\d\\.,]+)/);\r\n                                if (match) analytics.platformDetails.vseosvita_rawPointsEarned = parseFloat(match[1].replace(',', '.'));\r\n                            }\r\n                            const possibleB = valuePCell.querySelector('b[title=\"Максимальний бал за всі правильні відповіді\"]');\r\n                            if (possibleB) {\r\n                                const match = possibleB.innerText.match(/([\\d\\.,]+)/);\r\n                                if (match) analytics.platformDetails.vseosvita_rawPointsPossible = parseFloat(match[1].replace(',', '.'));\r\n                            }\r\n                        } else if (label.startsWith(\"Система оцінювання:\")) {\r\n                            analytics.platformDetails.vseosvita_gradingSystemDetails = valueText;\r\n                        } else if (label.startsWith(\"Розрахунок оцінки:\")) {\r\n                            analytics.platformDetails.vseosvita_finalGradeCalculationString = valueText;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        // Obliczanie skippedAnswersCount, jeśli możliwe\r\n        if (typeof analytics.totalQuestions === 'number' &&\r\n            typeof analytics.correctAnswersCount === 'number' &&\r\n            typeof analytics.incorrectAnswersCount === 'number' &&\r\n            typeof analytics.partiallyCorrectAnswersCount === 'number') {\r\n            analytics.skippedAnswersCount = analytics.totalQuestions -\r\n                analytics.correctAnswersCount -\r\n                analytics.incorrectAnswersCount -\r\n                analytics.partiallyCorrectAnswersCount;\r\n            if (analytics.skippedAnswersCount < 0) analytics.skippedAnswersCount = 0; // Sanity check\r\n        }\r\n\r\n\r\n    } catch (error) {\r\n        // console.log(\"Vseosvita Scraper: Critical error during data extraction:\", error);\r\n        analytics.error = `Extraction failed: ${error.message}`;\r\n    }\r\n    // console.log(\"Vseosvita Scraper: Final standardized data:\", JSON.parse(JSON.stringify(analytics)));\r\n    return analytics;\r\n}\r\n\r\n\r\nfunction extractQuizizzAnalytics() {\r\n    // console.log(\"Quizizz Scraper: Starting extraction...\");\r\n    const analytics = {\r\n        platform: \"Quizizz\",\r\n        userEmail: null, // Wypełniane przez główną logikę content_script\r\n        scrapedAt: null, // Wypełniane przez główną logikę content_script\r\n        pageUrl: window.location.href,\r\n\r\n        testTitle: null, // Quizizz nie wyświetla jednoznacznego tytułu quizu na tej stronie podsumowania; może być w innym miejscu lub niedostępny\r\n        quizMode: null, // np. \"Recenzja solo\"\r\n        playerName: null,\r\n\r\n        // Te pola odnoszą się do \"Dokładności\" pokazywanej przez Quizizz\r\n        accuracyPercentage: null,\r\n        accuracyPointsEarned: null, // np. 9 z \"9 / 19 pts\"\r\n        accuracyPointsPossible: null, // np. 19 z \"9 / 19 pts\"\r\n\r\n        rankString: null, // np. \"13 / 24\"\r\n        gameScore: null,  // Punkty w grze, np. 8960\r\n\r\n        // Te pochodzą z boksów statystyk\r\n        totalQuestions: null, // Obliczone z correct + incorrect + partial\r\n        correctAnswersCount: null,\r\n        incorrectAnswersCount: null,\r\n        partiallyCorrectAnswersCount: null, // Zazwyczaj 0 w Quizizz w tym widoku\r\n\r\n        avgTimePerQuestionString: null, // np. \"3 s\"\r\n        longestStreak: null,\r\n\r\n        questions: [], // Będzie zawierać ograniczoną informację o pytaniach\r\n\r\n        platformDetails: { // Specyficzne dla Quizizz\r\n            quizizz_gameTypeTitle: null,\r\n            quizizz_accuracyRawString: null, // np. \"9 / 19 pts\"\r\n            quizizz_motivationalMessage: null,\r\n        },\r\n        error: null\r\n    };\r\n\r\n    try {\r\n        const mainContainer = document.querySelector('div[data-v-5e383631].screen-container');\r\n        if (!mainContainer) {\r\n            // console.log(\"Quizizz Scraper: Main screen container not found.\");\r\n            analytics.error = \"Main screen container not found.\";\r\n            return analytics;\r\n        }\r\n\r\n        // --- Try to get Test Name if available from breadcrumbs or other sources (often not on summary screen directly)\r\n        // This is an example if a breadcrumb existed. For now, it's often missing on the summary.\r\n        // analytics.testTitle = document.querySelector('.breadcrumbs .quiz-title-breadcrumb')?.innerText.trim() || \"Quizizz Test\";\r\n\r\n\r\n        // --- Quiz Mode ---\r\n        analytics.platformDetails.quizizz_gameTypeTitle = mainContainer.querySelector('.game-type-title[data-cy=\"game-type-title\"]')?.innerText.trim() || null;\r\n        analytics.quizMode = analytics.platformDetails.quizizz_gameTypeTitle;\r\n\r\n\r\n        // --- Player Name ---\r\n        analytics.playerName = mainContainer.querySelector('span[data-testid=\"player-id-desktop\"][data-cy=\"player-name\"]')?.innerText.trim() || null;\r\n\r\n        // --- Motivational Message ---\r\n        analytics.platformDetails.quizizz_motivationalMessage = mainContainer.querySelector('div[data-v-b15e54fe].text-ds-light-300.font-bold.text-xl')?.innerText.trim() || null;\r\n\r\n        // --- Accuracy Info ---\r\n        const accuracySection = mainContainer.querySelector('div[data-v-b15e54fe].accuracy-info-section');\r\n        if (accuracySection) {\r\n            // Procent dokładności jest w tooltipie, który może nie być łatwy do pobrania bez interakcji.\r\n            // Spróbujemy pobrać z etykiety, jeśli tam jest, lub z tooltipa, jeśli jest renderowany.\r\n            // Alternatywnie, obliczymy go, jeśli mamy punkty.\r\n            const accuracyLabelTooltip = accuracySection.querySelector('.accuracy-label-tooltip .tooltip-text[data-cy=\"tooltip-text\"]');\r\n            if (accuracyLabelTooltip) {\r\n                const accText = accuracyLabelTooltip.innerText.trim().replace('%', '');\r\n                if (!isNaN(parseFloat(accText))) {\r\n                    analytics.accuracyPercentage = parseFloat(accText);\r\n                }\r\n            }\r\n\r\n            // Punkty do dokładności (np. \"9 / 19 pts\")\r\n            const accuracyPointsTooltipContent = accuracySection.querySelector('.accuracy-bar + .show-tooltip .content');\r\n            if (accuracyPointsTooltipContent) { // To jest bardziej stabilny selektor dla punktów\r\n                analytics.platformDetails.quizizz_accuracyRawString = accuracyPointsTooltipContent.innerText.trim();\r\n                const pointsMatch = analytics.platformDetails.quizizz_accuracyRawString.match(/(\\d+)\\s*\\/\\s*(\\d+)\\s*pts/);\r\n                if (pointsMatch) {\r\n                    analytics.accuracyPointsEarned = parseInt(pointsMatch[1]);\r\n                    analytics.accuracyPointsPossible = parseInt(pointsMatch[2]);\r\n                    // Oblicz procent, jeśli nie został pobrany z tooltipa\r\n                    if (analytics.accuracyPercentage === null && analytics.accuracyPointsPossible > 0) {\r\n                        analytics.accuracyPercentage = parseFloat(((analytics.accuracyPointsEarned / analytics.accuracyPointsPossible) * 100).toFixed(1));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        // --- Rank and Game Score ---\r\n        analytics.rankString = mainContainer.querySelector('.player-rank[data-cy=\"player-rank\"]')?.innerText.trim() || null;\r\n        const gameScoreEl = mainContainer.querySelector('.player-score[data-cy=\"player-score\"]');\r\n        if (gameScoreEl) {\r\n            analytics.gameScore = parseInt(gameScoreEl.innerText.trim().replace(/\\s/g, '')) || null;\r\n        }\r\n\r\n        // --- Stats Boxes ---\r\n        const statsContainer = mainContainer.querySelector('.stats-container');\r\n        if (statsContainer) {\r\n            const correctEl = statsContainer.querySelector('.stat-box-big.correct-container .value');\r\n            if (correctEl) analytics.correctAnswersCount = parseInt(correctEl.innerText.trim());\r\n\r\n            const partialEl = statsContainer.querySelector('.stat-box-big.partial-container .value');\r\n            if (partialEl) analytics.partiallyCorrectAnswersCount = parseInt(partialEl.innerText.trim());\r\n            else analytics.partiallyCorrectAnswersCount = 0; // Quizizz rzadko używa tego w typowych quizach\r\n\r\n            const incorrectEl = statsContainer.querySelector('.stat-box-big.incorrect-container .value');\r\n            if (incorrectEl) analytics.incorrectAnswersCount = parseInt(incorrectEl.innerText.trim());\r\n\r\n            analytics.avgTimePerQuestionString = statsContainer.querySelector('.stat-box-big.avg-time-container .value')?.innerText.trim() || null;\r\n\r\n            const streakEl = statsContainer.querySelector('.stat-box-big.streak-container .value');\r\n            if (streakEl) analytics.longestStreak = parseInt(streakEl.innerText.trim());\r\n\r\n            // Oblicz totalQuestions na podstawie zebranych statystyk\r\n            if (typeof analytics.correctAnswersCount === 'number' &&\r\n                typeof analytics.incorrectAnswersCount === 'number' &&\r\n                typeof analytics.partiallyCorrectAnswersCount === 'number') {\r\n                analytics.totalQuestions = analytics.correctAnswersCount + analytics.incorrectAnswersCount + analytics.partiallyCorrectAnswersCount;\r\n            }\r\n        }\r\n\r\n        // --- Review Questions Section ---\r\n        // Informacje są ograniczone w tym widoku\r\n        const reviewList = mainContainer.querySelector('.question-review-list');\r\n        if (reviewList) {\r\n            const questionItems = reviewList.querySelectorAll('button.question-container');\r\n            questionItems.forEach(item => {\r\n                const questionData = {\r\n                    questionNumber: null,\r\n                    questionText: null,\r\n                    isAnsweredCorrectlyByUser: null,\r\n                    userTypedAnswer: null, // Jeśli to pytanie otwarte\r\n                    optionsDisplayed: [] // Jeśli MCQ\r\n                };\r\n\r\n                const qTextElement = item.querySelector('.question-text');\r\n                if (qTextElement) {\r\n                    // Próba wyciągnięcia numeru pytania z tekstu\r\n                    const fullText = qTextElement.innerText.trim();\r\n                    const numMatch = fullText.match(/^(\\d+)\\.\\s*/);\r\n                    if (numMatch) {\r\n                        questionData.questionNumber = parseInt(numMatch[1]);\r\n                        questionData.questionText = fullText.replace(numMatch[0], '').trim(); // Usuń numer z tekstu\r\n                    } else {\r\n                        questionData.questionText = fullText;\r\n                    }\r\n                    // Można też zapisać .innerHTML jeśli potrzebne są tagi <p> wewnątrz\r\n                    // questionData.questionTextHTML = qTextElement.querySelector('p')?.innerHTML || qTextElement.innerHTML;\r\n                }\r\n\r\n                // Sprawdź kolor ramki dla poprawności\r\n                const borderColor = item.style.borderColor;\r\n                if (borderColor === 'rgb(0, 201, 133)') { // Green\r\n                    questionData.isAnsweredCorrectlyByUser = true;\r\n                } else if (borderColor === 'rgb(239, 60, 105)') { // Red\r\n                    questionData.isAnsweredCorrectlyByUser = false;\r\n                }\r\n\r\n                // Sprawdź, czy to pytanie otwarte (typed answer)\r\n                const typedAnswerEl = item.querySelector('.typed-answer-response .response-text span');\r\n                if (typedAnswerEl) {\r\n                    questionData.userTypedAnswer = typedAnswerEl.innerText.trim();\r\n                } else {\r\n                    // Jeśli nie otwarte, to prawdopodobnie MCQ - zbierz opcje\r\n                    const optionElements = item.querySelectorAll('.options-container .option-text p');\r\n                    optionElements.forEach(optEl => {\r\n                        questionData.optionsDisplayed.push(optEl.innerText.trim());\r\n                    });\r\n                }\r\n                analytics.questions.push(questionData);\r\n            });\r\n        }\r\n        // Jeśli nie udało się wyliczyć totalQuestions z boksów statystyk, a są pytania w review list:\r\n        if (analytics.totalQuestions === null && analytics.questions.length > 0) {\r\n            analytics.totalQuestions = analytics.questions.length;\r\n        }\r\n\r\n\r\n        // Ustawienie głównych pól wyniku na podstawie \"Dokładności\" jeśli dostępne\r\n        if (analytics.accuracyPointsEarned !== null && analytics.accuracyPointsPossible !== null) {\r\n            analytics.scoreEarned = analytics.accuracyPointsEarned;\r\n            analytics.scorePossible = analytics.accuracyPointsPossible;\r\n            // Procent już powinien być ustawiony, ale dla pewności\r\n            if (analytics.scorePossible > 0) {\r\n                analytics.scorePercentage = parseFloat(((analytics.scoreEarned / analytics.scorePossible) * 100).toFixed(1));\r\n            }\r\n        } else if (analytics.correctAnswersCount !== null && analytics.totalQuestions !== null && analytics.totalQuestions > 0) {\r\n            // Fallback, jeśli \"Dokładność\" nie była dostępna, ale mamy liczbę poprawnych i wszystkich pytań\r\n            // To jest mniej precyzyjne, bo nie uwzględnia punktacji za pytanie\r\n            analytics.scoreEarned = analytics.correctAnswersCount; // Zakładając 1 pkt za pytanie\r\n            analytics.scorePossible = analytics.totalQuestions;\r\n            analytics.scorePercentage = parseFloat(((analytics.scoreEarned / analytics.scorePossible) * 100).toFixed(1));\r\n        }\r\n\r\n\r\n    } catch (error) {\r\n        // console.log(\"Quizizz Scraper: Critical error during data extraction:\", error);\r\n        analytics.error = `Extraction failed: ${error.message}`;\r\n    }\r\n    // console.log(\"Quizizz Scraper: Final standardized data:\", JSON.parse(JSON.stringify(analytics)));\r\n    return analytics;\r\n}\r\n\r\nfunction extractMoodleAnalytics() {\r\n    // console.log(\"Moodle Scraper: Starting extraction...\");\r\n    const analytics = {\r\n        platform: \"Moodle\",\r\n        userEmail: null, // Wypełniane przez główną logikę content_script\r\n        scrapedAt: null, // Wypełniane przez główną logikę content_script\r\n        pageUrl: window.location.href,\r\n\r\n        testTitle: null,\r\n        courseTitle: null,\r\n\r\n        dateTimeStarted: null,\r\n        dateTimeCompleted: null,\r\n        duration: null, // Czas trwania jako string np. \"1 day 23 hours\" lub w sekundach\r\n\r\n        scoreEarned: null,          // Z pola \"Grade\" / \"Ocena\"\r\n        scorePossible: null,        // Z pola \"Grade\" / \"Ocena\"\r\n        scorePercentage: null,      // Z pola \"Grade\" / \"Ocena\"\r\n        resultStatus: null,         // np. \"Finished\", \"Zakończono\"\r\n\r\n        totalQuestions: null,       // Suma pytań w teście\r\n        correctAnswersCount: 0,     // Liczba w pełni poprawnych odpowiedzi\r\n        // incorrectAnswersCount, partiallyCorrectAnswersCount, skippedAnswersCount - mogą być trudne do jednoznacznego określenia bez iteracji po pytaniach\r\n\r\n        questions: [],\r\n\r\n        platformDetails: {\r\n            moodle_marksEarned: null, // Surowe punkty z pola \"Marks\" / \"Punkty\"\r\n            moodle_marksPossible: null,\r\n            moodle_rawGradeString: null, // np. \"6.00 out of 10.00 (60%)\"\r\n            moodle_rawMarksString: null, // np. \"3.00/5.00\"\r\n            moodle_statusString: null,\r\n            moodle_durationString: null,\r\n        },\r\n        error: null\r\n    };\r\n\r\n    // --- Helper function to find row text by various label possibilities ---\r\n    const MOODLE_LABELS = {\r\n        status: ['Status', 'Stan'],\r\n        started: ['Started', 'Rozpoczęto', 'Date taken'],\r\n        completed: ['Completed', 'Ukończono', 'Submitted on', 'Data oddania'],\r\n        duration: ['Duration', 'Wykorzystany czas', 'Time taken', 'Czas trwania'],\r\n        marks: ['Marks', 'Points', 'Punkty'], // Raw score\r\n        grade: ['Grade', 'Ocena', 'Note', 'Bewertung', 'Final grade'] // Scaled grade\r\n    };\r\n\r\n    function findRowTextInSummaryTable(tableBody, labelKeysOrExactLabels) {\r\n        if (!tableBody) return null;\r\n        const rows = Array.from(tableBody.querySelectorAll('tr'));\r\n        for (const row of rows) {\r\n            const th = row.querySelector('th.cell'); // Moodle often uses <th class=\"cell\">\r\n            if (th) {\r\n                const headerText = th.innerText.trim();\r\n                let found = false;\r\n                if (Array.isArray(labelKeysOrExactLabels)) { // Array of keys from MOODLE_LABELS\r\n                    for (const key of labelKeysOrExactLabels) {\r\n                        if (MOODLE_LABELS[key] && MOODLE_LABELS[key].some(label => headerText.toLowerCase().startsWith(label.toLowerCase()))) {\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else if (typeof labelKeysOrExactLabels === 'string') { // Single exact label (case insensitive start)\r\n                    if (headerText.toLowerCase().startsWith(labelKeysOrExactLabels.toLowerCase())) {\r\n                        found = true;\r\n                    }\r\n                }\r\n\r\n                if (found) {\r\n                    const td = row.querySelector('td.cell');\r\n                    return td ? td.innerText.trim() : null;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    try {\r\n        // --- Page Title (often the quiz title) and Course Title (from breadcrumbs) ---\r\n        analytics.testTitle = document.querySelector('#page-header h1.h2')?.innerText.trim() ||\r\n            document.querySelector('h1#page-title')?.innerText.trim() || // Starsze motywy Moodle\r\n            document.title.split(':')[0].trim(); // Fallback na tytuł strony\r\n\r\n        const breadcrumbItems = document.querySelectorAll('#page-navbar .breadcrumb-item a');\r\n        if (breadcrumbItems.length > 0) {\r\n            analytics.courseTitle = breadcrumbItems[0].innerText.trim(); // Pierwszy link w breadcrumbs to zazwyczaj kurs\r\n            if (breadcrumbItems.length > 1 && analytics.testTitle === document.title.split(':')[0].trim()) {\r\n                // Jeśli tytuł quizu nie został znaleziony w h1, spróbuj z breadcrumbs\r\n                const potentialQuizTitleEl = breadcrumbItems[breadcrumbItems.length - 2]; // Przedostatni element przed \"Preview\" lub \"Summary\"\r\n                if (potentialQuizTitleEl && !['Preview', 'Summary', 'Podgląd', 'Podsumowanie'].includes(potentialQuizTitleEl.innerText.trim())) {\r\n                    analytics.testTitle = potentialQuizTitleEl.innerText.trim();\r\n                }\r\n            }\r\n        }\r\n        // console.log(\"Moodle Scraper: Course Title:\", analytics.courseTitle, \"Test Title:\", analytics.testTitle);\r\n\r\n        // --- Summary Table ---\r\n        const summaryTableBody = document.querySelector('table.generaltable.quizreviewsummary tbody, table.generaltable.generalbox.summarytable tbody'); // Różne klasy dla tabeli podsumowania\r\n        // console.log(\"Moodle Scraper: Summary table body found?\", !!summaryTableBody);\r\n\r\n        if (summaryTableBody) {\r\n            analytics.platformDetails.moodle_statusString = findRowTextInSummaryTable(summaryTableBody, ['status']);\r\n            analytics.resultStatus = analytics.platformDetails.moodle_statusString; // np. \"Finished\"\r\n\r\n            const startedStr = findRowTextInSummaryTable(summaryTableBody, ['started']);\r\n            if (startedStr) analytics.dateTimeStarted = parseMoodleDate(startedStr);\r\n\r\n            const completedStr = findRowTextInSummaryTable(summaryTableBody, ['completed']);\r\n            if (completedStr) analytics.dateTimeCompleted = parseMoodleDate(completedStr);\r\n\r\n            analytics.platformDetails.moodle_durationString = findRowTextInSummaryTable(summaryTableBody, ['duration']);\r\n            analytics.duration = analytics.platformDetails.moodle_durationString; // Na razie string\r\n\r\n            // Marks (surowe punkty) e.g., \"3.00/5.00\" or \"3,00/5,00\"\r\n            analytics.platformDetails.moodle_rawMarksString = findRowTextInSummaryTable(summaryTableBody, ['marks']);\r\n            if (analytics.platformDetails.moodle_rawMarksString) {\r\n                const marksMatch = analytics.platformDetails.moodle_rawMarksString.match(/([\\d\\.,]+)\\s*\\/\\s*([\\d\\.,]+)/);\r\n                if (marksMatch) {\r\n                    analytics.platformDetails.moodle_marksEarned = parseFloat(marksMatch[1].replace(',', '.'));\r\n                    analytics.platformDetails.moodle_marksPossible = parseFloat(marksMatch[2].replace(',', '.'));\r\n                }\r\n            }\r\n\r\n            // Grade (ocena skalowana) e.g., \"6.00 out of 10.00 (60%)\" or \"6,00 na 10,00 (60%)\"\r\n            analytics.platformDetails.moodle_rawGradeString = findRowTextInSummaryTable(summaryTableBody, ['grade']);\r\n            if (analytics.platformDetails.moodle_rawGradeString) {\r\n                // Regex próbujący złapać różne formaty: \"X out of Y (Z%)\" lub \"X z Y (Z%)\" lub \"X na Y (Z%)\"\r\n                const gradeMatch = analytics.platformDetails.moodle_rawGradeString.match(/([\\d\\.,]+)\\s*(?:out of|z|na)\\s*([\\d\\.,]+)(?:\\s*\\(([\\d\\.,]+)%\\))?/i);\r\n                if (gradeMatch) {\r\n                    analytics.scoreEarned = parseFloat(gradeMatch[1].replace(',', '.'));\r\n                    analytics.scorePossible = parseFloat(gradeMatch[2].replace(',', '.'));\r\n                    if (gradeMatch[3]) {\r\n                        analytics.scorePercentage = parseFloat(gradeMatch[3].replace(',', '.'));\r\n                    } else if (analytics.scorePossible > 0) {\r\n                        analytics.scorePercentage = parseFloat(((analytics.scoreEarned / analytics.scorePossible) * 100).toFixed(1));\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            console.warn(\"Moodle Scraper: Summary table not found.\");\r\n        }\r\n\r\n        // --- Individual Questions ---\r\n        const questionElements = document.querySelectorAll('div.que'); // Główny kontener pytania\r\n        // console.log(\"Moodle Scraper: Found question elements count:\", questionElements.length);\r\n        analytics.totalQuestions = questionElements.length; // Wstępne ustawienie liczby pytań\r\n\r\n        questionElements.forEach((qElement, index) => {\r\n            const questionData = {\r\n                questionNumber: index + 1,\r\n                questionTextHTML: null,\r\n                isAnsweredCorrectly: null,\r\n                pointsEarned: null,\r\n                pointsPossible: null,\r\n                options: [],\r\n                userAnswerText: [], // Może być wiele odpowiedzi dla niektórych typów\r\n                correctAnswerText: null, // Tekst z sekcji \"The correct answer is:\"\r\n                platformDetails: {\r\n                    moodle_state: null, // np. \"Correct\", \"Incorrect\", \"Partially correct\"\r\n                    moodle_gradeString: null // np. \"Mark 1.00 out of 1.00\"\r\n                }\r\n            };\r\n\r\n            try {\r\n                const qNoElement = qElement.querySelector('.info .no .qno');\r\n                if (qNoElement) {\r\n                    questionData.questionNumber = parseInt(qNoElement.innerText.trim());\r\n                }\r\n\r\n                questionData.platformDetails.moodle_state = qElement.querySelector('.info .state')?.innerText.trim() || null;\r\n                if (questionData.platformDetails.moodle_state) {\r\n                    const stateLower = questionData.platformDetails.moodle_state.toLowerCase();\r\n                    if (stateLower.includes('correct') || stateLower.includes('poprawna')) questionData.isAnsweredCorrectly = true;\r\n                    else if (stateLower.includes('incorrect') || stateLower.includes('niepoprawna')) questionData.isAnsweredCorrectly = false;\r\n                    else if (stateLower.includes('partially correct') || stateLower.includes('częściowo poprawna')) questionData.isAnsweredCorrectly = 'partial'; // Lub true, jeśli częściowe liczymy jako \"coś zdobył\"\r\n                }\r\n\r\n\r\n                questionData.platformDetails.moodle_gradeString = qElement.querySelector('.info .grade')?.innerText.trim() || null;\r\n                if (questionData.platformDetails.moodle_gradeString) {\r\n                    // \"Mark 1.00 out of 1.00\" or \"Ocena 1,00 z 1,00\"\r\n                    const gradeMatch = questionData.platformDetails.moodle_gradeString.match(/([\\d\\.,]+)\\s*(?:out of|z)\\s*([\\d\\.,]+)/i);\r\n                    if (gradeMatch) {\r\n                        questionData.pointsEarned = parseFloat(gradeMatch[1].replace(',', '.'));\r\n                        questionData.pointsPossible = parseFloat(gradeMatch[2].replace(',', '.'));\r\n                        if (questionData.isAnsweredCorrectly === true && questionData.pointsEarned > 0) {\r\n                            analytics.correctAnswersCount++;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                questionData.questionTextHTML = qElement.querySelector('.content .formulation .qtext')?.innerHTML.trim() || null;\r\n\r\n                // Odpowiedzi użytkownika i opcje (bardzo zależy od typu pytania)\r\n                const answerSection = qElement.querySelector('.content .formulation .ablock, .content .formulation .answer');\r\n                if (answerSection) {\r\n                    // Przykładowa logika dla MCQ (radio/checkbox)\r\n                    const choices = answerSection.querySelectorAll('input[type=\"radio\"], input[type=\"checkbox\"]');\r\n                    choices.forEach(choice => {\r\n                        const labelElement = choice.closest('div[class^=\"r\"]'); // Kontener opcji, np. <div class=\"r0 incorrect\">\r\n                        let optionText = \"\";\r\n                        const labelFor = document.querySelector(`label[for=\"${choice.id}\"]`) || choice.nextElementSibling;\r\n                        if (labelFor) {\r\n                            // Pobierz tekst, omijając <span class=\"answernumber\">\r\n                            const textContentDiv = labelFor.querySelector('.flex-fill');\r\n                            optionText = textContentDiv ? textContentDiv.innerText.trim() : labelFor.innerText.trim().replace(/^[a-z]\\.\\s*/i, '').trim();\r\n                        } else {\r\n                            optionText = choice.value;\r\n                        }\r\n\r\n                        let isCorrectOption = false;\r\n                        if (labelElement && (labelElement.classList.contains('correct') || labelElement.querySelector('i.text-success'))) {\r\n                            isCorrectOption = true;\r\n                        }\r\n\r\n                        questionData.options.push({\r\n                            text: optionText,\r\n                            isUserSelected: choice.checked,\r\n                            isCorrect: isCorrectOption // To jest poprawność danej opcji, niekoniecznie czy user ją wybrał i była poprawna\r\n                        });\r\n                        if (choice.checked) {\r\n                            questionData.userAnswerText.push(optionText);\r\n                        }\r\n                    });\r\n\r\n                    // Przykładowa logika dla pytań typu \"dopasuj\" (select)\r\n                    const selects = answerSection.querySelectorAll('select');\r\n                    selects.forEach(select => {\r\n                        const selectedOption = select.options[select.selectedIndex];\r\n                        if (selectedOption && selectedOption.value !== \"0\") { // \"Choose...\" ma zwykle value 0\r\n                            const questionPartText = select.closest('tr')?.querySelector('td.text')?.innerText.trim();\r\n                            questionData.userAnswerText.push(`${questionPartText || 'Item'}: ${selectedOption.text.trim()}`);\r\n\r\n                            const isCorrectIcon = select.nextElementSibling?.matches('i.text-success');\r\n                            questionData.options.push({\r\n                                text: `${questionPartText || 'Item'} -> ${selectedOption.text.trim()}`,\r\n                                isUserSelected: true,\r\n                                isCorrect: !!isCorrectIcon\r\n                            });\r\n                        }\r\n                    });\r\n\r\n                    // Pytania otwarte (input text/textarea)\r\n                    const textInputs = answerSection.querySelectorAll('input[type=\"text\"].form-control, textarea.form-control');\r\n                    textInputs.forEach(input => {\r\n                        questionData.userAnswerText.push(input.value.trim());\r\n                        // Poprawność dla otwartych często jest tylko w 'rightanswer'\r\n                    });\r\n\r\n                }\r\n\r\n                // Poprawna odpowiedź z sekcji feedback\r\n                const rightAnswerElement = qElement.querySelector('.outcome .feedback .rightanswer');\r\n                if (rightAnswerElement) {\r\n                    // Usuń początkowe \"The correct answer is:\" itp.\r\n                    let clones = rightAnswerElement.cloneNode(true);\r\n                    clones.querySelectorAll('p:first-child').forEach(p => {\r\n                        if (p.innerText.toLowerCase().match(/^(the correct answer is:|poprawna odpowiedź to:|prawidłowymi odpowiedziami są:)/i)) {\r\n                            p.remove();\r\n                        }\r\n                    });\r\n                    questionData.correctAnswerText = clones.innerText.trim().replace(/\\n\\s*\\n/g, '\\n').trim(); // Oczyszczony tekst\r\n                }\r\n\r\n\r\n            } catch (e) {\r\n                console.warn(`Moodle Scraper: Error processing question ${questionData.questionNumber}:`, e, qElement);\r\n            }\r\n            analytics.questions.push(questionData);\r\n        });\r\n\r\n        // Uzupełnienie `correctAnswersCount`, jeśli nie zostało policzone z punktów za pytanie\r\n        if (analytics.totalQuestions > 0 && analytics.correctAnswersCount === 0 && analytics.questions.some(q => q.isAnsweredCorrectly === true)) {\r\n            analytics.correctAnswersCount = analytics.questions.filter(q => q.isAnsweredCorrectly === true).length;\r\n        }\r\n\r\n\r\n    } catch (error) {\r\n        // console.log(\"Moodle Scraper: Critical error during data extraction:\", error);\r\n        analytics.error = `Extraction failed: ${error.message}`;\r\n    }\r\n    // console.log(\"Moodle Scraper: Final standardized data:\", JSON.parse(JSON.stringify(analytics)));\r\n    return analytics;\r\n}\r\n\r\n// Helper function to parse Moodle dates (this is a basic example, might need improvement for different locales)\r\nfunction parseMoodleDate(dateString) {\r\n    if (!dateString) return null;\r\n    // Example: \"Sunday, 25 May 2025, 10:28 PM\" or \"niedziela, 25 maja 2025, 22:28\"\r\n    // This is complex due to language. For now, return as string.\r\n    // A robust solution would involve a date parsing library or more complex regex based on detected language.\r\n    return dateString;\r\n}\r\n\r\nfunction generateQuizSummaryKey(data, platform) {\r\n    let keyParts = [platform];\r\n\r\n    // Try to use the most stable and unique identifiers for each platform\r\n    switch (platform) {\r\n        case \"Naurok\":\r\n            if (data.quizTitle) keyParts.push(data.quizTitle);\r\n            if (data.student) keyParts.push(data.student);\r\n            if (data.dateTime) keyParts.push(data.dateTime); // e.g., \"Дата: 24.05.2024 о 16:39\"\r\n            if (data.score && data.score.earned !== undefined && data.score.total !== undefined) keyParts.push(`s:${data.score.earned}/${data.score.total}`);\r\n            break;\r\n        case \"Testportal\":\r\n            if (data.testTitle) keyParts.push(data.testTitle);\r\n            if (data.respondentIdentifier) keyParts.push(data.respondentIdentifier);\r\n            if (data.endTime) keyParts.push(data.endTime); // e.g., \"10:30\"\r\n            if (data.date) keyParts.push(data.date); // e.g., \"25.05.2024\"\r\n            if (data.scorePercentage !== null) keyParts.push(`p:${data.scorePercentage}`);\r\n            if (data.pointsEarned !== null && data.pointsPossible !== null) keyParts.push(`pts:${data.pointsEarned}/${data.pointsPossible}`);\r\n            break;\r\n        case \"Vseosvita\":\r\n            if (data.testAttemptId) {\r\n                keyParts.push(data.testAttemptId);\r\n            } else {\r\n                if (data.testTitle) keyParts.push(data.testTitle);\r\n                if (data.dateTimeCompleted) keyParts.push(data.dateTimeCompleted); // e.g., \"27 травня 2025 року о 22:00\"\r\n                if (data.scoreEarned !== null && data.scorePossible !== null) keyParts.push(`s:${data.scoreEarned}/${data.scorePossible}`);\r\n            }\r\n            break;\r\n        case \"Quizizz\":\r\n            if (data.playerName) keyParts.push(data.playerName);\r\n            if (data.gameScore !== null) keyParts.push(`gs:${data.gameScore}`);\r\n            if (data.quizMode) keyParts.push(data.quizMode);\r\n            if (data.accuracyPointsEarned !== null && data.accuracyPointsPossible !== null) {\r\n                keyParts.push(`acc:${data.accuracyPointsEarned}/${data.accuracyPointsPossible}`);\r\n            }\r\n            // Fallback to URL part if other identifiers are weak or missing\r\n            if (keyParts.length < 3 && data.pageUrl) keyParts.push(data.pageUrl.split('?')[0].split('#')[0]);\r\n            break;\r\n        case \"Moodle\":\r\n            const urlParams = new URLSearchParams(data.pageUrl.split('?')[1]);\r\n            const attemptId = urlParams.get('attempt') || urlParams.get('cmid'); // Common Moodle params for attempt/quiz\r\n            if (attemptId) {\r\n                keyParts.push(`att:${attemptId}`);\r\n            }\r\n            // Even with attemptId, other fields help differentiate review phases\r\n            if (data.testTitle) keyParts.push(data.testTitle);\r\n            if (data.dateTimeCompleted) keyParts.push(data.dateTimeCompleted); // e.g., \"Sunday, 25 May 2025, 10:28 PM\"\r\n            if (data.scoreEarned !== null && data.scorePossible !== null) keyParts.push(`s:${data.scoreEarned}/${data.scorePossible}`);\r\n            break;\r\n        default:\r\n            // Generic fallback\r\n            if (data.testTitle) keyParts.push(data.testTitle);\r\n            if (data.pageUrl) keyParts.push(data.pageUrl.split('?')[0].split('#')[0]); // Base URL\r\n            if (data.scoreEarned !== null && data.scorePossible !== null) keyParts.push(`s:${data.scoreEarned}/${data.scorePossible}`);\r\n    }\r\n\r\n    // If the key is still too short/generic, add more details like question count\r\n    if (keyParts.length < 3) {\r\n        if (data.totalQuestions !== null) keyParts.push(`tq:${data.totalQuestions}`);\r\n        else if (data.questions && data.questions.length > 0) keyParts.push(`qcnt:${data.questions.length}`);\r\n\r\n        if (data.questions && data.questions.length > 0 && (data.questions[0].questionText || data.questions[0].questionTextHTML)) {\r\n            const qTextSample = String(data.questions[0].questionText || data.questions[0].questionTextHTML).substring(0, 30);\r\n            keyParts.push(`fq:${qTextSample}`);\r\n        }\r\n    }\r\n\r\n    // Normalize and sanitize the key\r\n    return keyParts.join('|').replace(/\\s+/g, '_').replace(/[^\\w\\|\\.\\-]/g, '');\r\n}\r\n\r\n\r\n// --- Main logic for content script ---\r\nexport async function handleUnviersalSummary(userEmail) {\r\n    const currentUrl = window.location.href;\r\n    let platform = null;\r\n    let scraperFunction = null;\r\n\r\n    // console.log(\"Quizonator Scraper: Content script evaluating page:\", currentUrl);\r\n\r\n    if (currentUrl.includes(\"naurok.com.ua/test/complete\")) {\r\n        // console.log(\"Quizonator Scraper: Sprawdzanie, czy URL pasuje do Naurok.\");\r\n        if (document.querySelector('.homework-result-page')) {\r\n            platform = \"Naurok\";\r\n            scraperFunction = extractNaurokAnalytics;\r\n            // console.log(\"Quizonator Scraper: Wykryto platformę Naurok.\");\r\n        } else {\r\n            // console.log(\"Quizonator Scraper: URL pasuje do Naurok, ale brakujący kluczowy element .homework-result-page.\");\r\n        }\r\n    } else if (currentUrl.includes(\"testportal.pl/exam/test-result.html\") || currentUrl.includes(\"testportal.net/test-result/\")) {\r\n        if (document.querySelector('.test-page-container')) {\r\n            platform = \"Testportal\";\r\n            scraperFunction = extractTestportalAnalytics;\r\n            // console.log(\"Quizonator Scraper: Detected Testportal platform.\");\r\n        } else {\r\n            // console.log(\"Quizonator Scraper: URL matches Testportal, but key element .test-page-container not found.\");\r\n        }\r\n    } else if (currentUrl.includes(\"vseosvita.ua\") && (document.querySelector('.vo-container') || document.querySelector('div.v-hello-container'))) { // Ulepszony selektor dla Vseosvita\r\n        platform = \"Vseosvita\";\r\n        scraperFunction = extractVseosvitaAnalytics;\r\n        // console.log(\"Quizonator Scraper: Detected Vseosvita platform.\");\r\n    } else if (currentUrl.includes(\"quizizz.com\") && currentUrl.includes(\"page=summary\")) {\r\n        if (document.querySelector('div[data-v-5e383631].screen-container') || document.querySelector('.screen-summary') || document.querySelector('.summary-container')) { // Ulepszony selektor dla Quizizz\r\n            platform = \"Quizizz\";\r\n            scraperFunction = extractQuizizzAnalytics;\r\n            // console.log(\"Quizonator Scraper: Detected Quizizz platform.\");\r\n        } else {\r\n            // console.log(\"Quizonator Scraper: URL matches Quizizz summary, but key elements missing.\");\r\n        }\r\n    } else if (document.querySelector('body#page-mod-quiz-review') || (currentUrl.includes(\"/mod/quiz/review.php\") && document.querySelector('.quizreviewsummary'))) { // Ulepszony selektor dla Moodle\r\n        platform = \"Moodle\";\r\n        scraperFunction = extractMoodleAnalytics;\r\n        // console.log(\"Quizonator Scraper: Detected Moodle platform.\");\r\n    }\r\n\r\n\r\n    if (platform && scraperFunction) {\r\n        // console.log(`Quizonator Scraper: Attempting to extract data for ${platform} as user: ${userEmail}`);\r\n        const extractedData = scraperFunction();\r\n\r\n        if (extractedData && Object.keys(extractedData).length > (extractedData.platform ? 1 : 0)) {\r\n            // pageUrl jest już ustawiane wewnątrz scraperów, ale dla pewności możemy je tu nadpisać/ustawić\r\n            if (!extractedData.pageUrl) extractedData.pageUrl = currentUrl;\r\n            extractedData.scrapedAt = new Date().toISOString();\r\n            extractedData.userEmail = userEmail;\r\n            // extractedData.platform powinno być już ustawione przez funkcję scrapującą\r\n\r\n            // *** DODANA LOGIKA DEDUPLIKACJI ***\r\n            const summaryKey = generateQuizSummaryKey(extractedData, platform);\r\n            const storageKey = `quizonator_sent_${summaryKey}`;\r\n\r\n            if (sessionStorage.getItem(storageKey)) {\r\n                // console.log(`Quizonator Scraper: Summary for key \"${summaryKey}\" (from ${platform}) already sent in this session. Skipping.`);\r\n                return; // Zakończ, jeśli już wysłano w tej sesji\r\n            }\r\n            // *** KONIEC LOGIKI DEDUPLIKACJI ***\r\n\r\n            // console.log(`Quizonator Scraper: Data extracted for ${platform}:`, JSON.parse(JSON.stringify(extractedData))); // Logowanie kopii, aby uniknąć problemów z mutacją\r\n\r\n            chrome.runtime.sendMessage({ type: \"QUIZ_DATA\", payload: extractedData }, (response) => {\r\n                if (chrome.runtime.lastError) {\r\n                    // console.log(`Quizonator Scraper: Error sending ${platform} data to background:`, chrome.runtime.lastError.message);\r\n                } else {\r\n                    // console.log(`Quizonator Scraper: ${platform} data sent to background, response:`, response);\r\n                    // Oznacz jako wysłane tylko po (próbie) wysłania\r\n                    sessionStorage.setItem(storageKey, 'true'); // Można tu zapisać np. new Date().toISOString() dla więcej informacji\r\n                    // console.log(`Quizonator Scraper: Marked summary with key \"${summaryKey}\" as sent in sessionStorage.`);\r\n                }\r\n            });\r\n        } else {\r\n            // console.log(`Quizonator Scraper: No data extracted for ${platform} or data was empty.`);\r\n        }\r\n    } else {\r\n        // console.log(\"Quizonator Scraper: No known platform detected or required elements missing for URL:\", currentUrl);\r\n    }\r\n}","/**********************************************************************\r\n *  Universal DOM Changes Toggle System – v3.1  (persistent + HTML-safe)\r\n *********************************************************************/\r\n\r\n/* usuwa jedynie pojedynczy bold/span z pierwszą literą */\r\nfunction stripOneLetterBold(html) {\r\n    return html.replace(\r\n        /<(span\\b[^>]*|b|strong)>([A-Za-zĄĆĘŁŃÓŚŹŻąćęłńóśźż])<\\/\\1>/g,\r\n        '$2'\r\n    );\r\n}\r\n\r\nclass DOMChangesToggler {\r\n    /* ----------  K O N S T R U K T O R  ---------- */\r\n    constructor() {\r\n        this.isVisible = true;\r\n        this.changedElements = new Map();\r\n        this.svgElements = new Map();\r\n        this.addedElements = new Map();\r\n        this.changedClasses = new Map();\r\n        this.observer = null;\r\n\r\n        this.observeConfig = {\r\n            attributes: true,\r\n            attributeOldValue: true,\r\n            attributeFilter: ['style', 'class'],\r\n            childList: true,\r\n            subtree: true\r\n        };\r\n\r\n        this.setupKeyboardShortcut();\r\n        this.injectStyles();\r\n\r\n        /* ⬇️ pobierz zapisany stan z chrome.storage */\r\n        chrome.storage.sync.get({ domTogglerVisible: true }, data => {\r\n            this.isVisible = data.domTogglerVisible;\r\n\r\n            this.scanExistingChanges();\r\n            this.startObserving();\r\n\r\n            if (!this.isVisible) this.hideChanges();   // ukryj od razu, jeśli trzeba\r\n        });\r\n    }\r\n\r\n    /* ----------  P O M O C N I C Z E  ---------- */\r\n    pauseObserver() { if (this.observer) this.observer.disconnect(); }\r\n    resumeObserver() { if (this.observer) this.observer.observe(document.body, this.observeConfig); }\r\n    saveVisibility() { chrome.storage.sync.set({ domTogglerVisible: this.isVisible }); }\r\n\r\n    hideJustAdded(el, meta) {\r\n        switch (meta.type) {\r\n            case 'style':\r\n            case 'border':\r\n            case 'outline':\r\n                if (meta.originalStyle) el.setAttribute('style', meta.originalStyle);\r\n                else el.removeAttribute('style');\r\n                el.style.setProperty('font-weight', 'normal', 'important');\r\n                break;\r\n            case 'class':\r\n                el.className = meta.originalClass;\r\n                break;\r\n            case 'svg':\r\n                if (meta.originalStyle) el.setAttribute('style', meta.originalStyle);\r\n                else el.removeAttribute('style');\r\n                break;\r\n            case 'savemode-text':\r\n                el.innerHTML = meta.originalHTML;          // ⬅️  zachowaj <select>\r\n                break;\r\n            case 'added':\r\n                el.setAttribute('style', (el.getAttribute('style') || '') + '; display: none !important;');\r\n                break;\r\n        }\r\n    }\r\n\r\n    /* ----------  D E T E K T O R Y  ---------- */\r\n    isTrackedStyle(s) {\r\n        return s.includes('color: green') || s.includes('#4CAF50') ||\r\n            s.includes('rgb(76, 175, 80)') ||\r\n            /font-weight\\s*:\\s*(bold|[67]00)/.test(s) ||\r\n            /color:\\s*rgb\\(153,\\s*151,\\s*151\\)/.test(s) ||\r\n            /color:\\s*rgb\\(211,\\s*211,\\s*211\\)/.test(s) ||\r\n            s.includes('#999797') || s.includes('#D3D3D3') ||\r\n            s.includes('#A9A9A9') || s.includes('rgb(169, 169, 169)');\r\n    }\r\n\r\n    isAnswerElement(el) {\r\n        const st = el.getAttribute('style') || '';\r\n        const txt = el.textContent || '';\r\n        return el.classList?.contains('correct-answer-info') ||\r\n            el.classList?.contains('correct-answer-date-info') ||\r\n            (st.includes('#4CAF50') || st.includes('rgb(76, 175, 80)')) && st.includes('font-weight') ||\r\n            txt.includes('Poprawna odpowiedź') || txt.includes('Correct answer');\r\n    }\r\n\r\n    isFirstLetterBoldTag(n) { return n && ['B', 'STRONG'].includes(n.tagName) && n.textContent.length === 1; }\r\n    isSavemodeSpan(n) {\r\n        if (!n || n.tagName !== 'SPAN' || n.textContent.length !== 1) return false;\r\n        const w = n.style.fontWeight || getComputedStyle(n).fontWeight;\r\n        return w === 'bold' || w === '600' || w === '700' || parseInt(w, 10) >= 600;\r\n    }\r\n\r\n    /* ----------  S K A N   P O C Z Ą T K O W Y  ---------- */\r\n    scanExistingChanges() {\r\n        /* style / kolor / bold inline */\r\n        document.querySelectorAll(`\r\n        [style*=\"color: green\"], [style*=\"#4CAF50\"], [style*=\"rgb(76, 175, 80)\"],\r\n        [style*=\"font-weight: 600\"], [style*=\"font-weight:700\"], [style*=\"font-weight: bold\"],\r\n        [style*=\"#999797\"], [style*=\"#D3D3D3\"], [style*=\"#A9A9A9\"],\r\n        [style*=\"rgb(169, 169, 169)\"], [style*=\"rgb(153, 151, 151)\"], [style*=\"rgb(211, 211, 211)\"]\r\n      `).forEach(el => {\r\n            if (this.changedElements.has(el)) return;\r\n            this.changedElements.set(el, { originalStyle: el.dataset.originalStyle || '', modifiedStyle: el.getAttribute('style') || '', type: 'style' });\r\n        });\r\n\r\n        /* bold jako <b>/<strong> */\r\n        document.querySelectorAll('b,strong').forEach(tag => {\r\n            if (!this.isFirstLetterBoldTag(tag)) return;\r\n            const par = tag.closest('label,.YEVVod,.SG0AAe,p,pre,div') || tag.parentElement;\r\n            if (!par || this.changedElements.has(par)) return;\r\n            if (!par.dataset.originalText) par.dataset.originalText = stripOneLetterBold(par.innerHTML);\r\n            this.changedElements.set(par, {\r\n                originalHTML: par.dataset.originalText,\r\n                modifiedHTML: par.innerHTML,\r\n                type: 'savemode-text'\r\n            });\r\n        });\r\n\r\n        /* kolor przez klasę */\r\n        document.querySelectorAll('*').forEach(el => {\r\n            const inl = el.getAttribute('style') || '';\r\n            const isGreen = /rgb\\( ?7?6?, ?17?5?, ?8?0 ?\\)/.test(getComputedStyle(el).color);\r\n            if (isGreen && !inl.includes('color') && !this.changedClasses.has(el)) {\r\n                el.dataset.originalClass = el.className;\r\n                this.changedClasses.set(el, { originalClass: el.className, modifiedClass: el.className, type: 'class' });\r\n            }\r\n        });\r\n\r\n        /* divy z odpowiedziami */\r\n        document.querySelectorAll('.correct-answer-info,.correct-answer-date-info').forEach(el => {\r\n            if (this.addedElements.has(el)) return;\r\n            this.addedElements.set(el, { originalDisplay: getComputedStyle(el).display, inlineStyles: el.getAttribute('style') || '', className: el.className, innerHTML: el.innerHTML, type: 'added' });\r\n        });\r\n\r\n        /* SVG */\r\n        document.querySelectorAll('svg path[style*=\"stroke\"],svg path[style*=\"stroke-width\"]').forEach(p => {\r\n            const s = p.getAttribute('style') || '';\r\n            if (!/stroke.*green|stroke-width:\\s*2|stroke:\\s*#ccc|rgb\\(204, 204, 204\\)/.test(s)) return;\r\n            this.svgElements.set(p, { originalStyle: '', modifiedStyle: s, type: 'svg' });\r\n        });\r\n    }\r\n\r\n    /* ----------  T O G G L E  ---------- */\r\n    toggle() {\r\n        this.isVisible = !this.isVisible;\r\n        this.saveVisibility();\r\n        this.isVisible ? this.showChanges() : this.hideChanges();\r\n        this.showNotification(this.isVisible ? 'Odpowiedzi pokazane' : 'Odpowiedzi ukryte');\r\n    }\r\n\r\n    /* ----------  H I D E  ---------- */\r\n    hideChanges() {\r\n        this.pauseObserver();\r\n\r\n        this.changedElements.forEach((d, el) => {\r\n            if (d.type === 'savemode-text') {\r\n                if (!el.dataset.togglerModifiedHtml) el.dataset.togglerModifiedHtml = el.innerHTML;\r\n                el.innerHTML = d.originalHTML;                           // ⬅️ używamy HTML!\r\n            } else if (['style', 'border', 'outline'].includes(d.type)) {\r\n                if (!el.dataset.togglerModifiedStyle) el.dataset.togglerModifiedStyle = el.getAttribute('style') || '';\r\n                if (d.originalStyle) el.setAttribute('style', d.originalStyle); else el.removeAttribute('style');\r\n                el.style.setProperty('font-weight', 'normal', 'important');\r\n            }\r\n        });\r\n\r\n        this.changedClasses.forEach((d, el) => {\r\n            if (!el.dataset.togglerModifiedClass) el.dataset.togglerModifiedClass = el.className;\r\n            el.className = d.originalClass;\r\n        });\r\n\r\n        this.svgElements.forEach((d, el) => {\r\n            if (!el.dataset.togglerModifiedStyle) el.dataset.togglerModifiedStyle = el.getAttribute('style') || '';\r\n            if (d.originalStyle) el.setAttribute('style', d.originalStyle); else el.removeAttribute('style');\r\n        });\r\n\r\n        this.addedElements.forEach((d, el) => {\r\n            if (!el.dataset.togglerSavedStyles) el.dataset.togglerSavedStyles = el.getAttribute('style') || '';\r\n            el.setAttribute('style', el.dataset.togglerSavedStyles + '; display: none !important;');\r\n        });\r\n\r\n        this.resumeObserver();\r\n    }\r\n\r\n    /* ----------  S H O W  ---------- */\r\n    showChanges() {\r\n        this.pauseObserver();\r\n\r\n        this.changedElements.forEach((d, el) => {\r\n            if (d.type === 'savemode-text') {\r\n                el.innerHTML = el.dataset.togglerModifiedHtml || d.modifiedHTML;\r\n            } else if (['style', 'border', 'outline'].includes(d.type)) {\r\n                el.setAttribute('style', el.dataset.togglerModifiedStyle || d.modifiedStyle);\r\n            }\r\n        });\r\n\r\n        this.changedClasses.forEach((d, el) => {\r\n            el.className = el.dataset.togglerModifiedClass || d.modifiedClass;\r\n        });\r\n\r\n        this.svgElements.forEach((d, el) => {\r\n            el.setAttribute('style', el.dataset.togglerModifiedStyle || d.modifiedStyle);\r\n        });\r\n\r\n        this.addedElements.forEach((d, el) => {\r\n            const saved = el.dataset.togglerSavedStyles || d.inlineStyles;\r\n            el.setAttribute('style', saved.replace(/;\\s*display\\s*:\\s*none\\s*!important/gi, ''));\r\n        });\r\n\r\n        this.resumeObserver();\r\n    }\r\n\r\n    /* ----------  O B S E R W A T O R  ---------- */\r\n    startObserving() {\r\n        if (this.observer) return;\r\n\r\n        const schedule = fn => { clearTimeout(fn.t); fn.t = setTimeout(fn, 40); };\r\n\r\n        this.observer = new MutationObserver(muts => schedule(() => {\r\n            muts.forEach(m => {\r\n                /* (a) zmiana stylu */\r\n                if (m.type === 'attributes' && m.attributeName === 'style') {\r\n                    const el = m.target, cur = el.getAttribute('style') || '';\r\n                    if (!el.dataset.originalStyle && m.oldValue !== null) el.dataset.originalStyle = m.oldValue;\r\n\r\n                    /* SVG */\r\n                    if (el.tagName === 'path' && el.parentElement?.tagName === 'svg' && /stroke.*green|stroke-width:\\s*2|stroke:\\s*#ccc|rgb\\(204, 204, 204\\)/.test(cur)) {\r\n                        if (!this.svgElements.has(el)) {\r\n                            const meta = { originalStyle: el.dataset.originalStyle || m.oldValue || '', modifiedStyle: cur, type: 'svg' };\r\n                            this.svgElements.set(el, meta); if (!this.isVisible) this.hideJustAdded(el, meta);\r\n                        }\r\n                    }\r\n                    /* style/border/outline */\r\n                    else if (this.isTrackedStyle(cur) || /border:\\s*(1|2|3)px/.test(cur) || /outline:\\s*green/.test(cur)) {\r\n                        if (!this.changedElements.has(el)) {\r\n                            const t = /border/.test(cur) ? 'border' : /outline/.test(cur) ? 'outline' : 'style';\r\n                            const meta = { originalStyle: el.dataset.originalStyle || m.oldValue || '', modifiedStyle: cur, type: t };\r\n                            this.changedElements.set(el, meta); if (!this.isVisible) this.hideJustAdded(el, meta);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                /* (b) dziecko dodane */\r\n                if (m.type === 'childList') {\r\n                    m.addedNodes.forEach(node => {\r\n                        if (node.nodeType !== 1) return;\r\n\r\n                        if (this.isAnswerElement(node)) {\r\n                            const meta = { originalDisplay: 'block', inlineStyles: node.getAttribute('style') || '', className: node.className, innerHTML: node.innerHTML, type: 'added' };\r\n                            this.addedElements.set(node, meta); if (!this.isVisible) this.hideJustAdded(node, meta); return;\r\n                        }\r\n\r\n                        if (this.isFirstLetterBoldTag(node) || this.isSavemodeSpan(node)) {\r\n                            const par = node.closest('label,.YEVVod,.SG0AAe,p,pre,div') || node.parentElement;\r\n                            if (!par || this.changedElements.has(par)) return;\r\n                            const meta = { originalHTML: stripOneLetterBold(par.innerHTML), modifiedHTML: par.innerHTML, type: 'savemode-text' };\r\n                            this.changedElements.set(par, meta); if (!this.isVisible) this.hideJustAdded(par, meta);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }));\r\n        this.resumeObserver();\r\n    }\r\n\r\n    /* ----------  U I  ---------- */\r\n    setupKeyboardShortcut() {\r\n        document.addEventListener('keydown', e => {\r\n            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.code === 'Space') { e.preventDefault(); this.toggle(); }\r\n        });\r\n    }\r\n\r\n    injectStyles() {\r\n        if (document.getElementById('sc-toggle-styles')) return;\r\n        const st = document.createElement('style'); st.id = 'sc-toggle-styles';\r\n        st.textContent = '.sc-notification{position:fixed;top:5px;right:5px;background:rgba(0,0,0,.82);color:#fff;padding:3px 5px;border-radius:2px;font-size:10px;z-index:999999;transition:opacity .3s;pointer-events:none}.sc-notification.fade-out{opacity:0}[style*=\"display: none !important\"]{display:none!important}';\r\n        document.head.appendChild(st);\r\n    }\r\n\r\n    showNotification(msg) {\r\n        const n = document.createElement('div'); n.className = 'sc-notification'; n.textContent = msg;\r\n        document.body.appendChild(n); setTimeout(() => { n.classList.add('fade-out'); setTimeout(() => n.remove(), 300); }, 1800);\r\n    }\r\n\r\n    /* ----------  D E B U G  ---------- */\r\n    // rescan() { console.log('[DOMToggler] Rescan'); this.scanExistingChanges(); }\r\n    // debugAll() { console.log(this); }\r\n}\r\n\r\n/* ===== Helpers & global  ============================================ */\r\nconst MarkingHelper = {\r\n    saveOriginalStyle(el) { if (!el.dataset.origStyle) el.dataset.origStyle = el.getAttribute('style') || ''; },\r\n    saveOriginalText(el) { if (!el.dataset.origText) el.dataset.origText = el.textContent; },\r\n    markInputWithListener(inp) { inp.dataset.hasListeners = 'true'; if (!inp.dataset.origPh) inp.dataset.origPh = inp.placeholder || ''; },\r\n    createAnswerDiv(txt, color = '#4CAF50') { const d = document.createElement('div'); d.className = 'correct-answer-info'; d.style.color = color; d.style.fontWeight = 'bold'; d.textContent = txt; return d; }\r\n};\r\n\r\nfunction enableAutoTracking() { return window.domToggler?.startObserving(); }\r\n\r\nwindow.domToggler = new DOMChangesToggler();\r\nexport { DOMChangesToggler, MarkingHelper, enableAutoTracking };\r\n","import {\r\n  detectQuestionType,\r\n  handleMultipleChoiceQuestion,\r\n  handleTrueFalseQuestion,\r\n  handleMatchingQuestion,\r\n  handleClozeQuestion,\r\n  handleClozeMultianswerQuestion,\r\n  handleShortAnswerQuestion,\r\n  handleLongAnswerQuestion,\r\n  handleDragAndDropQuestion,\r\n  handleOrderingQuestion,\r\n  handleQuizSummary,\r\n  detectQuestionTypeSocrative,\r\n  handleMultipleChoiceQuestionSocrative,\r\n  handleTrueFalseQuestionSocrative,\r\n  handleOpenEndedQuestionSocrative\r\n} from '../platforms/Moodle.js';\r\nimport { processTestPortalLikeMicrosoftForms } from '../platforms/TestPortal.js';\r\nimport { processMicrosoftForms } from '../platforms/MicrosoftForms.js';\r\nimport { handleTestportalSummary } from '../Summaries.js';\r\nimport { handleQuizizzAnswers, initQuizizzHandler } from '../platforms/Quizziz.js';\r\nimport { processGoogleForms } from '../platforms/GoogleForms.js';\r\nimport { setupNaurokObserver } from '../platforms/Naurok.js';\r\nimport { processVseosvita } from '../platforms/Vseosvita.js';\r\n\r\nimport { handleUnviersalSummary } from '../Analitics/SummaryProcessor.js';\r\n\r\nimport { DOMChangesToggler, enableAutoTracking } from './DOMChangesToggler.js';\r\n\r\n// Inicjalizacja z opóźnieniem dla Microsoft Forms\r\nfunction initializeDOMToggler() {\r\n  // Poczekaj aż strona się w pełni załaduje\r\n  if (document.readyState === 'loading') {\r\n    document.addEventListener('DOMContentLoaded', initializeDOMToggler);\r\n    return;\r\n  }\r\n\r\n  // Dodatkowe opóźnienie dla dynamicznie ładowanych elementów\r\n  setTimeout(() => {\r\n    window.domToggler = new DOMChangesToggler();\r\n    window.domObserver = enableAutoTracking();\r\n    // console.log('[ContentScript] DOMToggler zainicjalizowany');\r\n\r\n    // Opcjonalnie: wymuś ponowne skanowanie po kolejnej sekundzie\r\n    // (przydatne jeśli odpowiedzi są ładowane asynchronicznie)\r\n    setTimeout(() => {\r\n      window.domToggler.scanExistingChanges();\r\n    }, 1000);\r\n  }, 500);\r\n}\r\n\r\n// Wywołaj inicjalizację\r\ninitializeDOMToggler();\r\n\r\n// ===== State Management =====\r\nlet state = {\r\n  isAutoModeEnabled: false,\r\n  isProcessing: false,\r\n  quizHandled: false,\r\n  observers: {\r\n    main: null,\r\n    dynamic: null\r\n  },\r\n  platform: {\r\n    lastQuizSignature: null,\r\n    lastFirstQuestionId: null,\r\n    firstQuestionStaticTitle: null,\r\n    formsHandled: false,\r\n    processedElementIds: new Set(), // Track processed elements by ID\r\n    processedQuestionsContent: new Map() // Dodane: śledzenie zawartości pytań\r\n  },\r\n  lastUrl: window.location.href // Dodane: śledzenie aktualnego URL\r\n};\r\n\r\n\r\n// Check if script was already injected\r\nif (window.contentScriptInjected) {\r\n  //console.log('Content script already injected, reinitializing');\r\n  resetState();\r\n  initializeContentScript();\r\n} else {\r\n  window.contentScriptInjected = true;\r\n  initializeContentScript();\r\n}\r\n\r\n// ===== Main Initialization =====\r\nfunction initializeContentScript() {\r\n  //console.log('Content script initializing');\r\n\r\n\r\n  let clickCount = 0;\r\n  let lastClickTime = 0;\r\n  let isCtrlPressed = false;\r\n\r\n  // Nasłuchuj na wciśnięcie i zwolnienie klawisza Ctrl\r\n  document.addEventListener('keydown', (event) => {\r\n    if (event.key === 'Control') {\r\n      isCtrlPressed = true;\r\n    }\r\n  });\r\n\r\n  document.addEventListener('keyup', (event) => {\r\n    if (event.key === 'Control') {\r\n      isCtrlPressed = false;\r\n      // Resetuj licznik kliknięć gdy Ctrl jest zwolniony\r\n      clickCount = 0;\r\n    }\r\n  });\r\n\r\n  // Nasłuchuj na kliknięcia myszą\r\n  document.addEventListener('click', (event) => {\r\n    // Sprawdź czy to lewy przycisk myszy i czy Ctrl jest wciśnięty\r\n    if (event.button === 0 && isCtrlPressed) {\r\n      const currentTime = new Date().getTime();\r\n\r\n      // Jeśli minęło więcej niż 500ms od ostatniego kliknięcia, zresetuj licznik\r\n      if (currentTime - lastClickTime > 500) {\r\n        clickCount = 1;\r\n      } else {\r\n        // Zwiększ licznik kliknięć\r\n        clickCount++;\r\n      }\r\n\r\n      lastClickTime = currentTime;\r\n\r\n      // Jeśli wykryto 3 szybkie kliknięcia, wywołaj autodestrukcję\r\n      if (clickCount === 3) {\r\n        // Wyślij komunikat do background script\r\n        chrome.runtime.sendMessage({ action: \"selfDestruct\" });\r\n\r\n        // Zapobiegaj dalszemu wykonaniu kliknięcia\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n      }\r\n    }\r\n  });\r\n  // Load KaTeX for math rendering\r\n  loadKatex(() => console.log(\"KaTeX loaded\"));\r\n\r\n  // Set up message listeners\r\n  setupMessageListeners();\r\n\r\n  // Check if autoMode is enabled\r\n  checkAutoMode((enabled) => {\r\n    state.isAutoModeEnabled = enabled;\r\n\r\n    // Process summary pages regardless of autoMode\r\n    processIfSummaryPage();\r\n\r\n    if (enabled) {\r\n      runContentScript();\r\n    }\r\n  });\r\n\r\n  // Listen for autoMode changes\r\n  listenForAutoModeChanges();\r\n\r\n  // Listen for URL changes\r\n  observeUrlChanges();\r\n\r\n  // Listen for DOM changes that might indicate new quiz content\r\n  setupMainObserver();\r\n}\r\n\r\n// ===== Platform Detection =====\r\nfunction detectPlatform() {\r\n  if (document.querySelector(\".que\") !== null || document.querySelector('.formulation') !== null) {\r\n    return \"moodle\";\r\n  }\r\n  if (document.querySelector(\"#question-container\") !== null) {\r\n    return \"socrative\";\r\n  }\r\n  if (document.querySelector(\".test-question-body\") !== null) {\r\n    return \"testportal\";\r\n  }\r\n\r\n  if (window.location.href.includes(\"quizizz.com/join/game/\")) {\r\n    return \"quizizz\";\r\n  }\r\n  if (window.location.hostname === \"forms.office.com\") {\r\n    return \"microsoftForms\";\r\n  }\r\n  if (window.location.hostname.includes('vseosvita.ua') && window.location.pathname.includes(\"/test/\")) return 'vseosvita';\r\n\r\n  if (window.location.hostname === \"docs.google.com\" && window.location.pathname.includes(\"/forms/\")) {\r\n    return \"googleForms\";\r\n  }\r\n  if (document.querySelector(\".test-container-inner\") !== null &&\r\n    document.querySelector(\".test-question-content\") !== null) {\r\n    return \"naurok\";\r\n  }\r\n  return \"unknown\";\r\n}\r\n\r\nfunction isOnMicrosoftForms() {\r\n  return window.location.hostname === \"forms.office.com\";\r\n}\r\n\r\nfunction isOnSummaryPage() {\r\n  // Moodle summary\r\n  const moodleSummary = document.querySelector(\".quizreviewsummary\");\r\n  // TestPortal summary\r\n  const testPortalSummary = window.location.href.includes(\"testportal.pl/exam/test-result.html?\");\r\n  const naurokSummary = window.location.href.includes(\"naurok.com.ua/test/complete\");\r\n  const vseosvitaSummary = window.location.href.includes(\"vseosvita.ua/test/go-olp\");\r\n  const quizizzSummary = window.location.href.includes(\"quizizz.com\") && window.location.href.includes(\"page=summary\");\r\n  return !!moodleSummary || testPortalSummary || naurokSummary || vseosvitaSummary || quizizzSummary;\r\n}\r\n\r\n// ===== Platform-Specific Signatures =====\r\nfunction getMoodleQuizSignature() {\r\n  const questionElements = document.querySelectorAll(\".que\");\r\n  if (questionElements.length === 0) return \"\";\r\n\r\n  // Pozyskanie szczegółowego podpisu zawierającego ID i zawartość pytania\r\n  const signatures = [];\r\n\r\n  for (let i = 0; i < Math.min(3, questionElements.length); i++) {\r\n    const questionElement = questionElements[i];\r\n    const questionId = questionElement.getAttribute(\"id\") || \"\";\r\n    const questionContent = questionElement.querySelector(\".qtext\")?.textContent.trim() || \"\";\r\n    signatures.push(`${questionId}:${questionContent.substring(0, 30)}`);\r\n  }\r\n\r\n  return signatures.join(\"|\");\r\n}\r\n\r\nfunction getSocrativeQuizSignature() {\r\n  const questionContainer = document.querySelector(\"#question-container\");\r\n  if (!questionContainer) return \"\";\r\n\r\n  const questionId = questionContainer.getAttribute(\"id\") || \"\";\r\n  const questionText = questionContainer.querySelector(\".question-text\")?.textContent.trim() || \"\";\r\n  return `${questionId}:${questionText.substring(0, 50)}`;\r\n}\r\n\r\nfunction getTestPortalSignature() {\r\n  const questionBody = document.querySelector(\".test-question-body\");\r\n  if (!questionBody) return \"\";\r\n\r\n  const questionId = questionBody.getAttribute(\"data-question-id\") || \"\";\r\n  const questionText = questionBody.querySelector(\".question-text\")?.textContent.trim() || \"\";\r\n\r\n  return `${questionId}:${questionText.substring(0, 50)}`;\r\n}\r\n\r\nfunction getQuizizzSignature() {\r\n  const questionContainer = document.querySelector(\".question-container\");\r\n  if (!questionContainer) return \"\";\r\n\r\n  const questionId = questionContainer.getAttribute(\"data-question-id\") || \"\";\r\n  const questionText = questionContainer.querySelector(\".question-text\")?.textContent.trim() || \"\";\r\n\r\n  return `${questionId}:${questionText.substring(0, 50)}`;\r\n}\r\n\r\nfunction getGoogleFormsSignature() {\r\n  const questionContainer = document.querySelector(\".freebirdFormviewerViewItemsItemItem\");\r\n  if (!questionContainer) return \"\";\r\n\r\n  const questionId = questionContainer.getAttribute(\"data-item-id\") || \"\";\r\n  const questionText = questionContainer.querySelector(\".freebirdFormviewerViewItemsItemItemTitle\")?.textContent.trim() || \"\";\r\n\r\n  return `${questionId}:${questionText.substring(0, 50)}`;\r\n}\r\n\r\nfunction getNaurokQuizSignature() {\r\n  const questionElement = document.querySelector('.test-content-text-inner');\r\n  if (!questionElement) return \"\";\r\n\r\n  const questionText = questionElement.textContent.trim();\r\n  return `naurok:${questionText.substring(0, 50)}`;\r\n}\r\n\r\n\r\nfunction getVseosvitaQuizSignature() {\r\n  const questionContainer = document.querySelector(\".v-test-question\");\r\n  if (!questionContainer) return \"\";\r\n\r\n  const questionTextEl = questionContainer.querySelector(\".v-test-questions-title p\");\r\n  const questionText = questionTextEl?.textContent.trim() || \"\";\r\n\r\n  const questionId = questionContainer.querySelector(\"input[type='radio']\")?.name || \"\";\r\n\r\n  return `${questionId}:${questionText.substring(0, 50)}`;\r\n}\r\n\r\n\r\n// ===== Main Content Script Logic =====\r\nfunction runContentScript() {\r\n  if (state.isProcessing) {\r\n    //console.log('Already processing content');\r\n    return;\r\n  }\r\n\r\n  state.isProcessing = true;\r\n\r\n  try {\r\n    const platform = detectPlatform();\r\n    //console.log('Detected platform:', platform);\r\n\r\n    let currentSignature = \"\";\r\n\r\n    switch (platform) {\r\n      case \"moodle\":\r\n        currentSignature = getMoodleQuizSignature();\r\n        if (currentSignature && currentSignature !== state.platform.lastQuizSignature) {\r\n          // console.log('Wykryto nową zawartość quizu Moodle:', currentSignature);\r\n          state.platform.lastQuizSignature = currentSignature;\r\n          processMoodleQuiz();\r\n        } else {\r\n          // console.log('Nie wykryto zmian w quizie Moodle lub sygnatura jest taka sama');\r\n        }\r\n        break;\r\n      case \"socrative\":\r\n        currentSignature = getSocrativeQuizSignature();\r\n        if (currentSignature && currentSignature !== state.platform.lastQuizSignature) {\r\n          //console.log('New Socrative quiz content detected');\r\n          state.platform.lastQuizSignature = currentSignature;\r\n          processSocrativeQuiz();\r\n          setupSocrativeObserver();\r\n        }\r\n        break;\r\n      case \"testportal\":\r\n        currentSignature = getTestPortalSignature();\r\n        if (currentSignature && currentSignature !== state.platform.lastQuizSignature) {\r\n          //console.log('New TestPortal quiz content detected');\r\n          state.platform.lastQuizSignature = currentSignature;\r\n          processTestPortalLikeMicrosoftForms();\r\n        }\r\n        break;\r\n      case \"quizizz\":\r\n        // For Quizizz, always run the handlers because its structure is different\r\n        // and doesn't immediately expose question elements for signature generation\r\n        //console.log('Quizizz detected, initializing handlers');\r\n        // initQuizizzHandler();\r\n        handleQuizizzAnswers();\r\n        break;\r\n      case \"microsoftForms\":\r\n        if (!state.platform.formsHandled) {\r\n          waitForMicrosoftFormsQuiz();\r\n        }\r\n        break;\r\n      case \"googleForms\":\r\n        // Remove the redundant processGoogleForms() call at the end\r\n        currentSignature = getGoogleFormsSignature();\r\n        if (!state.platform.googleFormsProcessed || (currentSignature && currentSignature !== state.platform.lastQuizSignature)) {\r\n          //console.log('Processing Google Forms content');\r\n          state.platform.lastQuizSignature = currentSignature;\r\n          state.platform.googleFormsProcessed = true;\r\n          processGoogleForms();\r\n        }\r\n        break;\r\n      case \"naurok\":\r\n        currentSignature = getNaurokQuizSignature();\r\n        if (currentSignature && currentSignature !== state.platform.lastQuizSignature) {\r\n          // console.log('New Naurok quiz content detected');\r\n          state.platform.lastQuizSignature = currentSignature;\r\n          // Usunięto wywołanie processNaurok() - będzie teraz wywoływane tylko przez obserwator\r\n          setupNaurokObserver();\r\n        }\r\n        break;\r\n      case \"vseosvita\":\r\n        currentSignature = getVseosvitaQuizSignature();\r\n        if (currentSignature && currentSignature !== state.platform.lastQuizSignature) {\r\n          // console.log('processVseosvita');\r\n          state.platform.lastQuizSignature = currentSignature;\r\n          processVseosvita();\r\n        }\r\n    }\r\n  } catch (error) {\r\n    console.error('Error processing content:', error);\r\n  } finally {\r\n    state.isProcessing = false;\r\n  }\r\n}\r\n\r\n// ===== Platform-Specific Processing =====\r\nfunction processMoodleQuiz() {\r\n  if (!state.isAutoModeEnabled) return;\r\n\r\n  // console.log('Processing Moodle quiz',\r\n  //   state.platform.processedElementIds.size);\r\n\r\n  const questionElements = document.querySelectorAll(\".que\");\r\n  const summaryElement = document.querySelector(\".quizreviewsummary\");\r\n\r\n  if (!summaryElement) {\r\n    buildInstructionRanges();\r\n\r\n    // Process each question only once with better tracking\r\n    questionElements.forEach(questionElement => {\r\n      const elemId = questionElement.getAttribute(\"id\") || \"\";\r\n      const questionContent = questionElement.querySelector(\".qtext\")?.textContent.trim() || \"\";\r\n\r\n      // Tworzenie bardziej niezawodnego ID przez połączenie ID elementu z zawartością pytania\r\n      const reliableId = `${elemId}:${questionContent.substring(0, 20)}`;\r\n\r\n      // Sprawdzenie czy element ma już flagę wskazującą na przetworzenie\r\n      if (questionElement.hasAttribute(\"data-sc-processed\")) {\r\n        // console.log(\"Element ma już atrybut data-sc-processed, pomijam:\", reliableId);\r\n        return;\r\n      }\r\n\r\n      // Sprawdzenie czy ten element był już przetwarzany na podstawie zawartości\r\n      if (state.platform.processedElementIds.has(reliableId)) {\r\n        // console.log(\"Pomijam już przetworzone pytanie:\", reliableId);\r\n        return;\r\n      }\r\n\r\n      // console.log(\"Przetwarzam nowe pytanie:\", reliableId);\r\n\r\n      const questionType = detectQuestionType(questionElement);\r\n      // console.log(\"Typ pytania:\", questionType);\r\n\r\n      // Ustawienie flagi bezpośrednio na elemencie\r\n      questionElement.setAttribute(\"data-sc-processed\", \"true\");\r\n\r\n      switch (questionType) {\r\n        case \"multipleChoice\":\r\n          handleMultipleChoiceQuestion(questionElement);\r\n          break;\r\n        case \"trueFalse\":\r\n          handleTrueFalseQuestion(questionElement);\r\n          break;\r\n        case \"matching\":\r\n          handleMatchingQuestion(questionElement);\r\n          break;\r\n        case \"cloze\":\r\n          handleClozeQuestion(questionElement);\r\n          break;\r\n        case \"cloze-multianswer\":\r\n          handleClozeMultianswerQuestion(questionElement);\r\n          break;\r\n        case \"shortAnswer\":\r\n          handleShortAnswerQuestion(questionElement);\r\n          break;\r\n        case \"longAnswer\":\r\n          handleLongAnswerQuestion(questionElement);\r\n          break;\r\n        case \"dragAndDrop\":\r\n          handleDragAndDropQuestion(questionElement);\r\n          break;\r\n        case \"ordering\":\r\n          handleOrderingQuestion(questionElement);\r\n          break;\r\n        default:\r\n        // console.log(\"Nieznany typ pytania w Moodle:\", questionType);\r\n      }\r\n\r\n      // Oznaczenie tego elementu jako przetworzonego przy użyciu niezawodnego ID\r\n      state.platform.processedElementIds.add(reliableId);\r\n      state.platform.processedQuestionsContent.set(elemId, questionContent);\r\n    });\r\n  }\r\n}\r\n\r\nfunction processSocrativeQuiz() {\r\n  if (!state.isAutoModeEnabled) return;\r\n\r\n  const questionElement = document.querySelector(\"#question-container\");\r\n  if (!questionElement) {\r\n    // Jeśli z jakiegoś powodu kontener zniknął, przerwij\r\n    return;\r\n  }\r\n\r\n  // Usunęliśmy sprawdzanie `processedElementIds`.\r\n  // Decyzja o uruchomieniu tej funkcji jest już podejmowana na podstawie zmiany\r\n  // sygnatury pytania w `runContentScript` i `setupSocrativeObserver`.\r\n  // Dzięki temu funkcja zawsze przetworzy aktualnie widoczne pytanie.\r\n\r\n  const questionType = detectQuestionTypeSocrative(questionElement);\r\n\r\n  switch (questionType) {\r\n    case \"multipleChoiceSocrative\":\r\n      handleMultipleChoiceQuestionSocrative(questionElement);\r\n      break;\r\n    case \"trueFalseSocrative\":\r\n      handleTrueFalseQuestionSocrative(questionElement);\r\n      break;\r\n    case \"openEndedSocrative\":\r\n      handleOpenEndedQuestionSocrative(questionElement);\r\n      break;\r\n    default:\r\n    //console.log(\"Unknown question type in Socrative:\", questionType);\r\n  }\r\n}\r\nfunction processIfSummaryPage() {\r\n  if (!isOnSummaryPage()) return;\r\n\r\n  chrome.storage.local.get(['email', 'userName'], (result) => {\r\n    const userEmail = result.email;\r\n    const userName = result.userName;\r\n\r\n    if (!userEmail && !userName) return;\r\n\r\n    // Moodle summary\r\n    const moodleSummary = document.querySelector(\".quizreviewsummary\");\r\n    if (moodleSummary) {\r\n      // handleQuizSummary(moodleSummary, navElement, userEmail);\r\n      handleUnviersalSummary(userEmail);\r\n    }\r\n\r\n    // TestPortal summary\r\n    const isTestPortalSummary = window.location.href.includes(\"testportal.pl/exam/test-result.html?\");\r\n    if (isTestPortalSummary) {\r\n      handleUnviersalSummary(userEmail);\r\n    }\r\n\r\n    const naurokSummary = window.location.href.includes(\"naurok.com.ua/test/complete\");\r\n    if (naurokSummary) {\r\n      handleUnviersalSummary(userEmail);\r\n    }\r\n    const quizizzSummary = window.location.href.includes(\"quizizz.com\") && window.location.href.includes(\"page=summary\");\r\n    if (quizizzSummary) {\r\n      const waitForElement = (selector, callback, timeout = 10000) => {\r\n        const startTime = Date.now();\r\n\r\n        const interval = setInterval(() => {\r\n          const element = document.querySelector(selector);\r\n          if (element) {\r\n            clearInterval(interval);\r\n            callback();\r\n          } else if (Date.now() - startTime > timeout) {\r\n            clearInterval(interval);\r\n            console.warn(\"Element '.screen-summary' not found within timeout.\");\r\n          }\r\n        }, 100);\r\n      };\r\n\r\n      waitForElement(\".accuracy-info-section\", () => {\r\n        handleUnviersalSummary(userEmail);\r\n      });\r\n    }\r\n\r\n    const vseosvita = window.location.href.includes(\"vseosvita.ua/test/go-olp\");\r\n    if (vseosvita) {\r\n      const waitForElement = (selector, callback, timeout = 10000) => {\r\n        const startTime = Date.now();\r\n\r\n        const interval = setInterval(() => {\r\n          const element = document.querySelector(selector);\r\n          if (element) {\r\n            clearInterval(interval);\r\n            callback();\r\n          } else if (Date.now() - startTime > timeout) {\r\n            clearInterval(interval);\r\n            console.warn(\"Element not found within timeout.\");\r\n          }\r\n        }, 100);\r\n      };\r\n\r\n      waitForElement(\".v-hello-container.type-container-vo\", () => {\r\n        handleUnviersalSummary(userEmail);\r\n      });\r\n    }\r\n  });\r\n}\r\n\r\nfunction waitForMicrosoftFormsQuiz() {\r\n  if (window.location.hostname !== \"forms.office.com\" || !state.isAutoModeEnabled) return;\r\n  state.platform.formsHandled = false;\r\n\r\n  // Clear previous interval if any\r\n  if (window.formsCheckInterval) {\r\n    clearInterval(window.formsCheckInterval);\r\n  }\r\n\r\n  let attempts = 0;\r\n  const maxAttempts = 20;\r\n  const interval = 500;\r\n\r\n  window.formsCheckInterval = setInterval(() => {\r\n    attempts++;\r\n\r\n    const questionContainer = document.querySelector(\"[data-automation-id='questionItem']\");\r\n    if (questionContainer) {\r\n      clearInterval(window.formsCheckInterval);\r\n      state.platform.lastQuizSignature = getPageSignatureForms();\r\n\r\n      if (state.isAutoModeEnabled) {\r\n        processMicrosoftForms();\r\n        observeFormsDynamicQuestions();\r\n        state.platform.formsHandled = true;\r\n      }\r\n    }\r\n\r\n    if (attempts >= maxAttempts) {\r\n      clearInterval(window.formsCheckInterval);\r\n    }\r\n  }, interval);\r\n}\r\n\r\nfunction getPageSignatureForms() {\r\n  const firstQuestion = document.querySelector(\"[data-automation-id='questionItem']\");\r\n  if (!firstQuestion) return \"\";\r\n\r\n  const firstChild = firstQuestion.firstElementChild;\r\n  if (!firstChild) return \"\";\r\n\r\n  const questionId = firstChild.getAttribute(\"id\") || \"\";\r\n  if (state.platform.lastFirstQuestionId !== questionId) {\r\n    state.platform.lastFirstQuestionId = questionId;\r\n    const titleElem = firstQuestion.querySelector(\"[data-automation-id='questionTitle']\");\r\n    state.platform.firstQuestionStaticTitle = titleElem ? titleElem.innerText.trim() : \"\";\r\n  }\r\n\r\n  return `${questionId}:${state.platform.firstQuestionStaticTitle}`;\r\n}\r\n\r\n// ===== Observers and Event Listeners =====\r\nfunction setupMainObserver() {\r\n  if (state.observers.main) {\r\n    state.observers.main.disconnect();\r\n  }\r\n\r\n  // Create a more specific target selector based on platform\r\n  const platform = detectPlatform();\r\n  let targetSelector = \"body\"; // Default fallback\r\n\r\n  switch (platform) {\r\n    case \"moodle\":\r\n      targetSelector = \"#responseform, #region-main, .content\";\r\n      break;\r\n    case \"socrative\":\r\n      targetSelector = \"#question-container\";\r\n      break;\r\n    case \"testportal\":\r\n      targetSelector = \".test-question-body\";\r\n      break;\r\n    case \"quizizz\":\r\n      targetSelector = \".question-container\";\r\n      break;\r\n    case \"microsoftForms\":\r\n      targetSelector = \"[data-automation-id='questionItem']\";\r\n      break;\r\n\r\n  }\r\n\r\n  const target = document.querySelector(targetSelector) || document.body;\r\n\r\n  // Use a more aggressive debounce (1000ms instead of 500ms) to prevent multiple rapid executions\r\n  state.observers.main = new MutationObserver(debounce(() => {\r\n    if (!state.isAutoModeEnabled) return;\r\n\r\n    const platform = detectPlatform();\r\n    if (platform !== \"unknown\") {\r\n      //console.log(\"Content change detected, checking for new quiz content\");\r\n      runContentScript();\r\n    }\r\n  }, 1000));\r\n\r\n  // More specific observation configuration to reduce noise\r\n  const observerConfig = {\r\n    childList: true,\r\n    subtree: true,\r\n    // Only observe attribute changes on specific elements to reduce noise\r\n    attributeFilter: ['id', 'class', 'data-question-id']\r\n  };\r\n\r\n  state.observers.main.observe(target, observerConfig);\r\n}\r\n\r\nfunction setupSocrativeObserver() {\r\n  if (state.observers.dynamic) {\r\n    state.observers.dynamic.disconnect();\r\n  }\r\n\r\n  const questionContainer = document.querySelector(\"#question-container\");\r\n  if (!questionContainer) return;\r\n\r\n  state.observers.dynamic = new MutationObserver(debounce(() => {\r\n    if (!state.isAutoModeEnabled) return;\r\n\r\n    const newSignature = getSocrativeQuizSignature();\r\n    if (newSignature && newSignature !== state.platform.lastQuizSignature) {\r\n      //console.log(\"Socrative question changed\");\r\n      state.platform.lastQuizSignature = newSignature;\r\n      processSocrativeQuiz();\r\n    }\r\n  }, 500));\r\n\r\n  state.observers.dynamic.observe(questionContainer, {\r\n    childList: true,\r\n    subtree: true,\r\n    attributeFilter: ['id', 'class']\r\n  });\r\n}\r\n\r\nfunction observeFormsDynamicQuestions() {\r\n  if (state.observers.dynamic) {\r\n    state.observers.dynamic.disconnect();\r\n  }\r\n\r\n  const container = document.querySelector(\"[data-automation-id='questionItem']\")?.parentElement;\r\n  if (!container) return;\r\n\r\n  state.observers.dynamic = new MutationObserver(debounce(() => {\r\n    if (!state.isAutoModeEnabled) return;\r\n\r\n    const currentSignature = getPageSignatureForms();\r\n    if (currentSignature && currentSignature !== state.platform.lastQuizSignature) {\r\n      //console.log(\"Microsoft Forms question changed\");\r\n      state.platform.lastQuizSignature = currentSignature;\r\n      processMicrosoftForms();\r\n    }\r\n  }, 500));\r\n\r\n  state.observers.dynamic.observe(container, {\r\n    childList: true,\r\n    subtree: true\r\n  });\r\n}\r\n\r\nfunction observeUrlChanges() {\r\n  let lastUrl = window.location.href;\r\n\r\n  const observer = new MutationObserver(() => {\r\n    const currentUrl = window.location.href;\r\n    if (currentUrl !== lastUrl) {\r\n      //console.log('URL changed from', lastUrl, 'to', currentUrl);\r\n      lastUrl = currentUrl;\r\n\r\n      if (state.isAutoModeEnabled) {\r\n        // Reset state when URL changes to avoid processing stale content\r\n        resetState();\r\n        runContentScript();\r\n      }\r\n    }\r\n  });\r\n\r\n  observer.observe(document, { subtree: true, childList: true });\r\n}\r\n\r\nfunction setupMessageListeners() {\r\n  // Handle extension messages\r\n  chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\r\n    if (request.action === 'initiateScreenshot') {\r\n      initScreenshot();\r\n    } else if (request.action === 'displayAnalysis') {\r\n      if (request.analysis) {\r\n        displayAnalysisPopup(request.analysis);\r\n        removeLoadingPopup();\r\n      }\r\n    } else if (request.action === 'updateAnalysis') {\r\n      updateExistingPopup(request.analysis);\r\n      removeLoadingPopup();\r\n    } else if (request.action === 'SEND_ERROR') {\r\n      const { errorType, comment, userEmail } = request.errorData;\r\n\r\n      const questionElement = document.querySelector('.qtext');\r\n      const question = questionElement ? questionElement.innerText : 'Brak pytania';\r\n\r\n      const answerElement = document.querySelector('.answer');\r\n      const answer = answerElement ? answerElement.innerText : 'Brak odpowiedzi';\r\n\r\n      const contentElement = document.querySelector('.formulation.clearfix');\r\n      const htmlElement = contentElement ? contentElement.outerHTML : 'Brak zawartości pytania';\r\n\r\n      sendErrorToServer(question, answer, errorType, comment, htmlElement, sendResponse, userEmail);\r\n      return true;\r\n    }\r\n  });\r\n\r\n  // Handle window messages\r\n  window.addEventListener('message', (event) => {\r\n    if (event.source !== window) return;\r\n\r\n    if (event.data.type && (event.data.type === 'FROM_PAGE')) {\r\n      chrome.runtime.sendMessage({\r\n        type: 'TOKEN_FROM_WEBPAGE',\r\n        token: event.data.token\r\n      });\r\n    } else if (event.data.type === \"LOGOUT\") {\r\n      chrome.runtime.sendMessage({ type: \"LOGOUT\" }, (response) => {\r\n        if (response && response.success) {\r\n          //console.log(\"Logout successful\");\r\n        }\r\n      });\r\n    }\r\n    if (event.data.type === 'FIREBASE_AUTH_EVENT') {\r\n      try {\r\n        chrome.runtime.sendMessage({\r\n          type: 'FIREBASE_AUTH_FROM_WEBAPP',\r\n          idToken: event.data.idToken,\r\n          userEmail: event.data.userEmail,\r\n          uid: event.data.uid\r\n        }, () => {\r\n          // Ignoruj potencjalne błędy (chrome.runtime.lastError)\r\n        });\r\n      } catch (error) {\r\n        console.log(\"Błąd komunikacji z rozszerzeniem:\", error);\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n// ===== AutoMode Management =====\r\nfunction checkAutoMode(callback) {\r\n  chrome.storage.local.get('autoMode', (result) => {\r\n    state.isAutoModeEnabled = !!result.autoMode;\r\n    callback(state.isAutoModeEnabled);\r\n  });\r\n}\r\n\r\nfunction listenForAutoModeChanges() {\r\n  chrome.storage.onChanged.addListener((changes, areaName) => {\r\n    if (areaName === 'local' && 'autoMode' in changes) {\r\n      const newVal = changes.autoMode.newValue;\r\n      const oldVal = changes.autoMode.oldValue;\r\n\r\n      //console.log('AutoMode changed from', oldVal, 'to', newVal);\r\n      state.isAutoModeEnabled = !!newVal;\r\n\r\n      if (newVal === true && oldVal === false) {\r\n        resetState();\r\n        runContentScript();\r\n      } else if (newVal === false && oldVal === true) {\r\n        cleanupObservers();\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\n// ===== Utility Functions =====\r\nfunction resetState() {\r\n  state.quizHandled = false;\r\n  state.isProcessing = false;\r\n  resetPlatformState();\r\n\r\n  // Reset dla Naurok (jeśli zmienna istnieje w kontekście window)\r\n  if (typeof window.isNaurokProcessingActive !== 'undefined') {\r\n    window.isNaurokProcessingActive = false;\r\n  }\r\n}\r\n\r\nfunction resetPlatformState() {\r\n  state.platform = {\r\n    lastQuizSignature: null,\r\n    lastFirstQuestionId: null,\r\n    firstQuestionStaticTitle: null,\r\n    formsHandled: false,\r\n    googleFormsProcessed: false, // Add this line\r\n    processedElementIds: new Set(),\r\n    processedQuestionsContent: new Map() // Dodaj tę linię\r\n\r\n  };\r\n}\r\n\r\nfunction cleanupObservers() {\r\n  Object.values(state.observers).forEach(observer => {\r\n    if (observer) {\r\n      observer.disconnect();\r\n    }\r\n  });\r\n}\r\n\r\nfunction debounce(func, wait) {\r\n  let timeout;\r\n  return function (...args) {\r\n    const context = this;\r\n    clearTimeout(timeout);\r\n    timeout = setTimeout(() => func.apply(context, args), wait);\r\n  };\r\n}\r\n\r\nfunction loadKatex(callback) {\r\n  if (window.katex) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  const script = document.createElement('script');\r\n  script.src = chrome.runtime.getURL('vendor/katex/katex.min.js');\r\n  script.onload = function () {\r\n    callback();\r\n  };\r\n  document.head.appendChild(script);\r\n\r\n  const link = document.createElement('link');\r\n  link.rel = 'stylesheet';\r\n  link.href = chrome.runtime.getURL('vendor/katex/katex.min.css');\r\n  document.head.appendChild(link);\r\n}\r\n\r\nfunction renderLaTeX(latexString, displayMode) {\r\n  try {\r\n    return katex.renderToString(latexString, {\r\n      throwOnError: false,\r\n      displayMode: displayMode,\r\n    });\r\n  } catch (error) {\r\n    return latexString;\r\n  }\r\n}\r\n\r\nfunction buildInstructionRanges() {\r\n  const container = document.querySelector('.qn_buttons.clearfix.multipages');\r\n  if (!container) return;\r\n\r\n  const navLinks = [...container.querySelectorAll('a')];\r\n\r\n  let previousRanges = JSON.parse(localStorage.getItem('instructionsRanges')) || [];\r\n  let newRanges = [];\r\n  let lastInfoIndex = -1;\r\n\r\n  navLinks.forEach((link, i) => {\r\n    const text = link.innerText.trim().toLowerCase();\r\n    const page = parseInt(link.getAttribute('data-quiz-page'), 10);\r\n\r\n    if (text.includes('info')) {\r\n      if (lastInfoIndex >= 0 && newRanges[lastInfoIndex].endPage === null) {\r\n        newRanges[lastInfoIndex].endPage = navLinks[i - 1]\r\n          ? parseInt(navLinks[i - 1].getAttribute('data-quiz-page'), 10)\r\n          : page;\r\n      }\r\n\r\n      newRanges.push({\r\n        infoPage: page,\r\n        startPage: navLinks[i + 1] ? parseInt(navLinks[i + 1].getAttribute('data-quiz-page'), 10) : null,\r\n        endPage: null\r\n      });\r\n\r\n      lastInfoIndex = newRanges.length - 1;\r\n    }\r\n  });\r\n\r\n  // Close the last range to the end of the quiz\r\n  if (newRanges.length > 0 && newRanges[newRanges.length - 1].endPage === null) {\r\n    newRanges[newRanges.length - 1].endPage =\r\n      parseInt(navLinks[navLinks.length - 1].getAttribute('data-quiz-page'), 10);\r\n  }\r\n\r\n  // Ignore instructionText when comparing\r\n  const isSameStructure = JSON.stringify(previousRanges.map(({ instructionText, ...rest }) => rest)) ===\r\n    JSON.stringify(newRanges);\r\n\r\n  // Save to localStorage only if the structure has changed\r\n  if (!isSameStructure) {\r\n    localStorage.setItem('instructionsRanges', JSON.stringify(newRanges));\r\n  }\r\n}\r\n\r\n// ===== Event Listeners =====\r\nwindow.addEventListener(\"load\", () => {\r\n  //console.log(\"Window loaded\");\r\n  if (state.isAutoModeEnabled) {\r\n    resetState();\r\n    runContentScript();\r\n  }\r\n});\r\n\r\nwindow.addEventListener(\"pageshow\", () => {\r\n  //console.log(\"Page shown\");\r\n  if (state.isAutoModeEnabled) {\r\n    resetState();\r\n    runContentScript();\r\n\r\n    if (isOnMicrosoftForms()) {\r\n      state.platform.formsHandled = false;\r\n      waitForMicrosoftFormsQuiz();\r\n    }\r\n  }\r\n});\r\n\r\n// ===== UI Functions =====\r\n// Loading Popup\r\nfunction createLoadingPopup() {\r\n  const existingPopup = document.querySelector('#ai-analysis-popup');\r\n\r\n  if (existingPopup) {\r\n    const previousSpinner = existingPopup.querySelector('.loading-spinner');\r\n    if (previousSpinner) {\r\n      previousSpinner.remove();\r\n    }\r\n    const existingContent = existingPopup.querySelector('.popup-content');\r\n    if (existingContent) {\r\n      existingContent.innerHTML = '';\r\n      existingContent.style.overflow = 'hidden';\r\n      existingContent.style.height = '150px';\r\n    }\r\n    const existingAnswer = existingPopup.querySelector('#extracted-answer');\r\n    if (existingAnswer) {\r\n      existingAnswer.style.display = 'none';\r\n    }\r\n\r\n    const loadingContainer = document.createElement('div');\r\n    loadingContainer.className = 'loading-container';\r\n    loadingContainer.style.cssText = `\r\n            display: flex;\r\n            flex-direction: column;\r\n            align-items: center;\r\n            justify-content: center;\r\n            height: 100%;\r\n            width: 100%; \r\n            position: absolute; \r\n            top: 0; \r\n            left: 0;\r\n        `;\r\n\r\n    const loadingText = document.createElement('p');\r\n    loadingText.textContent = 'Ładowanie odpowiedzi AI...';\r\n    loadingText.className = 'loading-text';\r\n    loadingText.style.marginBottom = '10px';\r\n    loadingText.style.textAlign = 'center';\r\n\r\n    const spinner = document.createElement('div');\r\n    spinner.className = 'loading-spinner';\r\n    spinner.style.cssText = `\r\n            border: 4px solid #f3f3f3;\r\n            border-top: 4px solid #4169e1;\r\n            border-radius: 50%;\r\n            width: 30px;\r\n            height: 30px;\r\n            animation: spin 1s linear infinite;\r\n            margin: 0 auto;\r\n        `;\r\n\r\n    const keyframes = `\r\n            @keyframes spin {\r\n            0% { transform: rotate(0deg); }\r\n            100% { transform: rotate(360deg); }\r\n            }\r\n        `;\r\n    const style = document.createElement('style');\r\n    style.appendChild(document.createTextNode(keyframes));\r\n    document.head.appendChild(style);\r\n\r\n    const previousLoadingText = existingPopup.querySelector('.loading-text');\r\n    if (previousLoadingText) {\r\n      previousLoadingText.remove();\r\n    }\r\n\r\n    loadingContainer.appendChild(loadingText);\r\n    loadingContainer.appendChild(spinner);\r\n    existingContent.appendChild(loadingContainer);\r\n    existingContent.style.display = 'flex';\r\n    existingContent.style.alignItems = 'center';\r\n    existingContent.style.justifyContent = 'center';\r\n\r\n  } else {\r\n    const loadingPopup = document.createElement('div');\r\n    loadingPopup.id = 'ai-loading-popup';\r\n    loadingPopup.style.cssText = `\r\n            position: fixed;\r\n            top: 50%;\r\n            left: 50%;\r\n            transform: translate(-50%, -50%);\r\n            background-color: rgba(240, 248, 255, 0.9);\r\n            border: 2px solid #4169e1;\r\n            border-radius: 10px;\r\n            padding: 20px;\r\n            z-index: 10001;\r\n            text-align: center;\r\n            font-family: Arial, sans-serif;\r\n            color: #4169e1;\r\n            box-shadow: 0 4px 15px rgba(65, 105, 225, 0.3);\r\n        `;\r\n\r\n    const loadingText = document.createElement('p');\r\n    loadingText.textContent = 'Ładowanie odpowiedzi AI...';\r\n    loadingText.className = 'loading-text';\r\n    loadingText.style.marginBottom = '10px';\r\n\r\n    const spinner = document.createElement('div');\r\n    spinner.className = 'loading-spinner';\r\n    spinner.style.cssText = `\r\n            border: 4px solid #f3f3f3;\r\n            border-top: 4px solid #4169e1;\r\n            border-radius: 50%;\r\n            width: 30px;\r\n            height: 30px;\r\n            animation: spin 1s linear infinite;\r\n            margin: 0 auto;\r\n        `;\r\n\r\n    const keyframes = `\r\n            @keyframes spin {\r\n            0% { transform: rotate(0deg); }\r\n            100% { transform: rotate(360deg); }\r\n            }\r\n        `;\r\n    const style = document.createElement('style');\r\n    style.appendChild(document.createTextNode(keyframes));\r\n    document.head.appendChild(style);\r\n\r\n    loadingPopup.appendChild(loadingText);\r\n    loadingPopup.appendChild(spinner);\r\n    document.body.appendChild(loadingPopup);\r\n\r\n    return loadingPopup;\r\n  }\r\n}\r\n\r\nfunction removeLoadingPopup() {\r\n  const loadingPopup = document.getElementById('ai-loading-popup');\r\n  if (loadingPopup) {\r\n    document.body.removeChild(loadingPopup);\r\n  }\r\n}\r\n\r\n// Analysis Popup\r\nfunction displayAnalysisPopup(analysis) {\r\n  if (document.querySelector('#ai-analysis-popup')) return;\r\n  loadKatex(function () {\r\n    const popup = document.createElement('div');\r\n    popup.id = 'ai-analysis-popup';\r\n    popup.style.cssText = `\r\n            position: fixed;\r\n            top: 50px;\r\n            left: 50px;\r\n            width: 400px;\r\n            max-height: 600px;\r\n            background-color: #f0f8ff;\r\n            border: 2px solid #4169e1;\r\n            border-radius: 10px;\r\n            padding: 15px;\r\n            z-index: 10000;\r\n            overflow: hidden; \r\n            box-shadow: 0 4px 15px rgba(65, 105, 225, 0.3);\r\n            font-family: Arial, sans-serif;\r\n            color: #333;\r\n            cursor: move;\r\n        `;\r\n\r\n    const header = document.createElement('div');\r\n    header.style.cssText = `\r\n            display: flex;\r\n            justify-content: space-between;\r\n            align-items: center;\r\n            margin-bottom: 10px;\r\n            user-select: none;\r\n        `;\r\n\r\n    const title = document.createElement('h3');\r\n    title.textContent = 'Odpowiedź AI';\r\n    title.style.cssText = `\r\n            margin: 0;\r\n            color: #4169e1;\r\n            font-size: 18px;\r\n            font-weight: semi-bold;\r\n        `;\r\n\r\n    const closeButton = document.createElement('button');\r\n    closeButton.textContent = '✕';\r\n    closeButton.style.cssText = `\r\n            background: none;\r\n            border: none;\r\n            font-size: 20px;\r\n            cursor: pointer;\r\n            color: #4169e1;\r\n        `;\r\n    closeButton.onclick = () => document.body.removeChild(popup);\r\n\r\n    const feedbackContainer = document.createElement('div');\r\n    feedbackContainer.style.cssText = `\r\n            display: flex;\r\n            justify-content: space-between;\r\n            align-items: center;\r\n            margin-top: 15px;\r\n            width: 100%; /* Daje pełną szerokość kontenera */\r\n        `;\r\n\r\n    const leftContainer = document.createElement('div');\r\n    leftContainer.style.cssText = `\r\n            display: flex;\r\n            gap: 10px; /* Odstęp między przyciskami */\r\n        `;\r\n\r\n    const rightContainer = document.createElement('div');\r\n    rightContainer.style.cssText = `\r\n            display: flex;\r\n            gap: 10px; /* Odstęp między przyciskami */\r\n        `;\r\n\r\n    const copyButton = document.createElement('button');\r\n    copyButton.style.cssText = `\r\n            display: flex;\r\n            align-items: center;\r\n            background: none;\r\n            border: none;\r\n            font-size: 16px;\r\n            cursor: pointer;\r\n            padding: 8px;\r\n        `;\r\n\r\n    copyButton.innerHTML = `\r\n            <svg id=\"copyIcon\" xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-copy\">\r\n            <rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect>\r\n            <path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path>\r\n            </svg>\r\n        \r\n        `;\r\n\r\n    copyButton.onclick = () => {\r\n      const popup = document.querySelector('#ai-analysis-popup');\r\n      if (popup) {\r\n        const explanationDiv = popup.querySelector('.popup-content');\r\n        const explanationText = explanationDiv ? explanationDiv.textContent.trim() : '';\r\n\r\n        navigator.clipboard.writeText(explanationText).then(() => {\r\n          const copyIcon = document.getElementById('copyIcon');\r\n          if (copyIcon) {\r\n            copyIcon.innerHTML = `<path d=\"M20 6L9 17l-5-5\"></path>`;\r\n            copyIcon.setAttribute(\"id\", \"checkIcon\");\r\n\r\n            setTimeout(() => {\r\n              copyIcon.innerHTML = `\r\n                                <rect x=\"9\" y=\"9\" width=\"13\" height=\"13\" rx=\"2\" ry=\"2\"></rect>\r\n                                <path d=\"M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1\"></path>\r\n                            `;\r\n              copyIcon.setAttribute(\"id\", \"copyIcon\");\r\n              copyIcon.style.width = '24px';\r\n              copyIcon.style.height = '24px';\r\n              copyIcon.style.overflow = 'visible';\r\n            }, 2000);\r\n          }\r\n        }).catch(err => {\r\n          console.error('Failed to copy text: ', err);\r\n        });\r\n      }\r\n    };\r\n\r\n    const regenerateButton = document.createElement('button');\r\n    regenerateButton.style.cssText = `\r\n            display: flex;\r\n            align-items: center;\r\n            background: none;\r\n            border: none;\r\n            font-size: 24px;\r\n            cursor: pointer;\r\n        `;\r\n    regenerateButton.innerHTML = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-refresh-cw\"><path d=\"M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8\"/><path d=\"M21 3v5h-5\"/><path d=\"M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16\"/><path d=\"M8 16H3v5\"/></svg>`;\r\n\r\n    regenerateButton.onclick = () => {\r\n      createLoadingPopup();\r\n      chrome.runtime.sendMessage({ action: 'regenerateAnalysis' }, (response) => {\r\n        if (response && response.success) {\r\n          //console.log(\"Regeneration request sent successfully\");\r\n        } else {\r\n          console.error(\"Error regenerating analysis:\", response?.error);\r\n          removeLoadingPopup();\r\n        }\r\n      });\r\n    };\r\n\r\n    const thumbsUpButton = document.createElement('button');\r\n    thumbsUpButton.style.cssText = `\r\n            display: flex;\r\n            align-items: center;\r\n            background: none;\r\n            border: none;\r\n            font-size: 24px;\r\n            cursor: pointer;\r\n            transition: transform 0.2s ease, color 0.3s ease;\r\n        `;\r\n    thumbsUpButton.id = \"thumbsUpButton\"\r\n    thumbsUpButton.innerHTML = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-thumbs-up\"><path d=\"M7 10v12\"/><path d=\"M15 5.88 14 10h5.83a2 2 0 0 1 1.92 2.56l-2.33 8A2 2 0 0 1 17.5 22H4a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h2.76a2 2 0 0 0 1.79-1.11L12 2a3.13 3.13 0 0 1 3 3.88Z\"/></svg>`;\r\n\r\n    thumbsUpButton.onclick = () => {\r\n      sendInstantFeedback(true);\r\n      disableFeedbackButtons();\r\n      animateThumb(thumbsUpButton, true);\r\n    };\r\n\r\n    const thumbsDownButton = document.createElement('button');\r\n    thumbsDownButton.style.cssText = `\r\n            display: flex;\r\n            align-items: center;\r\n            background: none;\r\n            border: none;\r\n            font-size: 24px;\r\n            cursor: pointer;\r\n            transition: transform 0.2s ease, color 0.3s ease;\r\n        `;\r\n    thumbsDownButton.id = \"thumbsDownButton\"\r\n    thumbsDownButton.innerHTML = `<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-thumbs-down\"><path d=\"M17 14V2\"/><path d=\"M9 18.12 10 14H4.17a2 2 0 0 1-1.92-2.56l2.33-8A2 2 0 0 1 6.5 2H20a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.76a2 2 0 0 0-1.79 1.11L12 22a3.13 3.13 0 0 1-3-3.88Z\"/></svg>`;\r\n\r\n    thumbsDownButton.onclick = () => {\r\n      sendInstantFeedback(false);\r\n      disableFeedbackButtons();\r\n      animateThumb(thumbsDownButton, false);\r\n    };\r\n\r\n    function disableFeedbackButtons() {\r\n      thumbsUpButton.disabled = true;\r\n      thumbsUpButton.style.cursor = 'default';\r\n      thumbsDownButton.disabled = true;\r\n      thumbsDownButton.style.cursor = 'default';\r\n    }\r\n\r\n    function animateThumb(button, isPositive) {\r\n      button.style.transform = 'scale(1.2)';\r\n      button.style.color = isPositive ? '#45ba4f' : '#f87171';\r\n\r\n      setTimeout(() => {\r\n        button.style.transform = 'scale(1)';\r\n      }, 300);\r\n    }\r\n\r\n    leftContainer.appendChild(copyButton);\r\n    leftContainer.appendChild(regenerateButton);\r\n\r\n    rightContainer.appendChild(thumbsUpButton);\r\n    rightContainer.appendChild(thumbsDownButton);\r\n\r\n    feedbackContainer.appendChild(leftContainer);\r\n    feedbackContainer.appendChild(rightContainer);\r\n\r\n    header.appendChild(title);\r\n    header.appendChild(closeButton);\r\n\r\n    function renderContent(content) {\r\n      const hasMath = /\\\\\\(|\\\\\\[|\\$\\$/.test(content);\r\n\r\n      if (!hasMath) {\r\n        return `<p style=\"margin-bottom: 0;\">${content.trim()}</p>`;\r\n      }\r\n\r\n      content = content.replace(/\\\\\\[([\\s\\S]+?)\\\\\\]/g, function (match, latex) {\r\n        return `<div style=\"margin: 16px 0; text-align: center;\">${renderLaTeX(latex, true)}</div>`;\r\n      });\r\n\r\n      content = content.replace(/\\$\\$([\\s\\S]+?)\\$\\$/g, function (match, latex) {\r\n        return `<div style=\"margin: 16px 0; text-align: center;\">${renderLaTeX(latex, true)}</div>`;\r\n      });\r\n\r\n      content = content.replace(/\\\\\\((.+?)\\\\\\)/g, function (match, latex) {\r\n        return `<span style=\"margin-left: 4px; margin-right: 4px;\">${renderLaTeX(latex, false)}</span>`;\r\n      });\r\n\r\n      content = content.replace(/(?:^|\\n)([^$\\n]+)(?:\\n|$)/g, function (match, text) {\r\n        return `<p style=\"margin-bottom: 12px; line-height: 1.6; text-align: justify;\">${text.trim()}</p>`;\r\n      });\r\n\r\n      return content;\r\n    }\r\n\r\n    const answerExtract = extractAnswer(analysis);\r\n    let content = analysis.replace(/- Wyekstraktowana odpowiedź:\\s*([\\s\\S]*?)\\s*-/, '').trim();\r\n\r\n    if (answerExtract) {\r\n      const answerDisplay = document.createElement('div');\r\n      answerDisplay.id = 'extracted-answer';\r\n      answerDisplay.style.cssText = `\r\n                padding: 10px;\r\n                border-radius: 5px;\r\n                margin-top: 10px;\r\n                margin-bottom: 10px;\r\n                display: flex;\r\n                align-items: center;\r\n                justify-content: flex-start;\r\n                width: 100%;\r\n                font-size: 18px; /* Większa czcionka dla wyeksponowania */\r\n                height: auto;\r\n                box-sizing: border-box;\r\n                overflow: hidden;\r\n            `;\r\n      answerDisplay.innerHTML = `\r\n                <span style=\"display: flex; align-items: center; justify-content: center; width: 30px; height: 30px; background-color: #d4f5cc; border-radius: 50%; margin-right: 10px;\">\r\n                <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#69e63c\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-check\">\r\n                    <polyline points=\"20 6 9 17 4 12\"></polyline>\r\n                </svg>\r\n                </span>\r\n                <span style=\" font-weight: bold; font-size: 24px;\">${renderContent(answerExtract)}</span>\r\n            `;\r\n\r\n      popup.appendChild(header);\r\n      popup.appendChild(answerDisplay);\r\n      content = content.replace(/.*\\*\\$\\*/, '').trim();\r\n      content = content.replace(\"Uzasadnienie: \", \"\");\r\n    } else {\r\n      popup.appendChild(header);\r\n    }\r\n\r\n    const contentDiv = document.createElement('div');\r\n    contentDiv.className = 'popup-content';\r\n    contentDiv.style.cssText = `\r\n            max-height: 400px;\r\n            overflow-y: auto;\r\n            padding-right: 10px;\r\n            line-height: 1.5;\r\n            font-size: 14px;\r\n            cursor: default;\r\n        `;\r\n    contentDiv.textContent = content;\r\n\r\n    popup.appendChild(contentDiv);\r\n    popup.appendChild(feedbackContainer);\r\n\r\n    document.body.appendChild(popup);\r\n\r\n    if (!document.getElementById('custom-scrollbar-styles')) {\r\n      const styleElement = document.createElement('style');\r\n      styleElement.id = 'custom-scrollbar-styles';\r\n      styleElement.textContent = `\r\n                .custom-scrollbar {\r\n                    scrollbar-width: thin;\r\n                    scrollbar-color: #4169e1 #f0f8ff;\r\n                }\r\n                .custom-scrollbar::-webkit-scrollbar {\r\n                    width: 6px;\r\n                }\r\n                .custom-scrollbar::-webkit-scrollbar-track {\r\n                    background: #f0f8ff;\r\n                }\r\n                .custom-scrollbar::-webkit-scrollbar-thumb {\r\n                    background-color: #4169e1;\r\n                    border-radius: 3px;\r\n                }\r\n            `;\r\n      document.head.appendChild(styleElement);\r\n    }\r\n    contentDiv.classList.add('custom-scrollbar');\r\n\r\n    contentDiv.innerHTML = renderContent(content);\r\n\r\n    let isDragging = false;\r\n    let startX, startY, initialX, initialY;\r\n\r\n    popup.addEventListener('mousedown', dragStart);\r\n    popup.addEventListener('mouseup', dragEnd);\r\n    popup.addEventListener('mousemove', drag);\r\n    popup.addEventListener('mouseleave', dragEnd);\r\n\r\n    function dragStart(e) {\r\n      if (!contentDiv.contains(e.target)) {\r\n        isDragging = true;\r\n        startX = e.clientX;\r\n        startY = e.clientY;\r\n        const computedStyle = window.getComputedStyle(popup);\r\n        initialX = parseInt(computedStyle.left, 10);\r\n        initialY = parseInt(computedStyle.top, 10);\r\n        popup.style.cursor = 'grabbing';\r\n      }\r\n    }\r\n\r\n    function drag(e) {\r\n      if (isDragging) {\r\n        e.preventDefault();\r\n        const dx = e.clientX - startX;\r\n        const dy = e.clientY - startY;\r\n        popup.style.left = `${initialX + dx}px`;\r\n        popup.style.top = `${initialY + dy}px`;\r\n      }\r\n    }\r\n\r\n    function dragEnd() {\r\n      isDragging = false;\r\n      popup.style.cursor = 'move';\r\n    }\r\n  });\r\n}\r\n\r\nfunction updateExistingPopup(newAnalysis) {\r\n  const popup = document.querySelector('#ai-analysis-popup');\r\n  if (popup) {\r\n    const answerDiv = popup.querySelector('#extracted-answer');\r\n    const contentDiv = popup.querySelector('.popup-content');\r\n    contentDiv.style.height = 'auto'\r\n    contentDiv.style.overflow = 'auto'\r\n    const spinner = popup.querySelector('.loading-spinner');\r\n\r\n    let thumbsUpButton = popup.querySelector('#thumbsUpButton')\r\n    let thumbsDownButton = popup.querySelector('#thumbsDownButton')\r\n    thumbsUpButton.disabled = false;\r\n    thumbsDownButton.disabled = false;\r\n    thumbsUpButton.style.cursor = 'pointer';\r\n    thumbsDownButton.style.cursor = 'pointer';\r\n    thumbsUpButton.style.color = '';\r\n    thumbsDownButton.style.color = '';\r\n\r\n    const answerExtract = extractAnswer(newAnalysis);\r\n\r\n    if (answerExtract) {\r\n      if (answerDiv) {\r\n        answerDiv.innerHTML = `\r\n                <span style=\"display: flex; align-items: center; justify-content: center; width: 30px; height: 30px; background-color: #d4f5cc; border-radius: 50%; margin-right: 10px;\">\r\n                    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#69e63c\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-check\">\r\n                    <polyline points=\"20 6 9 17 4 12\"></polyline>\r\n                    </svg>\r\n                </span>\r\n                <span style=\" font-weight: bold; font-size: 24px;\">${renderContent(answerExtract)}</span>\r\n                `;\r\n      } else {\r\n        const newAnswerDiv = document.createElement('div');\r\n        newAnswerDiv.id = 'extracted-answer';\r\n        newAnswerDiv.style.cssText = `\r\n                    padding: 10px;\r\n                    border-radius: 5px;\r\n                    margin-top: 10px;\r\n                    margin-bottom: 10px;\r\n                    display: flex;\r\n                    align-items: center;\r\n                    justify-content: flex-start;\r\n                    width: 100%;\r\n                    font-size: 18px; /* Większa czcionka dla wyeksponowania */\r\n                    height: auto;\r\n                    box-sizing: border-box;\r\n                    overflow: hidden;\r\n                `;\r\n        newAnswerDiv.innerHTML = `\r\n                <span style=\"display: flex; align-items: center; justify-content: center; width: 30px; height: 30px; background-color: #d4f5cc; border-radius: 50%; margin-right: 10px;\">\r\n                    <svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#69e63c\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"feather feather-check\">\r\n                    <polyline points=\"20 6 9 17 4 12\"></polyline>\r\n                    </svg>\r\n                </span>\r\n                <span style=\" font-weight: bold; font-size: 24px;\">${renderContent(answerExtract)}</span>\r\n                `;\r\n        popup.appendChild(newAnswerDiv);\r\n      }\r\n    }\r\n\r\n    let content = newAnalysis.replace(/- Wyekstraktowana odpowiedź:\\s*[A-Za-z0-9,\\s]+\\s*-/, '').trim();\r\n    function renderContent(content) {\r\n      content = content.replace(/\\\\\\[([\\s\\S]+?)\\\\\\]/g, function (match, latex) {\r\n        return `<div style=\"margin: 16px 0; text-align: center;\">${renderLaTeX(latex, true)}</div>`;\r\n      });\r\n\r\n      content = content.replace(/\\$\\$([\\s\\S]+?)\\$\\$/g, function (match, latex) {\r\n        return `<div style=\"margin: 16px 0; text-align: center;\">${renderLaTeX(latex, true)}</div>`;\r\n      });\r\n\r\n      content = content.replace(/\\\\\\((.+?)\\\\\\)/g, function (match, latex) {\r\n        return `<span style=\"margin-left: 4px; margin-right: 4px;\">${renderLaTeX(latex, false)}</span>`;\r\n      });\r\n\r\n      content = content.replace(/(?:^|\\n)([^$\\n]+)(?:\\n|$)/g, function (match, text) {\r\n        return `<p style=\"margin-bottom: 12px; line-height: 1.6; text-align: justify;\">${text.trim()}</p>`;\r\n      });\r\n\r\n      return content;\r\n    }\r\n\r\n    if (contentDiv) {\r\n      contentDiv.innerHTML = renderContent(content);\r\n    }\r\n\r\n    if (spinner) {\r\n      spinner.remove();\r\n    }\r\n    if (answerDiv) {\r\n      answerDiv.style.display = 'block'\r\n    }\r\n    if (contentDiv) {\r\n      contentDiv.style.display = 'block'\r\n    }\r\n  }\r\n}\r\n\r\nfunction extractAnswer(analysis) {\r\n  const match = analysis.match(/- Wyekstraktowana odpowiedź:\\s*([\\s\\S]*?)\\s*-/);\r\n  if (match) {\r\n    const answer = match[1].trim();\r\n    return answer;\r\n  }\r\n\r\n  const trueFalseMatch = analysis.match(/^(true|false)/i);\r\n  if (trueFalseMatch) {\r\n    return trueFalseMatch[1].toUpperCase();\r\n  }\r\n\r\n  const shortAnswerMatch = analysis.match(/^([a-z0-9]+(?:\\s*,\\s*[a-z0-9]+)*)/i);\r\n  if (shortAnswerMatch && shortAnswerMatch[1].split(/\\s+/).length <= 2) {\r\n    return shortAnswerMatch[1].toUpperCase();\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n// Screenshot functionality\r\nlet screenshotOverlay, screenshotCanvas, selectionRect;\r\nlet isDrawing = false;\r\nlet startX, startY, endX, endY;\r\n\r\nfunction initScreenshot() {\r\n  removeScreenshotOverlay();\r\n  removeConfirmationButtons();\r\n  createScreenshotOverlay();\r\n}\r\n\r\nfunction createScreenshotOverlay() {\r\n  screenshotOverlay = document.createElement('div');\r\n  screenshotOverlay.style.cssText = `\r\n        position: fixed;\r\n        top: 0;\r\n        left: 0;\r\n        width: 100%;\r\n        height: 100%;\r\n        background: rgba(0, 0, 0, 0.5);\r\n        z-index: 10000;\r\n        cursor: url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 24 24' fill='none' stroke='%2338bdf8' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cline x1='12' y1='2' x2='12' y2='22'/%3E%3Cline x1='2' y1='12' x2='22' y2='12'/%3E%3C/svg%3E\") 16 16, crosshair;\r\n    `;\r\n\r\n  selectionRect = document.createElement('div');\r\n  selectionRect.style.cssText = `\r\n        position: absolute;\r\n        border: 2px solid #fff;\r\n        background: rgba(255, 255, 255, 0.1);\r\n        display: none;\r\n    `;\r\n\r\n  screenshotOverlay.appendChild(selectionRect);\r\n  document.body.appendChild(screenshotOverlay);\r\n\r\n  screenshotOverlay.addEventListener('mousedown', handleMouseDown);\r\n  screenshotOverlay.addEventListener('mousemove', handleMouseMove);\r\n  screenshotOverlay.addEventListener('mouseup', handleMouseUp);\r\n  document.addEventListener('keydown', handleKeyDown);\r\n}\r\n\r\nfunction handleKeyDown(e) {\r\n  if (e.key === 'Escape') {\r\n    removeScreenshotOverlay();\r\n  }\r\n}\r\n\r\nfunction handleMouseDown(e) {\r\n  isDrawing = true;\r\n  startX = e.clientX;\r\n  startY = e.clientY;\r\n  endX = e.clientX;\r\n  endY = e.clientY;\r\n  updateSelectionRect();\r\n  removeConfirmationButtons();\r\n}\r\n\r\nfunction handleMouseMove(e) {\r\n  if (!isDrawing) return;\r\n  endX = e.clientX;\r\n  endY = e.clientY;\r\n  updateSelectionRect();\r\n}\r\n\r\nfunction handleMouseUp(event) {\r\n  isDrawing = false;\r\n  endX = event.clientX;\r\n  endY = event.clientY;\r\n  showConfirmationButtons();\r\n}\r\n\r\nfunction updateSelectionRect() {\r\n  const left = Math.min(startX, endX);\r\n  const top = Math.min(startY, endY);\r\n  const width = Math.abs(endX - startX);\r\n  const height = Math.abs(endY - startY);\r\n\r\n  selectionRect.style.left = `${left}px`;\r\n  selectionRect.style.top = `${top}px`;\r\n  selectionRect.style.width = `${width}px`;\r\n  selectionRect.style.height = `${height}px`;\r\n  selectionRect.style.display = 'block';\r\n}\r\n\r\nfunction showConfirmationButtons() {\r\n  removeConfirmationButtons();\r\n\r\n  const minSelectionWidth = 20;\r\n  const minSelectionHeight = 20;\r\n\r\n  const selectionWidth = Math.abs(endX - startX);\r\n  const selectionHeight = Math.abs(endY - startY);\r\n\r\n  if (selectionWidth < minSelectionWidth || selectionHeight < minSelectionHeight) {\r\n    // alert('Zaznaczony obszar jest zbyt mały. Wybierz większy obszar.');\r\n    removeScreenshotOverlay();\r\n    return;\r\n  }\r\n\r\n  const buttonContainer = document.createElement('div');\r\n  buttonContainer.classList.add('confirmation-button-container');\r\n  buttonContainer.style.cssText = `\r\n        position: fixed;\r\n        top: ${endY + 10}px;\r\n        left: ${endX + 10}px;\r\n        display: flex;\r\n        gap: 10px; /* Odstęp między przyciskami */\r\n        z-index: 10001;\r\n    `;\r\n\r\n  const confirmButton = document.createElement('button');\r\n  confirmButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-check\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg>';\r\n  confirmButton.style.cssText = `\r\n        width: 48px;\r\n        height: 48px;\r\n        border-radius: 8px;\r\n        background: linear-gradient(to bottom right, #38bdf8, #22d3ee);\r\n        color: white;\r\n        display: flex;\r\n        align-items: center;\r\n        justify-content: center;\r\n        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.15);\r\n        transition: box-shadow 0.3s ease-in-out;\r\n        border: none;\r\n        cursor: pointer;\r\n    `;\r\n  confirmButton.onmouseover = () => confirmButton.style.boxShadow = '0px 6px 12px rgba(0, 0, 0, 0.25)';\r\n  confirmButton.onmouseout = () => confirmButton.style.boxShadow = '0px 4px 8px rgba(0, 0, 0, 0.15)';\r\n  confirmButton.onclick = () => {\r\n    removeConfirmationButtons();\r\n    const area = {\r\n      x: Math.min(startX, endX),\r\n      y: Math.min(startY, endY),\r\n      width: Math.abs(endX - startX),\r\n      height: Math.abs(endY - startY)\r\n    };\r\n    onScreenshotAreaSelected(area);\r\n  };\r\n\r\n  const cancelButton = document.createElement('button');\r\n  cancelButton.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" class=\"lucide lucide-x\"><line x1=\"18\" y1=\"6\" x2=\"6\" y2=\"18\"></line><line x1=\"6\" y1=\"6\" x2=\"18\" y2=\"18\"></line></svg>';\r\n  cancelButton.style.cssText = `\r\n        width: 48px;\r\n        height: 48px;\r\n        border-radius: 8px;\r\n        background: linear-gradient(to bottom right, #f87171, #fb7185);\r\n        color: white;\r\n        display: flex;\r\n        align-items: center;\r\n        justify-content: center;\r\n        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.15);\r\n        transition: box-shadow 0.3s ease-in-out;\r\n        border: none;\r\n        cursor: pointer;\r\n    `;\r\n  cancelButton.onmouseover = () => cancelButton.style.boxShadow = '0px 6px 12px rgba(0, 0, 0, 0.25)';\r\n  cancelButton.onmouseout = () => cancelButton.style.boxShadow = '0px 4px 8px rgba(0, 0, 0, 0.15)';\r\n  cancelButton.onclick = () => {\r\n    removeConfirmationButtons();\r\n    removeScreenshotOverlay();\r\n  };\r\n\r\n  buttonContainer.appendChild(confirmButton);\r\n  buttonContainer.appendChild(cancelButton);\r\n\r\n  document.body.appendChild(buttonContainer);\r\n}\r\n\r\nfunction removeConfirmationButtons() {\r\n  const existingButtonContainer = document.querySelector('.confirmation-button-container');\r\n  if (existingButtonContainer) {\r\n    existingButtonContainer.remove();\r\n  }\r\n}\r\n\r\nfunction removeScreenshotOverlay() {\r\n  if (screenshotOverlay && screenshotOverlay.parentNode) {\r\n    screenshotOverlay.parentNode.removeChild(screenshotOverlay);\r\n    document.removeEventListener('keydown', handleKeyDown);\r\n  }\r\n  removeConfirmationButtons();\r\n}\r\n\r\nfunction onScreenshotAreaSelected(area) {\r\n  removeScreenshotOverlay();\r\n  removeConfirmationButtons();\r\n\r\n  createLoadingPopup();\r\n\r\n  chrome.runtime.sendMessage(\r\n    { action: 'captureAndAnalyzeScreenshot', area: area }\r\n  );\r\n}\r\n\r\nfunction getDocumentCoordinates(x, y) {\r\n  const rect = document.documentElement.getBoundingClientRect();\r\n  const scrollX = window.pageXOffset || document.documentElement.scrollLeft;\r\n  const scrollY = window.pageYOffset || document.documentElement.scrollTop;\r\n  const scale = window.devicePixelRatio || 1;\r\n  return {\r\n    x: Math.round((x - rect.left + scrollX) * scale),\r\n    y: Math.round((y - rect.top + scrollY) * scale)\r\n  };\r\n}\r\n\r\nfunction cropImage(dataUrl, x, y, width, height) {\r\n  return new Promise((resolve, reject) => {\r\n    const img = new Image();\r\n    img.onload = function () {\r\n      const canvas = document.createElement('canvas');\r\n      canvas.width = width;\r\n      canvas.height = height;\r\n      const ctx = canvas.getContext('2d');\r\n      ctx.drawImage(img, 0, 0, width, height);\r\n      resolve(canvas.toDataURL());\r\n    };\r\n    img.onerror = reject;\r\n    img.src = dataUrl;\r\n  });\r\n}\r\n\r\n// API Requests\r\nasync function sendErrorToServer(question, answer, errorType, comment, htmlElement, sendResponse, userEmail) {\r\n  const serverUrl = 'https://us-central1-quizonator-a4513.cloudfunctions.net/api/api/send-error-to-slack';\r\n\r\n  const payload = {\r\n    question,\r\n    answer,\r\n    errorType,\r\n    comment,\r\n    htmlElement,\r\n    userEmail\r\n  };\r\n\r\n  try {\r\n    const response = await fetch(serverUrl, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify(payload),\r\n    });\r\n    if (response.ok) {\r\n      sendResponse({ success: true });\r\n    } else {\r\n      sendResponse({ success: false });\r\n    }\r\n  } catch (error) {\r\n    console.error('Błąd podczas wysyłania na serwer:', error);\r\n    sendResponse({ success: false });\r\n  }\r\n}\r\n\r\nfunction sendInstantFeedback(isPositive) {\r\n  const feedback = isPositive ? 'positive' : 'negative';\r\n  const popup = document.querySelector('#ai-analysis-popup');\r\n  let analysis = '', extractedAnswer = '';\r\n  if (popup) {\r\n    const answerDiv = popup.querySelector('#extracted-answer');\r\n    const contentDiv = popup.querySelector('.popup-content');\r\n\r\n    if (contentDiv) {\r\n      analysis = contentDiv.textContent.trim();\r\n    }\r\n\r\n    if (answerDiv) {\r\n      extractedAnswer = answerDiv.textContent.trim();\r\n    }\r\n  }\r\n\r\n  chrome.storage.local.get(['lastScreenshot', 'email'], function (result) {\r\n    const screenshotDataUrl = result.lastScreenshot || '';\r\n    const userEmail = result.email || '';\r\n\r\n    const payload = {\r\n      userEmail: userEmail,\r\n      extractedAnswer: extractedAnswer,\r\n      analysis: analysis,\r\n      screenshotDataUrl: screenshotDataUrl,\r\n      feedback: feedback\r\n    };\r\n\r\n    fetch('https://us-central1-quizonator-a4513.cloudfunctions.net/api/snapshot-feedback', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify(payload),\r\n    })\r\n      .then(response => {\r\n        if (response.ok) {\r\n          //console.log(\"Feedback sent successfully\");\r\n        } else {\r\n          console.error('Błąd podczas wysyłania feedbacku:', response.statusText);\r\n        }\r\n      })\r\n      .catch(error => {\r\n        console.error('Wystąpił błąd:', error);\r\n      });\r\n  });\r\n}"],"names":["sendQuestionToChatGPT","questionText","possibleAnswers","questionType","inputCount","currentOrder","isMultipleCorrect","arguments","length","undefined","imageBase64Strings","Promise","resolve","reject","formattedPrompt","prompt","Array","isArray","console","error","Error","forEach","answer","index","pair","options","term","option","i","trim","item","formatQuestionForChatGPT","imageUrl","chrome","runtime","sendMessage","type","originalQuestionText","response","sendQuestionToChatGPTMicrosoftForms","questionData","getCurrentPageNumber","pageParam","URLSearchParams","window","location","search","get","pageNumber","parseInt","isNaN","getLocalizedText","textKey","lang","navigator","language","userLanguage","split","textDict","getInstructionForPage","page","found","JSON","parse","localStorage","getItem","find","r","startPage","endPage","instructionText","formatPromptWithInstruction","join","async","convertMathJaxToText","element","clone","cloneNode","querySelectorAll","script","latex","textContent","parentElement","replaceWith","document","createTextNode","remove","el","innerText","replace","extractImageUrlsFromQuestion","questionElement","imageElements","querySelector","imageBase64","img","base64","convertImageToBase64","push","canvas","createElement","ctx","getContext","width","height","drawImage","toBlob","blob","reader","FileReader","onloadend","result","onerror","readAsDataURL","handleClozeMultianswerQuestion","questionContainers","extractedText","extractTextWithSubquestions","node","textResult","childNodes","child","nodeType","Node","TEXT_NODE","ELEMENT_NODE","classList","contains","selectElement","inputElement","value","questionContainer","qIndex","then","answersArray","map","filter","a","correctAnswers","subQuestions","storage","local","markingMode","allAnswers","subq","userAnswer","correctIndex","correctOption","style","color","answerText","innerHTML","slice","answerDiv","fontWeight","insertAdjacentElement","addEventListener","placeholder","warn","markCorrectAnswersForMultianswer","catch","ensureImageString","url","publicAvailable","fetch","method","ok","isImagePublic","forceMime","status","statusText","contentType","headers","startsWith","Blob","onload","err","convertUrlToImageDataUrl","extractImagesFromTestPortal","imgs","promises","from","src","getAttribute","alt","all","Boolean","extractMultipleChoiceAnswersTestPortal","answerElements","answerBody","images","id","label","handleQuestionTestPortal","mode","userEmail","dataset","alreadyHandled","unifiedQuestion","detectedType","questionTypeInput","detectQuestionTypeTestPortal","questionTextElement","questionImages","unified","Date","now","text","metadata","difficulty","format","responseType","description","inputShort","answerLength","buildUnifiedQuestionTestPortal","correctAnswer","correctAnswerObj","toLowerCase","qType","alreadyMarked","answerContainers","correctIds","toUpperCase","includes","s","container","optionLetter","isTextEmpty","checked","dispatchEvent","Event","bubbles","originalText","inputEl","correctAnswerString","String","tagName","hiddenField","getElementById","iframe","iframeDoc","contentDocument","contentWindow","body","hint","fontSize","opacity","transition","marginTop","userSelect","add","background","border","borderRadius","marginBottom","padding","boxSizing","parentContainer","closest","appendChild","markCorrectAnswerTestPortal","waitForImageLoad","timeout","complete","naturalWidth","timer","setTimeout","clearTimeout","extractImages","extractMathContent","startTime","poll","scriptEl","mathElements","mathContent","mathEl","hasAttribute","rawHTML","latexRegex","match","exec","extractMultipleChoiceAnswersMicrosoftForms","letters","idx","answerElement","autoVal","processMicrosoftForms","questions","processingPromises","questionInfo","detectQuestionTypeMicrosoftForms","mainTitleEl","subTitleEl","mathFromMain","mathFromSub","questionContent","mathFromQuestion","extractQuestionTextMicrosoftForms","dateData","dateContainer","extractDateQuestionMicrosoftForms","openData","extractOpenTextQuestionMicrosoftForms","likertData","statementElements","optionElements","statements","commonOptions","fromCharCode","subQuestionElements","subQ","stmtEl","firstSubQ","optEl","labelEl","extractLikertQuestionMicrosoftForms","rankingData","rankingItemElements","ranking","extractRankingQuestionMicrosoftForms","buildUnifiedQuestion","isIndexMode","test","correctIndexes","correctLetters","str","n","letter","answerTextEl","isCorrect","getBoundingClientRect","boxShadow","backgroundColor","imgEl","click","charAt","display","info","whiteSpace","overflow","position","zIndex","lineHeight","wordWrap","translations","getCorrectAnswerText","focus","blur","originalPlaceholder","googlePlaceholder","this","activeElement","head","e","rankingContainer","checkRankingOrder","rankItems","setAttribute","MutationObserver","observe","childList","subtree","newOrder","numericValues","v","mapping","opt","statementRows","isMobile","row","inputSelector","svgPath","stroke","strokeWidth","mobileTarget","inverseMapping","numericAnswers","stmt","numeric","numericAnswerString","answerRepresentation","markCorrectAnswerUnified","handleQuestionMicrosoftForms","quizizzAnswersCache","quizizzInterval","lastQuestionText","extractCurrentQuizizzQuestion","domQuestion","questionParagraph","fixMathNotation","quizContainer","optionButtons","btn","optionTextEl","optionText","isMultipleChoice","question","handleQuizizzAnswers","check","autoMode","questionTextEl","interval","setInterval","clearInterval","currentQuestionData","currentQuestionText","currentUrl","href","startCheckingCurrentQuestion","stopCheckingCurrentQuestion","sessionId","quizId","parts","URL","pathname","gameIndex","indexOf","extractQuizIdFromUrl","quizPin","pinButton","previousContext","parsedContext","game","roomCode","getQuizPin","platform","quizSimpleId","pin","normalizeText","stripHtml","normalize","failedQuizitQuizzes","cache","oneWeek","updatedCache","needsUpdate","Object","entries","failed","timestamp","set","stringify","markedAnswersCache","answersData","domQuestionData","domQuestionText","matchedQuestion","questionsArray","normalizedDom","q","questionTextClean","normDom","normBackend","findMatchingQuestion","answers","textarea","questionKey","substring","buttonsToClick","ans","ansTextClean","answerNumbers","answerNum","cacheKeys","keys","markCorrectAnswersImmediate","optionsGrid","isMobileLayout","markCorrectAnswersSavemode","matchFound","normalizedAns","markCorrectAnswersDefault","highlightCurrentQuizizzQuestion","htmlString","codePointAt","extractChoiceAnswersGoogleForms","checkboxLabel","radioLabel","dropdownOption","extractOpenTextQuestionGoogleForms","handleQuestionGoogleForms","detectQuestionTypeGoogleForms","titleElement","descriptionElement","extractQuestionTextGoogleForms","gridData","rowSelectors","rowElements","selector","seenTexts","Set","rowText","has","columnHeaderRow","columnElements","columnText","firstRow","optionValue","extractGridQuestionGoogleForms","checkboxGridData","allGridTexts","possibleRows","columnSelectors","columnHeaderElements","startIndex","checkboxesInFirstRow","columnCount","defaultLabel","extractCheckboxGridGoogleForms","scaleData","scaleOptions","lowLabel","highLabel","extractScaleQuestionGoogleForms","dropdownOptions","startIdx","extractDropdownQuestionGoogleForms","dateInput","extractDateQuestionGoogleForms","timeData","hourInput","minuteInput","extractTimeQuestionGoogleForms","shortData","longData","textareaElement","sendQuestionToChatGPTGoogleForms","correctLetter","correctElement","textElement","radioElement","textEl","originalValue","firstChar","restOfText","boldSpan","correctIndices","optionIds","part","findIndex","checkboxElement","isLongAnswer","correctAnswerText","existingInfo","mainContainer","maxHeight","headerElement","contentElement","fontFamily","alertContainer","formContainer","parentDiv","focusHandler","blurHandler","original","inputHandler","saveFocusHandler","removeEventListener","saveBlurHandler","saveInputHandler","call","dropdownElement","correctOptionText","foundCorrect","scaleValue","targetOption","valueElement","radioButton","radioCircle","dateValue","dateMatch","year","month","padStart","day","date","getTime","getFullYear","getMonth","toString","getDate","formattedDate","infoElement","alertElement","parentNode","insertBefore","originalBorder","removeAttribute","hours","minutes","timeMatch","originalHourBorder","originalMinuteBorder","answerMapping","parsed","rows","statement","rowIndex","selectedColumns","checkboxes","columnValue","columnIndex","checkbox","outline","rowElement","correctColumnValue","optionIndex","radioButtons","correctRadio","markCorrectAnswer","isNaurokProcessingActive","lastQuestionContent","extractBackgroundImageUrl","extractChoiceAnswersNaurok","optionElement","imageElement","setupNaurokObserver","isProcessing","debouncedProcess","func","_len","args","_key","apply","debounce","currentSignature","optionsElements","signature","content","getCurrentQuestionSignature","log","formLoadDelay","qData","detectQuestionTypeNaurok","imageContainer","extractQuestionTextNaurok","buildUnifiedQuestionNaurok","sendQuestionToBackendNaurok","innerElement","markCorrectAnswerNaurok","handleQuestionNaurok","cursor","message","processNaurok","observer","attributeFilter","characterData","lastUrl","labelElement","sendQuestionToBackendVseosvita","charCodeAt","correctRadioButton","parentBlock","paragraphElement","imgElement","webkitUserSelect","MozUserSelect","msUserSelect","setProperty","processVseosvita","altSelectors","altQuestions","results","extractNaurokAnalytics","analytics","scoreEarned","scorePossible","scorePercentage","quizTitle","homeworkTitle","teacher","student","dateTime","totalQuestions","correctAnswersCount","incorrectAnswersCount","skippedAnswersCount","totalTime","averageTimePerQuestion","questionsScoreRatio","_rawScoreData","_rawPercentageResult","_rawAccuracyPercentage","quizInfoContainer","detailsDiv","detailElements","totalQuestionsElement","firstChild","totalQuestionsText","labelTextUpper","spanValue","valueFullText","labelColumn","nextElementSibling","valueCell","earned","total","unit","pop","parseFloat","progressBar","accuracyValText","unlabeledStatRows","countsRow","valuesText","valueDivs","correctDiv","d","spanText","incorrectDiv","skippedDiv","timeRow","totalTimeDiv","avgTimeDiv","toFixed","block","questionLineElement","questionNumberMatch","questionNumber","optLine","optionValueDiv","optionTextP","isUserAnswer","pointsLabelElement","pointsAwarded","isAnsweredCorrectly","stack","extractTestportalAnalytics","testTitle","resultPageUrl","respondentIdentifier","pointsEarned","pointsPossible","testStatus","timeTaken","timeMax","endTime","totalQuestionsCountFromHeader","respondentTile","card","resultTile","percentageEl","pointsEl","pointsMatch","hiddenResultMessage","p","timerTile","prop","questionsHeaderCounter","qContainer","questionNumberText","questionTextHTML","pointsEarnedForQuestion","pointsPossibleForQuestion","userAnswerText","possibleCorrectAnswersText","userSelectedOptionIds","numMatch","pointsMarkerEl","correctIconInHeader","incorrectIconInHeader","questionMarkersDiv","selectedAnswerIdsAttr","ids","ansEl","outerHTML","isUserSelected","answerIdFromInput","providedAnswerEl","possibleAnswerElements","paEl","totalQuestionsFound","calculatedCorrect","calculatedPossiblePoints","calculatedEarnedPoints","allQuestionsHavePoints","calculatedCorrectAnswersCount","extractVseosvitaAnalytics","scrapedAt","pageUrl","testAttemptId","dateTimeCompleted","durationInSeconds","resultStatus","partiallyCorrectAnswersCount","platformDetails","vseosvita_dateTimeFullString","vseosvita_durationString","vseosvita_finalScoreString","vseosvita_rawPointsEarned","vseosvita_rawPointsPossible","vseosvita_pointsFromCorrect","vseosvita_partiallyCorrectDetails","vseosvita_pointsFromPartiallyCorrect","vseosvita_gradingSystemDetails","vseosvita_finalGradeCalculationString","mainInfoContainer","durationOuterSpan","directDurationSpan","durationMatch","seconds","titlePElement","finalScorePElement","finalScoreBElement","scoreMatch","scoreTableContainer","scoreTable","cells","valuePCell","valueText","partialEntries","entryP","detail","count","pointsPerQuestion","earnedPoints","maxPointsPerQuestion","earnedB","possibleB","extractQuizizzAnalytics","quizMode","playerName","accuracyPercentage","accuracyPointsEarned","accuracyPointsPossible","rankString","gameScore","avgTimePerQuestionString","longestStreak","quizizz_gameTypeTitle","quizizz_accuracyRawString","quizizz_motivationalMessage","accuracySection","accuracyLabelTooltip","accText","accuracyPointsTooltipContent","gameScoreEl","statsContainer","correctEl","partialEl","incorrectEl","streakEl","reviewList","isAnsweredCorrectlyByUser","userTypedAnswer","optionsDisplayed","qTextElement","fullText","borderColor","typedAnswerEl","extractMoodleAnalytics","courseTitle","dateTimeStarted","duration","moodle_marksEarned","moodle_marksPossible","moodle_rawGradeString","moodle_rawMarksString","moodle_statusString","moodle_durationString","MOODLE_LABELS","started","completed","marks","grade","findRowTextInSummaryTable","tableBody","labelKeysOrExactLabels","th","headerText","key","some","td","title","breadcrumbItems","potentialQuizTitleEl","summaryTableBody","startedStr","parseMoodleDate","completedStr","marksMatch","gradeMatch","questionElements","qElement","moodle_state","moodle_gradeString","qNoElement","stateLower","answerSection","choice","labelFor","textContentDiv","isCorrectOption","select","selectedOption","selectedIndex","questionPartText","isCorrectIcon","matches","input","rightAnswerElement","clones","dateString","handleUnviersalSummary","scraperFunction","extractedData","toISOString","summaryKey","data","keyParts","score","urlParams","attemptId","qTextSample","generateQuizSummaryKey","storageKey","sessionStorage","payload","lastError","setItem","stripOneLetterBold","html","processGoogleForms","readyState","DOMChangesToggler","constructor","isVisible","changedElements","Map","svgElements","addedElements","changedClasses","observeConfig","attributes","attributeOldValue","setupKeyboardShortcut","injectStyles","sync","domTogglerVisible","scanExistingChanges","startObserving","hideChanges","pauseObserver","disconnect","resumeObserver","saveVisibility","hideJustAdded","meta","originalStyle","className","originalClass","originalHTML","isTrackedStyle","isAnswerElement","st","txt","isFirstLetterBoldTag","isSavemodeSpan","w","getComputedStyle","modifiedStyle","tag","par","modifiedHTML","inl","modifiedClass","originalDisplay","inlineStyles","toggle","showChanges","showNotification","togglerModifiedHtml","togglerModifiedStyle","togglerModifiedClass","togglerSavedStyles","saved","muts","schedule","fn","m","attributeName","target","cur","oldValue","t","addedNodes","ctrlKey","metaKey","shiftKey","code","preventDefault","msg","domToggler","initializeDOMToggler","domObserver","screenshotOverlay","selectionRect","state","isAutoModeEnabled","quizHandled","observers","main","dynamic","lastQuizSignature","lastFirstQuestionId","firstQuestionStaticTitle","formsHandled","processedElementIds","processedQuestionsContent","initializeContentScript","clickCount","lastClickTime","isCtrlPressed","callback","event","button","currentTime","action","stopPropagation","loadKatex","onMessage","addListener","request","sender","sendResponse","removeScreenshotOverlay","removeConfirmationButtons","cssText","handleMouseDown","handleMouseMove","handleMouseUp","handleKeyDown","analysis","popup","header","closeButton","onclick","removeChild","feedbackContainer","leftContainer","rightContainer","copyButton","explanationDiv","explanationText","clipboard","writeText","copyIcon","regenerateButton","createLoadingPopup","success","removeLoadingPopup","thumbsUpButton","sendInstantFeedback","disableFeedbackButtons","animateThumb","thumbsDownButton","disabled","isPositive","transform","renderContent","renderLaTeX","answerExtract","extractAnswer","answerDisplay","contentDiv","styleElement","startX","startY","initialX","initialY","isDragging","dragEnd","clientX","clientY","computedStyle","left","top","dx","dy","newAnalysis","spinner","newAnswerDiv","updateExistingPopup","errorType","comment","errorData","htmlElement","sendErrorToServer","source","token","idToken","uid","enabled","moodleSummary","testPortalSummary","naurokSummary","vseosvitaSummary","quizizzSummary","isOnSummaryPage","email","userName","waitForElement","runContentScript","onChanged","changes","areaName","newVal","newValue","oldVal","resetState","values","observeUrlChanges","targetSelector","detectPlatform","setupMainObserver","hostname","getSocrativeQuizSignature","signatures","Math","min","questionId","getMoodleQuizSignature","navLinks","previousRanges","newRanges","lastInfoIndex","link","infoPage","_ref","rest","buildInstructionRanges","elemId","reliableId","currentPage","qtextElem","infoText","instructionsRanges","handleInformationQuestion","detectQuestionType","extractMultipleChoiceQuestionText","processedText","answerLabelElement","pElements","preElements","divElements","extractMultipleChoiceAnswers","correctAnswersArray","answerNumber","isNumberMatch","isTextMatch","correctText","markCorrectAnswerForMultipleChoice","handleMultipleChoiceQuestion","extractTrueFalseQuestionText","extractTrueFalseAnswers","markCorrectAnswerForTrueFalse","handleTrueFalseQuestion","extractMatchingQuestionText","matchingPairs","answerTable","pairs","termElement","extractMatchingPairs","rawResponse","correctAnswerNumbers","correctAnswerNumber","optionToHighlight","markCorrectAnswersForMatching","handleMatchingQuestion","extractClozeQuestionText","clozeOptions","selects","selectOptions","extractClozeOptions","markCorrectAnswersForCloze","handleClozeQuestion","qtextElement","extractShortAnswerQuestionText","inputElements","matchingAnswer","correctAnswerDisplay","markCorrectAnswerForShortAnswer","handleShortAnswerQuestion","questionTextElementP","extractLongAnswerQuestionText","textAreaElement","editorBody","editorDocument","words","currentWordIndex","createOverlay","overlay","pointerEvents","updateOverlayPosition","overlayElement","rect","scrollY","scrollX","updateOverlayContent","currentText","remainingWords","typedWords","currentWord","setupOverlayForTextarea","hintElement","fontStyle","applyLongAnswerResponse","handleLongAnswerQuestion","extractDragAndDropQuestionText","extractDragAndDropAnswers","correctAnswerIndexes","num","dropZones","answerIndex","correctAnswerElement","dropZone","startPos","endPos","MouseEvent","cancelable","markCorrectAnswerForDragAndDrop","handleDragAndDropQuestion","extractOrderingQuestionText","listItems","extractCurrentOrder","correctOrder","correctItems","updateArrowColors","itemElement","currentIndex","upArrow","downArrow","sort","b","aText","bText","list","markCorrectOrder","handleOrderingQuestion","processMoodleQuiz","processSocrativeQuiz","newSignature","setupSocrativeObserver","questionBody","getTestPortalSignature","processTestPortalLikeMicrosoftForms","waitForMicrosoftFormsQuiz","getGoogleFormsSignature","googleFormsProcessed","successfulResults","getNaurokQuizSignature","name","getVseosvitaQuizSignature","detectQuestionTypeSocrative","extractMultipleChoiceQuestionTextSocrative","answerTextElement","extractMultipleChoiceAnswersSocrative","markCorrectAnswerForMultipleChoiceSocrative","handleMultipleChoiceQuestionSocrative","extractTrueFalseQuestionTextSocrative","extractTrueFalseAnswersSocrative","optionTextElement","markCorrectAnswerForTrueFalseSocrative","handleTrueFalseQuestionSocrative","extractOpenEndedQuestionTextSocrative","answerTextarea","markCorrectAnswerForOpenEndedSocrative","handleOpenEndedQuestionSocrative","formsCheckInterval","attempts","getPageSignatureForms","observeFormsDynamicQuestions","firstQuestion","firstElementChild","titleElem","wait","context","katex","getURL","rel","latexString","displayMode","renderToString","throwOnError","existingPopup","loadingPopup","loadingText","keyframes","previousSpinner","existingContent","existingAnswer","loadingContainer","textAlign","previousLoadingText","alignItems","justifyContent","trueFalseMatch","shortAnswerMatch","contentScriptInjected","endX","endY","isDrawing","updateSelectionRect","selectionWidth","abs","selectionHeight","buttonContainer","confirmButton","onmouseover","onmouseout","area","x","y","cancelButton","showConfirmationButtons","existingButtonContainer","feedback","extractedAnswer","screenshotDataUrl","lastScreenshot"],"sourceRoot":""}